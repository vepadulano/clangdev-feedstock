From 2a4e0ef934f2cb7955cad5f56abb78fb3fd9b6aa Mon Sep 17 00:00:00 2001
From: Chris Burr <christopher.burr@cern.ch>
Date: Tue, 13 Dec 2022 11:00:56 +0100
Subject: [PATCH] Attempt to extract clang patches from ROOT

---
 include/clang/AST/ASTContext.h                |  18 +-
 include/clang/AST/Decl.h                      |   2 +
 include/clang/AST/DeclCXX.h                   |   1 +
 include/clang/AST/DeclTemplate.h              |  37 +-
 include/clang/AST/ExternalASTSource.h         |  14 +-
 include/clang/AST/Type.h                      |   8 +-
 include/clang/Basic/Diagnostic.h              |   6 +-
 include/clang/Basic/FileEntry.h               |   1 +
 include/clang/Basic/FileManager.h             |   9 +
 include/clang/Basic/SourceLocation.h          |   1 +
 include/clang/Basic/SourceManager.h           |  21 +-
 include/clang/CodeGen/ModuleBuilder.h         |  10 +
 include/clang/Frontend/CompilerInvocation.h   |  17 +
 include/clang/Lex/DirectoryLookup.h           |   3 +-
 include/clang/Lex/HeaderSearch.h              |   6 +-
 include/clang/Lex/Preprocessor.h              |  82 ++++-
 include/clang/Parse/Parser.h                  |  40 ++-
 include/clang/Sema/Sema.h                     |  86 ++++-
 include/clang/Serialization/ASTReader.h       |   9 +
 .../clang/Serialization/GlobalModuleIndex.h   |  24 +-
 lib/AST/ASTContext.cpp                        |  13 +-
 lib/AST/ASTImporter.cpp                       |   2 +-
 lib/AST/DeclTemplate.cpp                      |  89 +++--
 lib/AST/ExternalASTSource.cpp                 |  20 +-
 lib/AST/ODRHash.cpp                           |  67 ++--
 lib/AST/TemplateBase.cpp                      |   8 +-
 lib/AST/TypePrinter.cpp                       |  20 +-
 lib/Analysis/CFG.cpp                          |  34 +-
 lib/Analysis/UninitializedValues.cpp          |  26 +-
 lib/Basic/Diagnostic.cpp                      |  28 +-
 lib/Basic/FileManager.cpp                     |  45 ++-
 lib/Basic/SourceManager.cpp                   |  33 +-
 lib/Basic/Targets/OSTargets.h                 |   4 +-
 lib/Basic/Targets/PPC.cpp                     |   5 +-
 lib/Basic/Targets/Sparc.h                     |   3 +
 lib/CodeGen/CGCUDANV.cpp                      |   4 +-
 lib/CodeGen/CGDeclCXX.cpp                     |  12 +-
 lib/CodeGen/CGExprCXX.cpp                     |   5 +-
 lib/CodeGen/CodeGenModule.cpp                 |  31 +-
 lib/CodeGen/CodeGenModule.h                   |  26 +-
 lib/CodeGen/ModuleBuilder.cpp                 | 204 ++++++++++-
 lib/Driver/ToolChains/Arch/AArch64.cpp        |  15 +-
 lib/Format/TokenAnnotator.cpp                 |  42 +--
 lib/Format/UnwrappedLineParser.cpp            |   5 +-
 lib/Format/WhitespaceManager.cpp              |  16 +-
 lib/Frontend/CompilerInvocation.cpp           |   7 +-
 lib/Frontend/VerifyDiagnosticConsumer.cpp     |   5 +
 lib/Headers/__clang_cuda_runtime_wrapper.h    |   6 +-
 lib/Lex/HeaderSearch.cpp                      |  36 +-
 lib/Lex/Lexer.cpp                             |   4 +
 lib/Lex/PPDirectives.cpp                      |   7 +-
 lib/Lex/PPMacroExpansion.cpp                  |  14 +
 lib/Lex/Preprocessor.cpp                      |  37 ++
 lib/Parse/ParsePragma.cpp                     |   8 +
 lib/Parse/Parser.cpp                          |  23 +-
 lib/Sema/HackForDefaultTemplateArg.h          |  52 +++
 lib/Sema/Sema.cpp                             |  18 +-
 lib/Sema/SemaCXXScopeSpec.cpp                 |  33 +-
 lib/Sema/SemaDecl.cpp                         |  34 +-
 lib/Sema/SemaDeclCXX.cpp                      |   5 +-
 lib/Sema/SemaExpr.cpp                         |  35 +-
 lib/Sema/SemaExprCXX.cpp                      |   3 +-
 lib/Sema/SemaLookup.cpp                       |   8 +-
 lib/Sema/SemaModule.cpp                       |   2 +-
 lib/Sema/SemaTemplate.cpp                     |  98 +++++-
 lib/Sema/SemaTemplateInstantiate.cpp          |  16 +-
 lib/Sema/SemaType.cpp                         |   4 +-
 lib/Sema/TreeTransform.h                      |  21 +-
 lib/Serialization/ASTReader.cpp               | 124 +++++--
 lib/Serialization/ASTReaderDecl.cpp           |  40 ++-
 lib/Serialization/ASTReaderInternals.h        |   2 +-
 lib/Serialization/ASTWriter.cpp               |  23 +-
 lib/Serialization/ASTWriterDecl.cpp           |  74 +++-
 lib/Serialization/GlobalModuleIndex.cpp       | 112 ++++--
 lib/Serialization/ModuleManager.cpp           |  11 +-
 lib/Tooling/DumpTool/ClangSrcLocDump.cpp      | 318 +++++++++---------
 76 files changed, 1768 insertions(+), 564 deletions(-)
 create mode 100644 lib/Sema/HackForDefaultTemplateArg.h

diff --git a/include/clang/AST/ASTContext.h b/include/clang/AST/ASTContext.h
index 34299581..08b79abc 100644
--- a/include/clang/AST/ASTContext.h
+++ b/include/clang/AST/ASTContext.h
@@ -252,6 +252,10 @@ class ASTContext : public RefCountedBase<ASTContext> {
                                      ASTContext&>
     SubstTemplateTemplateParmPacks;
 
+  /// Generation number for this external AST source. Must be increased
+  /// whenever we might have added new redeclarations for existing decls.
+  uint32_t CurrentGeneration = 0;
+
   /// The set of nested name specifiers.
   ///
   /// This set is managed by the NestedNameSpecifier class.
@@ -661,6 +665,15 @@ public:
   /// use ParentMapContext::getParents() directly.
   template <typename NodeT> DynTypedNodeList getParents(const NodeT &Node);
 
+  uint32_t getGeneration() const { return CurrentGeneration; }
+  uint32_t incrementGeneration() {
+    uint32_t OldGeneration = CurrentGeneration;
+    CurrentGeneration++;
+    assert(CurrentGeneration > OldGeneration &&
+           "Overflowed generation counter");
+    return OldGeneration;
+  }
+
   const clang::PrintingPolicy &getPrintingPolicy() const {
     return PrintingPolicy;
   }
@@ -1531,7 +1544,8 @@ public:
                              QualType equivalentType);
 
   QualType getSubstTemplateTypeParmType(const TemplateTypeParmType *Replaced,
-                                        QualType Replacement) const;
+                                        QualType Replacement,
+                                        bool AllowNonCanonical = false) const;
   QualType getSubstTemplateTypeParmPackType(
                                           const TemplateTypeParmType *Replaced,
                                             const TemplateArgument &ArgPack);
@@ -3347,7 +3361,7 @@ typename clang::LazyGenerationalUpdatePtr<Owner, T, Update>::ValueType
   // include ASTContext.h. We explicitly instantiate it for all relevant types
   // in ASTContext.cpp.
   if (auto *Source = Ctx.getExternalSource())
-    return new (Ctx) LazyData(Source, Value);
+    return new (Ctx) LazyData(&Ctx, Source, Value);
   return Value;
 }
 
diff --git a/include/clang/AST/Decl.h b/include/clang/AST/Decl.h
index 510bf897..66842653 100644
--- a/include/clang/AST/Decl.h
+++ b/include/clang/AST/Decl.h
@@ -49,6 +49,8 @@
 #include <string>
 #include <utility>
 
+namespace cling { class DeclUnloader; }
+
 namespace clang {
 
 class ASTContext;
diff --git a/include/clang/AST/DeclCXX.h b/include/clang/AST/DeclCXX.h
index 0d5ad40f..88a1a8dd 100644
--- a/include/clang/AST/DeclCXX.h
+++ b/include/clang/AST/DeclCXX.h
@@ -261,6 +261,7 @@ class CXXRecordDecl : public RecordDecl {
   friend class ASTWriter;
   friend class DeclContext;
   friend class LambdaExpr;
+  friend class ::cling::DeclUnloader;
 
   friend void FunctionDecl::setPure(bool);
   friend void TagDecl::startDefinition();
diff --git a/include/clang/AST/DeclTemplate.h b/include/clang/AST/DeclTemplate.h
index cbaa287f..e6b261ed 100644
--- a/include/clang/AST/DeclTemplate.h
+++ b/include/clang/AST/DeclTemplate.h
@@ -261,6 +261,9 @@ public:
   static TemplateArgumentList *CreateCopy(ASTContext &Context,
                                           ArrayRef<TemplateArgument> Args);
 
+  /// \brief Create hash for the given arguments.
+  static unsigned ComputeODRHash(ArrayRef<TemplateArgument> Args);
+
   /// Construct a new, temporary template argument list on the stack.
   ///
   /// The template argument list does not own the template arguments
@@ -763,6 +766,26 @@ class RedeclarableTemplateDecl : public TemplateDecl,
   }
 
   void anchor() override;
+  struct LazySpecializationInfo {
+    uint32_t DeclID = ~0U;
+    unsigned ODRHash = ~0U;
+    bool IsPartial = false;
+    LazySpecializationInfo(uint32_t ID, unsigned Hash = ~0U,
+                           bool Partial = false)
+      : DeclID(ID), ODRHash(Hash), IsPartial(Partial) { }
+    LazySpecializationInfo() { }
+    bool operator<(const LazySpecializationInfo &Other) const {
+      return DeclID < Other.DeclID;
+    }
+    bool operator==(const LazySpecializationInfo &Other) const {
+      assert((DeclID != Other.DeclID || ODRHash == Other.ODRHash) &&
+             "Hashes differ!");
+      assert((DeclID != Other.DeclID || IsPartial == Other.IsPartial) &&
+             "Both must be the same kinds!");
+      return DeclID == Other.DeclID;
+    }
+  };
+
 protected:
   template <typename EntryType> struct SpecEntryTraits {
     using DeclType = EntryType;
@@ -803,7 +826,13 @@ protected:
     return SpecIterator<EntryType>(isEnd ? Specs.end() : Specs.begin());
   }
 
-  void loadLazySpecializationsImpl() const;
+  void loadLazySpecializationsImpl(bool OnlyPartial = false) const;
+
+  ///\returns true if any lazy specialization was loaded.
+  bool loadLazySpecializationsImpl(llvm::ArrayRef<TemplateArgument> Args,
+                                   TemplateParameterList *TPL = nullptr) const;
+
+  Decl *loadLazySpecializationImpl(LazySpecializationInfo &LazySpecInfo) const;
 
   template <class EntryType, typename ...ProfileArguments>
   typename SpecEntryTraits<EntryType>::DeclType*
@@ -830,7 +859,7 @@ protected:
     ///
     /// The first value in the array is the number of specializations/partial
     /// specializations that follow.
-    uint32_t *LazySpecializations = nullptr;
+    LazySpecializationInfo *LazySpecializations = nullptr;
   };
 
   /// Pointer to the common data shared by all declarations of this
@@ -2285,7 +2314,7 @@ public:
   friend class ASTDeclWriter;
 
   /// Load any lazily-loaded specializations from the external source.
-  void LoadLazySpecializations() const;
+  void LoadLazySpecializations(bool OnlyPartial = false) const;
 
   /// Get the underlying class declarations of the template.
   CXXRecordDecl *getTemplatedDecl() const {
@@ -3114,7 +3143,7 @@ public:
   friend class ASTDeclWriter;
 
   /// Load any lazily-loaded specializations from the external source.
-  void LoadLazySpecializations() const;
+  void LoadLazySpecializations(bool OnlyPartial = false) const;
 
   /// Get the underlying variable declarations of the template.
   VarDecl *getTemplatedDecl() const {
diff --git a/include/clang/AST/ExternalASTSource.h b/include/clang/AST/ExternalASTSource.h
index b1851afc..4b0f57a8 100644
--- a/include/clang/AST/ExternalASTSource.h
+++ b/include/clang/AST/ExternalASTSource.h
@@ -90,7 +90,7 @@ public:
   /// Get the current generation of this AST source. This number
   /// is incremented each time the AST source lazily extends an existing
   /// entity.
-  uint32_t getGeneration() const { return CurrentGeneration; }
+  uint32_t getGeneration(const ASTContext &C) const;
 
   /// Resolve a declaration ID into a declaration, potentially
   /// building a new declaration.
@@ -389,12 +389,14 @@ struct LazyGenerationalUpdatePtr {
   /// A cache of the value of this pointer, in the most recent generation in
   /// which we queried it.
   struct LazyData {
+    const ASTContext *Context;
     ExternalASTSource *ExternalSource;
     uint32_t LastGeneration = 0;
     T LastValue;
 
-    LazyData(ExternalASTSource *Source, T Value)
-        : ExternalSource(Source), LastValue(Value) {}
+    LazyData(const ASTContext *Context, ExternalASTSource *Source, T Value)
+        : Context(Context), ExternalSource(Source), LastGeneration(0),
+          LastValue(Value) {}
   };
 
   // Our value is represented as simply T if there is no external AST source.
@@ -436,8 +438,10 @@ public:
   /// Get the value of this pointer, updating its owner if necessary.
   T get(Owner O) {
     if (auto *LazyVal = Value.template dyn_cast<LazyData *>()) {
-      if (LazyVal->LastGeneration != LazyVal->ExternalSource->getGeneration()) {
-        LazyVal->LastGeneration = LazyVal->ExternalSource->getGeneration();
+      if (LazyVal->LastGeneration !=
+          LazyVal->ExternalSource->getGeneration(*LazyVal->Context)) {
+        LazyVal->LastGeneration =
+            LazyVal->ExternalSource->getGeneration(*LazyVal->Context);
         (LazyVal->ExternalSource->*Update)(O);
       }
       return LazyVal->LastValue;
diff --git a/include/clang/AST/Type.h b/include/clang/AST/Type.h
index 9f46d533..adb0d909 100644
--- a/include/clang/AST/Type.h
+++ b/include/clang/AST/Type.h
@@ -4848,10 +4848,12 @@ class SubstTemplateTypeParmType : public Type, public llvm::FoldingSetNode {
 
   // The original type parameter.
   const TemplateTypeParmType *Replaced;
+  QualType Replacement;
 
-  SubstTemplateTypeParmType(const TemplateTypeParmType *Param, QualType Canon)
+  SubstTemplateTypeParmType(const TemplateTypeParmType *Param,
+                            QualType ReplacementType, QualType Canon)
       : Type(SubstTemplateTypeParm, Canon, Canon->getDependence()),
-        Replaced(Param) {}
+        Replaced(Param), Replacement(ReplacementType) {}
 
 public:
   /// Gets the template parameter that was substituted for.
@@ -4862,7 +4864,7 @@ public:
   /// Gets the type that was substituted for the template
   /// parameter.
   QualType getReplacementType() const {
-    return getCanonicalTypeInternal();
+    return Replacement;
   }
 
   bool isSugared() const { return true; }
diff --git a/include/clang/Basic/Diagnostic.h b/include/clang/Basic/Diagnostic.h
index 3b915fb1..19acd97f 100644
--- a/include/clang/Basic/Diagnostic.h
+++ b/include/clang/Basic/Diagnostic.h
@@ -887,9 +887,9 @@ public:
     LastDiagLevel = Other.LastDiagLevel;
   }
 
-  /// Reset the state of the diagnostic object to its initial
-  /// configuration.
-  void Reset();
+  /// Reset the state of the diagnostic object to its initial configuration.
+  /// \param[in] soft - if true, doesn't reset the diagnostic mappings and state
+  void Reset(bool soft = false);
 
   //===--------------------------------------------------------------------===//
   // DiagnosticsEngine classification and reporting interfaces.
diff --git a/include/clang/Basic/FileEntry.h b/include/clang/Basic/FileEntry.h
index 6e91b42e..8b745fc9 100644
--- a/include/clang/Basic/FileEntry.h
+++ b/include/clang/Basic/FileEntry.h
@@ -365,6 +365,7 @@ public:
   FileEntryRef getLastRef() const { return *LastRef; }
 
   StringRef tryGetRealPathName() const { return RealPathName; }
+  bool isOpen() const { return (bool)File; }
   bool isValid() const { return IsValid; }
   off_t getSize() const { return Size; }
   unsigned getUID() const { return UID; }
diff --git a/include/clang/Basic/FileManager.h b/include/clang/Basic/FileManager.h
index 974771a8..f7c4cd13 100644
--- a/include/clang/Basic/FileManager.h
+++ b/include/clang/Basic/FileManager.h
@@ -32,6 +32,7 @@
 #include <map>
 #include <memory>
 #include <string>
+#include <set>
 
 namespace llvm {
 
@@ -105,6 +106,11 @@ class FileManager : public RefCountedBase<FileManager> {
   /// The canonical names of files and directories .
   llvm::DenseMap<const void *, llvm::StringRef> CanonicalNames;
 
+  std::set<const FileEntry*> FileEntriesToReread;
+
+  /// The canonical names of directories.
+  llvm::DenseMap<const DirectoryEntry *, llvm::StringRef> CanonicalDirNames;
+
   /// Storage for canonical names that we have computed.
   llvm::BumpPtrAllocator CanonicalNameStorage;
 
@@ -293,6 +299,9 @@ public:
   std::error_code getNoncachedStatValue(StringRef Path,
                                         llvm::vfs::Status &Result);
 
+  /// Remove the real file \p Entry from the cache.
+  void invalidateCache(FileEntry *Entry);
+
   /// If path is not absolute and FileSystemOptions set the working
   /// directory, the path is modified to be relative to the given
   /// working directory.
diff --git a/include/clang/Basic/SourceLocation.h b/include/clang/Basic/SourceLocation.h
index 540de23b..28810d21 100644
--- a/include/clang/Basic/SourceLocation.h
+++ b/include/clang/Basic/SourceLocation.h
@@ -431,6 +431,7 @@ public:
   /// \returns true if this source location comes before 'Loc', false otherwise.
   bool isBeforeInTranslationUnitThan(FullSourceLoc Loc) const {
     assert(Loc.isValid());
+    if (!SrcMgr) return true; // assume command line is before Loc
     assert(SrcMgr == Loc.SrcMgr && "Loc comes from another SourceManager!");
     return isBeforeInTranslationUnitThan((SourceLocation)Loc);
   }
diff --git a/include/clang/Basic/SourceManager.h b/include/clang/Basic/SourceManager.h
index cc29c24f..8bebe0af 100644
--- a/include/clang/Basic/SourceManager.h
+++ b/include/clang/Basic/SourceManager.h
@@ -243,7 +243,7 @@ public:
 
   /// Set the buffer.
   void setBuffer(std::unique_ptr<llvm::MemoryBuffer> B) {
-    IsBufferInvalid = false;
+    IsBufferInvalid = !B;
     Buffer = std::move(B);
   }
 
@@ -797,6 +797,8 @@ public:
 
   void clearIDTables();
 
+  void invalidateCache(FileID FID);
+
   /// Initialize this source manager suitably to replay the compilation
   /// described by \p Old. Requires that \p Old outlive \p *this.
   void initializeForReplay(const SourceManager &Old);
@@ -1468,24 +1470,35 @@ public:
 
   /// Returns whether \p Loc is located in a <built-in> file.
   bool isWrittenInBuiltinFile(SourceLocation Loc) const {
-    StringRef Filename(getPresumedLoc(Loc).getFilename());
+    PresumedLoc Presumed = getPresumedLoc(Loc);
+    if (Presumed.isInvalid())
+      return false;
+    StringRef Filename(Presumed.getFilename());
     return Filename.equals("<built-in>");
   }
 
   /// Returns whether \p Loc is located in a <command line> file.
   bool isWrittenInCommandLineFile(SourceLocation Loc) const {
-    StringRef Filename(getPresumedLoc(Loc).getFilename());
+    PresumedLoc Presumed = getPresumedLoc(Loc);
+    if (Presumed.isInvalid())
+      return false;
+    StringRef Filename(Presumed.getFilename());
     return Filename.equals("<command line>");
   }
 
   /// Returns whether \p Loc is located in a <scratch space> file.
   bool isWrittenInScratchSpace(SourceLocation Loc) const {
-    StringRef Filename(getPresumedLoc(Loc).getFilename());
+    PresumedLoc Presumed = getPresumedLoc(Loc);
+    if (Presumed.isInvalid())
+      return false;
+    StringRef Filename(Presumed.getFilename());
     return Filename.equals("<scratch space>");
   }
 
   /// Returns if a SourceLocation is in a system header.
   bool isInSystemHeader(SourceLocation Loc) const {
+    if (Loc.isInvalid())
+      return false;
     return isSystem(getFileCharacteristic(Loc));
   }
 
diff --git a/include/clang/CodeGen/ModuleBuilder.h b/include/clang/CodeGen/ModuleBuilder.h
index f9d056ed..91bb5f07 100644
--- a/include/clang/CodeGen/ModuleBuilder.h
+++ b/include/clang/CodeGen/ModuleBuilder.h
@@ -17,9 +17,11 @@
 
 namespace llvm {
   class Constant;
+  class GlobalValue;
   class LLVMContext;
   class Module;
   class StringRef;
+  class raw_ostream;
 }
 
 namespace clang {
@@ -84,9 +86,17 @@ public:
   ///   definition has been registered with this code generator.
   llvm::Constant *GetAddrOfGlobal(GlobalDecl decl, bool isForDefinition);
 
+  void print(llvm::raw_ostream& out);
+
   /// Create a new \c llvm::Module after calling HandleTranslationUnit. This
   /// enable codegen in interactive processing environments.
   llvm::Module* StartModule(llvm::StringRef ModuleName, llvm::LLVMContext &C);
+
+  void forgetGlobal(llvm::GlobalValue* GV);
+  void forgetDecl(const GlobalDecl& GD, llvm::StringRef MangledName);
+  llvm::Module* StartModule(llvm::StringRef ModuleName,
+                            llvm::LLVMContext& C,
+                            const CodeGenOptions& CGO);
 };
 
 /// CreateLLVMCodeGen - Create a CodeGenerator instance.
diff --git a/include/clang/Frontend/CompilerInvocation.h b/include/clang/Frontend/CompilerInvocation.h
index 2245439d..1c1a057e 100644
--- a/include/clang/Frontend/CompilerInvocation.h
+++ b/include/clang/Frontend/CompilerInvocation.h
@@ -22,6 +22,8 @@
 #include "clang/StaticAnalyzer/Core/AnalyzerOptions.h"
 #include "llvm/ADT/IntrusiveRefCntPtr.h"
 #include "llvm/ADT/ArrayRef.h"
+#include "llvm/Support/VirtualFileSystem.h"
+
 #include <memory>
 #include <string>
 
@@ -147,6 +149,9 @@ protected:
   /// Options controlling preprocessed output.
   PreprocessorOutputOptions PreprocessorOutputOpts;
 
+  /// List of overlay files
+  IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> Overlay = new llvm::vfs::OverlayFileSystem(llvm::vfs::getRealFileSystem());
+
 public:
   MigratorOptions &getMigratorOpts() { return MigratorOpts; }
   const MigratorOptions &getMigratorOpts() const { return MigratorOpts; }
@@ -162,6 +167,18 @@ public:
     return DependencyOutputOpts;
   }
 
+  void addOverlay(const IntrusiveRefCntPtr<llvm::vfs::FileSystem>& FS) {
+    Overlay->pushOverlay(FS);
+  }
+
+  IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> &getOverlay() {
+    return Overlay;
+  }
+
+  const IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> &getOverlay() const {
+    return Overlay;
+  }
+
   FileSystemOptions &getFileSystemOpts() { return FileSystemOpts; }
 
   const FileSystemOptions &getFileSystemOpts() const {
diff --git a/include/clang/Lex/DirectoryLookup.h b/include/clang/Lex/DirectoryLookup.h
index da2ae9fc..9e92a6e5 100644
--- a/include/clang/Lex/DirectoryLookup.h
+++ b/include/clang/Lex/DirectoryLookup.h
@@ -182,7 +182,8 @@ public:
              SmallVectorImpl<char> *RelativePath, Module *RequestingModule,
              ModuleMap::KnownHeader *SuggestedModule,
              bool &InUserSpecifiedSystemFramework, bool &IsFrameworkFound,
-             bool &IsInHeaderMap, SmallVectorImpl<char> &MappedName) const;
+             bool &IsInHeaderMap, SmallVectorImpl<char> &MappedName,
+             bool OpenFile = true) const;
 
 private:
   Optional<FileEntryRef> DoFrameworkLookup(
diff --git a/include/clang/Lex/HeaderSearch.h b/include/clang/Lex/HeaderSearch.h
index a35a394f..858d7254 100644
--- a/include/clang/Lex/HeaderSearch.h
+++ b/include/clang/Lex/HeaderSearch.h
@@ -416,7 +416,8 @@ public:
       SmallVectorImpl<char> *SearchPath, SmallVectorImpl<char> *RelativePath,
       Module *RequestingModule, ModuleMap::KnownHeader *SuggestedModule,
       bool *IsMapped, bool *IsFrameworkFound, bool SkipCache = false,
-      bool BuildSystemModule = false);
+      bool BuildSystemModule = false, bool OpenFile = true,
+      bool CacheFailures = true);
 
   /// Look up a subframework for the specified \#include file.
   ///
@@ -707,7 +708,8 @@ private:
   getFileAndSuggestModule(StringRef FileName, SourceLocation IncludeLoc,
                           const DirectoryEntry *Dir, bool IsSystemHeaderDir,
                           Module *RequestingModule,
-                          ModuleMap::KnownHeader *SuggestedModule);
+                          ModuleMap::KnownHeader *SuggestedModule,
+                          bool OpenFile = true, bool CacheFailures = true);
 
 public:
   /// Retrieve the module map.
diff --git a/include/clang/Lex/Preprocessor.h b/include/clang/Lex/Preprocessor.h
index fe2327f0..724a53aa 100644
--- a/include/clang/Lex/Preprocessor.h
+++ b/include/clang/Lex/Preprocessor.h
@@ -1145,6 +1145,11 @@ public:
     return appendDefMacroDirective(II, MI, MI->getDefinitionLoc());
   }
 
+  /// Remove a IdentifierInfo and MacroDirective from the history.
+  /// Given an IdentifierInfo and a MacroDirective we can remove them from
+  /// the macros vector.
+  void removeMacro(IdentifierInfo *II, MacroDirective *MD);
+
   /// Set a MacroDirective that was loaded from a PCH file.
   void setLoadedMacroDirective(IdentifierInfo *II, MacroDirective *ED,
                                MacroDirective *MD);
@@ -1374,6 +1379,74 @@ public:
                      IsReinject);
   }
 
+  /// A RAII object to temporarily reset PP's state and restore it.
+  class CleanupAndRestoreCacheRAII {
+  private:
+    Preprocessor &PP;
+    CachedTokensTy::size_type SavedCachedLexPos;
+    CachedTokensTy SavedCachedTokens;
+    std::vector<IncludeStackInfo> SavedStack;
+    Lexer *SavedCurLexer;
+    PreprocessorLexer *SavedCurPPLexer;
+    TokenLexer* SavedCurTokenLexer;
+    const DirectoryLookup *SavedCurDirLookup;
+    enum CurLexerKind SavedCurLexerKind;
+    unsigned SavedLexLevel;
+
+  public:
+    CleanupAndRestoreCacheRAII(Preprocessor &PP)
+      : PP(PP), SavedCachedLexPos(PP.CachedLexPos),
+        SavedCachedTokens(PP.CachedTokens),
+        SavedStack(std::move(PP.IncludeMacroStack)),
+        SavedCurLexer(PP.CurLexer.release()),
+        SavedCurPPLexer(PP.CurPPLexer),
+        SavedCurTokenLexer(PP.CurTokenLexer.release()),
+        SavedCurDirLookup(PP.CurDirLookup),
+        SavedCurLexerKind(PP.CurLexerKind),
+        SavedLexLevel(PP.LexLevel)
+    {
+      PP.CachedLexPos = 0;
+      PP.CachedTokens.clear();
+      PP.IncludeMacroStack.clear();
+      PP.CurLexer.reset(0);
+      PP.CurPPLexer = 0;
+      PP.CurTokenLexer.reset(0);
+      PP.CurDirLookup = 0;
+      PP.CurLexerKind = CLK_CachingLexer;
+      PP.LexLevel = 0;
+    }
+
+    void pop() {
+      if (SavedCurLexerKind == (enum CurLexerKind)~0U)
+        return;
+
+      //ExitCachingLexMode();
+      PP.CachedLexPos = SavedCachedLexPos;
+      PP.CachedTokens = SavedCachedTokens;
+      PP.IncludeMacroStack = std::move(SavedStack);
+      PP.CurLexer.reset(SavedCurLexer);
+      PP.CurPPLexer = SavedCurPPLexer;
+      PP.CurTokenLexer.reset(SavedCurTokenLexer);
+      PP.CurDirLookup = SavedCurDirLookup;
+      PP.CurLexerKind = SavedCurLexerKind;
+      PP.LexLevel = SavedLexLevel;
+
+      SavedCachedLexPos = 0;
+      SavedCachedTokens.clear();
+      SavedStack.clear();
+      SavedCurLexer = 0;
+      SavedCurPPLexer = 0;
+      SavedCurTokenLexer = 0;
+      SavedCurDirLookup = 0;
+      SavedCurLexerKind = (enum CurLexerKind)~0U;
+      SavedLexLevel = ~0U;
+    }
+
+    ~CleanupAndRestoreCacheRAII() {
+      pop();
+    }
+  };
+
   /// Pop the current lexer/macro exp off the top of the lexer stack.
   ///
   /// This should only be used in situations where the current state of the
@@ -1859,6 +1932,12 @@ public:
   void DumpMacro(const MacroInfo &MI) const;
   void dumpMacroInfo(const IdentifierInfo *II);
 
+  /// Print a Macro to an ostream used for ClangInternalState
+  /// Same as dump, but without orinting source location.
+  void printMacros(raw_ostream &OS) const;
+  void printMacro(const IdentifierInfo* II, const MacroDirective *MD,
+                  llvm::raw_ostream &OS) const;
+
   /// Given a location that specifies the start of a
   /// token, return a new location that specifies a character within the token.
   SourceLocation AdvanceToTokenCharacter(SourceLocation TokStart,
@@ -2017,7 +2096,8 @@ public:
              const DirectoryLookup *&CurDir, SmallVectorImpl<char> *SearchPath,
              SmallVectorImpl<char> *RelativePath,
              ModuleMap::KnownHeader *SuggestedModule, bool *IsMapped,
-             bool *IsFrameworkFound, bool SkipCache = false);
+             bool *IsFrameworkFound, bool SkipCache = false,
+             bool OpenFile = true, bool CacheFailures = true);
 
   /// Get the DirectoryLookup structure used to find the current
   /// FileEntry, if CurLexer is non-null and if applicable.
diff --git a/include/clang/Parse/Parser.h b/include/clang/Parse/Parser.h
index 8eb3f902..26b6815c 100644
--- a/include/clang/Parse/Parser.h
+++ b/include/clang/Parse/Parser.h
@@ -30,6 +30,8 @@
 #include <memory>
 #include <stack>
 
+namespace cling { class ParserStateRAII; }
+
 namespace clang {
   class PragmaHandler;
   class Scope;
@@ -52,6 +54,7 @@ namespace clang {
   struct OMPTraitSelector;
   struct OMPTraitSet;
   class OMPTraitInfo;
+  class DestroyTemplateIdAnnotationsRAIIObj;
 
 /// Parser - This implements a parser for the C family of languages.  After
 /// parsing units of the grammar, productions are invoked to handle whatever has
@@ -65,6 +68,8 @@ class Parser : public CodeCompletionHandler {
   friend class ObjCDeclContextSwitch;
   friend class ParenBraceBracketBalancer;
   friend class BalancedDelimiterTracker;
+  friend class DestroyTemplateIdAnnotationsRAIIObj;
+  friend class ::cling::ParserStateRAII;
 
   Preprocessor &PP;
 
@@ -429,8 +434,11 @@ class Parser : public CodeCompletionHandler {
   /// a statement expression and builds a suitable expression statement.
   StmtResult handleExprStmt(ExprResult E, ParsedStmtContext StmtCtx);
 
+  bool IsTemporary;
+
 public:
-  Parser(Preprocessor &PP, Sema &Actions, bool SkipFunctionBodies);
+  Parser(Preprocessor &PP, Sema &Actions, bool SkipFunctionBodies, 
+         bool isTemp = false);
   ~Parser() override;
 
   const LangOptions &getLangOpts() const { return PP.getLangOpts(); }
@@ -440,6 +448,34 @@ public:
   AttributeFactory &getAttrFactory() { return AttrFactory; }
 
   const Token &getCurToken() const { return Tok; }
+
+  /// A RAII object to temporarily reset PP's state and restore it.
+  class ParserCurTokRestoreRAII {
+  private:
+    Parser &P;
+    Token SavedTok;
+
+  public:
+    ParserCurTokRestoreRAII(Parser &P)
+      : P(P), SavedTok(P.Tok) 
+    {
+    }
+
+    void pop() {
+      if (SavedTok.is(tok::unknown))
+        return;
+
+      P.Tok = SavedTok;
+      
+      SavedTok.startToken();
+    }
+
+    ~ParserCurTokRestoreRAII() {
+      pop();
+    }
+  };
+
+
   Scope *getCurScope() const { return Actions.getCurScope(); }
   void incrementMSManglingNumber() const {
     return Actions.incrementMSManglingNumber();
@@ -1171,7 +1207,7 @@ public:
     return Diag(Tok, DiagID);
   }
 
-private:
+protected:
   void SuggestParentheses(SourceLocation Loc, unsigned DK,
                           SourceRange ParenRange);
   void CheckNestedObjCContexts(SourceLocation AtLoc);
diff --git a/include/clang/Sema/Sema.h b/include/clang/Sema/Sema.h
index d8b2546b..9d376ba6 100644
--- a/include/clang/Sema/Sema.h
+++ b/include/clang/Sema/Sema.h
@@ -150,6 +150,7 @@ namespace clang {
   typedef ArrayRef<std::pair<IdentifierInfo *, SourceLocation>> ModuleIdPath;
   class ModuleLoader;
   class MultiLevelTemplateArgumentList;
+  class MultiplexExternalSemaSource;
   class NamedDecl;
   class ObjCCategoryDecl;
   class ObjCCategoryImplDecl;
@@ -359,8 +360,9 @@ class Sema final {
   ///Source of additional semantic information.
   ExternalSemaSource *ExternalSource;
 
-  ///Whether Sema has generated a multiplexer and has to delete it.
-  bool isMultiplexExternalSource;
+  ///Source of additional semantic information if it is a multiplexer.
+  llvm::IntrusiveRefCntPtr<MultiplexExternalSemaSource>
+      MultiplexExternalSource;
 
   static bool mightHaveNonExternalLinkage(const DeclaratorDecl *FD);
 
@@ -1036,6 +1038,41 @@ public:
            isConstantEvaluatedOverride;
   }
 
+  /// A RAII object to temporarily push a decl context and scope.
+  class ContextAndScopeRAII {
+  private:
+    Sema &S;
+    DeclContext *SavedContext;
+    Scope *SavedScope;
+    ProcessingContextState SavedContextState;
+    QualType SavedCXXThisTypeOverride;
+
+  public:
+    ContextAndScopeRAII(Sema &S, DeclContext *ContextToPush, Scope *ScopeToPush)
+      : S(S), SavedContext(S.CurContext), SavedScope(S.CurScope),
+        SavedContextState(S.DelayedDiagnostics.pushUndelayed()),
+        SavedCXXThisTypeOverride(S.CXXThisTypeOverride)
+    {
+      assert(ContextToPush && "pushing null context");
+      S.CurContext = ContextToPush;
+      S.CurScope = ScopeToPush;
+    }
+
+    void pop() {
+      if (!SavedContext) return;
+      S.CurContext = SavedContext;
+      S.CurScope = SavedScope;
+      S.DelayedDiagnostics.popUndelayed(SavedContextState);
+      S.CXXThisTypeOverride = SavedCXXThisTypeOverride;
+      SavedContext = 0;
+      SavedScope = 0;
+    }
+
+    ~ContextAndScopeRAII() {
+      pop();
+    }
+  };
+
   /// RAII object to handle the state changes required to synthesize
   /// a function body.
   class SynthesizedFunctionScope {
@@ -1077,6 +1114,27 @@ public:
     }
   };
 
+  class DelayedInfoRAII {
+    Sema &S;
+    SmallVector<std::pair<const CXXMethodDecl*, const CXXMethodDecl*>, 2>
+      DelayedOverridingExceptionSpecChecks;
+    SmallVector<std::pair<FunctionDecl*, FunctionDecl*>, 2>
+      DelayedEquivalentExceptionSpecChecks;
+  public:
+    DelayedInfoRAII(Sema& S): S(S) {
+      std::swap(S.DelayedOverridingExceptionSpecChecks,
+                DelayedOverridingExceptionSpecChecks);
+      std::swap(S.DelayedEquivalentExceptionSpecChecks,
+                DelayedEquivalentExceptionSpecChecks);
+    }
+    ~DelayedInfoRAII() {
+      std::swap(S.DelayedOverridingExceptionSpecChecks,
+                DelayedOverridingExceptionSpecChecks);
+      std::swap(S.DelayedEquivalentExceptionSpecChecks,
+                DelayedEquivalentExceptionSpecChecks);
+    }
+  };
+
   /// WeakUndeclaredIdentifiers - Identifiers contained in
   /// \#pragma weak before declared. rare. may alias another
   /// identifier, declared or undeclared
@@ -6435,7 +6493,7 @@ public:
   StmtResult ActOnFinishFullStmt(Stmt *Stmt);
 
   // Marks SS invalid if it represents an incomplete type.
-  bool RequireCompleteDeclContext(CXXScopeSpec &SS, DeclContext *DC);
+  bool RequireCompleteDeclContext(CXXScopeSpec &SS, DeclContext *&DC);
   // Complete an enum decl, maybe without a scope spec.
   bool RequireCompleteEnumDecl(EnumDecl *D, SourceLocation L,
                                CXXScopeSpec *SS = nullptr);
@@ -7591,7 +7649,8 @@ public:
   bool CheckTemplateParameterList(TemplateParameterList *NewParams,
                                   TemplateParameterList *OldParams,
                                   TemplateParamListContext TPC,
-                                  SkipBodyInfo *SkipBody = nullptr);
+                                  SkipBodyInfo *SkipBody = nullptr,
+                                  bool Complain = true);
   TemplateParameterList *MatchTemplateParametersToScopeSpecifier(
       SourceLocation DeclStartLoc, SourceLocation DeclLoc,
       const CXXScopeSpec &SS, TemplateIdAnnotation *TemplateId,
@@ -9292,6 +9351,24 @@ public:
     }
   };
 
+  class SavePendingInstantiationsRAII {
+  public:
+    SavePendingInstantiationsRAII(Sema &S):
+      SavedPendingLocalImplicitInstantiations(S), S(S) {
+      SavedPendingInstantiations.swap(S.PendingInstantiations);
+    }
+
+    ~SavePendingInstantiationsRAII() {
+      assert(S.PendingInstantiations.empty() &&
+             "there shouldn't be any pending instantiations");
+      SavedPendingInstantiations.swap(S.PendingInstantiations);
+    }
+  private:
+    LocalEagerInstantiationScope SavedPendingLocalImplicitInstantiations;
+    Sema &S;
+    std::deque<PendingImplicitInstantiation> SavedPendingInstantiations;
+  };
+
   void PerformPendingInstantiations(bool LocalOnly = false);
 
   TypeSourceInfo *SubstType(TypeSourceInfo *T,
@@ -12798,6 +12875,7 @@ protected:
   friend class ASTReader;
   friend class ASTDeclReader;
   friend class ASTWriter;
+  friend class ::cling::DeclUnloader;
 
 public:
   /// Retrieve the keyword associated
diff --git a/include/clang/Serialization/ASTReader.h b/include/clang/Serialization/ASTReader.h
index 242b75ba..8ea16187 100644
--- a/include/clang/Serialization/ASTReader.h
+++ b/include/clang/Serialization/ASTReader.h
@@ -649,6 +649,9 @@ private:
   /// files.
   llvm::DenseSet<LoadedMacroInfo> LoadedUndefs;
 
+  /// \Token literal data loaded and owned by us.
+  std::vector<std::string *> TokenLiteralDataLoaded;
+
   using GlobalMacroMapType =
       ContinuousRangeMap<serialization::MacroID, ModuleFile *, 4>;
 
@@ -1291,6 +1294,12 @@ private:
         : Mod(Mod), ImportedBy(ImportedBy), ImportLoc(ImportLoc) {}
   };
 
+  uint32_t getGenerationOrNull() const {
+    if (ContextObj)
+      return getGeneration(*ContextObj);
+    return 0u;
+  }
+
   ASTReadResult ReadASTCore(StringRef FileName, ModuleKind Type,
                             SourceLocation ImportLoc, ModuleFile *ImportedBy,
                             SmallVectorImpl<ImportedModule> &Loaded,
diff --git a/include/clang/Serialization/GlobalModuleIndex.h b/include/clang/Serialization/GlobalModuleIndex.h
index 5f481262..d38ae6a9 100644
--- a/include/clang/Serialization/GlobalModuleIndex.h
+++ b/include/clang/Serialization/GlobalModuleIndex.h
@@ -16,11 +16,13 @@
 #define LLVM_CLANG_SERIALIZATION_GLOBALMODULEINDEX_H
 
 #include "llvm/ADT/DenseMap.h"
+#include <llvm/ADT/DenseSet.h>
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringMap.h"
 #include "llvm/ADT/StringRef.h"
 #include "llvm/Support/Error.h"
+#include "llvm/ADT/StringSet.h"
 #include <memory>
 #include <utility>
 
@@ -42,6 +44,12 @@ namespace serialization {
   class ModuleFile;
 }
 
+using llvm::SmallVector;
+using llvm::SmallVectorImpl;
+using llvm::StringRef;
+using llvm::StringSet;
+using serialization::ModuleFile;
+
 /// A global index for a set of module files, providing information about
 /// the identifiers within those module files.
 ///
@@ -54,8 +62,6 @@ namespace serialization {
 /// imported, and can be queried to determine which modules the current
 /// translation could or should load to fix a problem.
 class GlobalModuleIndex {
-  using ModuleFile = serialization::ModuleFile;
-
   /// Buffer containing the index file, which is lazily accessed so long
   /// as the global module index is live.
   std::unique_ptr<llvm::MemoryBuffer> Buffer;
@@ -121,6 +127,9 @@ class GlobalModuleIndex {
   GlobalModuleIndex &operator=(const GlobalModuleIndex &) = delete;
 
 public:
+  using UserDefinedInterestingIDs =
+    llvm::StringMap<llvm::SmallVector<const FileEntry*, 2>>;
+
   ~GlobalModuleIndex();
 
   /// Read a global index file for the given directory.
@@ -142,7 +151,9 @@ public:
   ///
   /// \param ModuleFiles Will be populated with the set of module files that
   /// have been indexed.
-  void getKnownModules(llvm::SmallVectorImpl<ModuleFile *> &ModuleFiles);
+  void getKnownModules(SmallVectorImpl<ModuleFile *> &ModuleFiles);
+
+  void getKnownModuleFileNames(StringSet<> &ModuleFiles);
 
   /// Retrieve the set of module files on which the given module file
   /// directly depends.
@@ -163,6 +174,9 @@ public:
   /// \returns true if the identifier is known to the index, false otherwise.
   bool lookupIdentifier(llvm::StringRef Name, HitSet &Hits);
 
+  typedef llvm::SmallDenseSet<llvm::StringRef, 4> FileNameHitSet;
+  bool lookupIdentifier(StringRef Name, FileNameHitSet &Hits);
+
   /// Note that the given module file has been loaded.
   ///
   /// \returns false if the global module index has information about this
@@ -182,9 +196,11 @@ public:
   /// creating modules.
   /// \param Path The path to the directory containing module files, into
   /// which the global index will be written.
+  /// \param Optionally pass already precomputed interesting identifiers.
   static llvm::Error writeIndex(FileManager &FileMgr,
                                 const PCHContainerReader &PCHContainerRdr,
-                                llvm::StringRef Path);
+                                StringRef Path,
+                              UserDefinedInterestingIDs *ExternalIDs = nullptr);
 };
 }
 
diff --git a/lib/AST/ASTContext.cpp b/lib/AST/ASTContext.cpp
index 0e163f31..00ec96ab 100644
--- a/lib/AST/ASTContext.cpp
+++ b/lib/AST/ASTContext.cpp
@@ -4597,9 +4597,13 @@ QualType ASTContext::getAttributedType(attr::Kind attrKind,
 /// Retrieve a substitution-result type.
 QualType
 ASTContext::getSubstTemplateTypeParmType(const TemplateTypeParmType *Parm,
-                                         QualType Replacement) const {
-  assert(Replacement.isCanonical()
-         && "replacement types must always be canonical");
+                                         QualType Replacement,
+                                         bool AllowNonCanonical /* = false */
+                                        ) const {
+  if (!AllowNonCanonical) {
+     assert(Replacement.isCanonical()
+            && "replacement types must always be canonical");
+  }
 
   llvm::FoldingSetNodeID ID;
   SubstTemplateTypeParmType::Profile(ID, Parm, Replacement);
@@ -4609,7 +4613,8 @@ ASTContext::getSubstTemplateTypeParmType(const TemplateTypeParmType *Parm,
 
   if (!SubstParm) {
     SubstParm = new (*this, TypeAlignment)
-      SubstTemplateTypeParmType(Parm, Replacement);
+      SubstTemplateTypeParmType(Parm, Replacement,
+                                Replacement.getCanonicalType());
     Types.push_back(SubstParm);
     SubstTemplateTypeParmTypes.InsertNode(SubstParm, InsertPos);
   }
diff --git a/lib/AST/ASTImporter.cpp b/lib/AST/ASTImporter.cpp
index 787e0202..4a303b8d 100644
--- a/lib/AST/ASTImporter.cpp
+++ b/lib/AST/ASTImporter.cpp
@@ -9029,7 +9029,7 @@ Expected<FileID> ASTImporter::Import(FileID FromID, bool IsBuiltin) {
       // FIXME: We want to re-use the existing MemoryBuffer!
       llvm::Optional<llvm::MemoryBufferRef> FromBuf =
           Cache->getBufferOrNone(FromContext.getDiagnostics(),
-                                 FromSM.getFileManager(), SourceLocation{});
+                                 FromFileManager, SourceLocation{});
       if (!FromBuf)
         return llvm::make_error<ImportError>(ImportError::Unknown);
 
diff --git a/lib/AST/DeclTemplate.cpp b/lib/AST/DeclTemplate.cpp
index ec8b00a9..4b1ea6da 100644
--- a/lib/AST/DeclTemplate.cpp
+++ b/lib/AST/DeclTemplate.cpp
@@ -20,6 +20,8 @@
 #include "clang/AST/TemplateBase.h"
 #include "clang/AST/TemplateName.h"
 #include "clang/AST/Type.h"
+#include "clang/AST/ODRHash.h"
+#include "clang/AST/ExprCXX.h"
 #include "clang/AST/TypeLoc.h"
 #include "clang/Basic/Builtins.h"
 #include "clang/Basic/LLVM.h"
@@ -280,19 +282,48 @@ RedeclarableTemplateDecl::CommonBase *RedeclarableTemplateDecl::getCommonPtr() c
   return Common;
 }
 
-void RedeclarableTemplateDecl::loadLazySpecializationsImpl() const {
+void RedeclarableTemplateDecl::loadLazySpecializationsImpl(
+                                             bool OnlyPartial/*=false*/) const {
   // Grab the most recent declaration to ensure we've loaded any lazy
   // redeclarations of this template.
   CommonBase *CommonBasePtr = getMostRecentDecl()->getCommonPtr();
-  if (CommonBasePtr->LazySpecializations) {
-    ASTContext &Context = getASTContext();
-    uint32_t *Specs = CommonBasePtr->LazySpecializations;
-    CommonBasePtr->LazySpecializations = nullptr;
-    for (uint32_t I = 0, N = *Specs++; I != N; ++I)
-      (void)Context.getExternalSource()->GetExternalDecl(Specs[I]);
+  if (auto *Specs = CommonBasePtr->LazySpecializations) {
+    if (!OnlyPartial)
+      CommonBasePtr->LazySpecializations = nullptr;
+    for (uint32_t I = 0, N = Specs[0].DeclID; I != N; ++I) {
+      // Skip over already loaded specializations.
+      if (!Specs[I+1].ODRHash)
+        continue;
+      if (!OnlyPartial || Specs[I+1].IsPartial)
+        (void)loadLazySpecializationImpl(Specs[I+1]);
+    }
   }
 }
 
+Decl *RedeclarableTemplateDecl::loadLazySpecializationImpl(
+                                   LazySpecializationInfo &LazySpecInfo) const {
+  uint32_t ID = LazySpecInfo.DeclID;
+  assert(ID && "Loading already loaded specialization!");
+  // Note that we loaded the specialization.
+  LazySpecInfo.DeclID = LazySpecInfo.ODRHash = LazySpecInfo.IsPartial = 0;
+  return getASTContext().getExternalSource()->GetExternalDecl(ID);
+}
+
+bool
+RedeclarableTemplateDecl::loadLazySpecializationsImpl(ArrayRef<TemplateArgument>
+                                                      Args,
+                                                      TemplateParameterList *TPL) const {
+  bool LoadedSpecialization = false;
+  CommonBase *CommonBasePtr = getMostRecentDecl()->getCommonPtr();
+  if (auto *Specs = CommonBasePtr->LazySpecializations) {
+    unsigned Hash = TemplateArgumentList::ComputeODRHash(Args);
+    for (uint32_t I = 0, N = Specs[0].DeclID; I != N; ++I)
+      if (Specs[I+1].ODRHash && Specs[I+1].ODRHash == Hash)
+        LoadedSpecialization |= (bool)loadLazySpecializationImpl(Specs[I+1]);
+  }
+  return LoadedSpecialization;
+}
+
 template<class EntryType, typename... ProfileArguments>
 typename RedeclarableTemplateDecl::SpecEntryTraits<EntryType>::DeclType *
 RedeclarableTemplateDecl::findSpecializationImpl(
@@ -300,6 +331,8 @@ RedeclarableTemplateDecl::findSpecializationImpl(
     ProfileArguments&&... ProfileArgs) {
   using SETraits = SpecEntryTraits<EntryType>;
 
+  (void)loadLazySpecializationsImpl(std::forward<ProfileArguments>(ProfileArgs)...);
+
   llvm::FoldingSetNodeID ID;
   EntryType::Profile(ID, std::forward<ProfileArguments>(ProfileArgs)...,
                      getASTContext());
@@ -315,10 +348,11 @@ void RedeclarableTemplateDecl::addSpecializationImpl(
 
   if (InsertPos) {
 #ifndef NDEBUG
+    auto Args = SETraits::getTemplateArgs(Entry);
+    assert(!loadLazySpecializationsImpl(Args) &&
+           "Specialization is already registered as lazy");
     void *CorrectInsertPos;
-    assert(!findSpecializationImpl(Specializations,
-                                   CorrectInsertPos,
-                                   SETraits::getTemplateArgs(Entry)) &&
+    assert(!findSpecializationImpl(Specializations, CorrectInsertPos, Args) &&
            InsertPos == CorrectInsertPos &&
            "given incorrect InsertPos for specialization");
 #endif
@@ -375,12 +409,14 @@ FunctionTemplateDecl::getSpecializations() const {
 FunctionDecl *
 FunctionTemplateDecl::findSpecialization(ArrayRef<TemplateArgument> Args,
                                          void *&InsertPos) {
-  return findSpecializationImpl(getSpecializations(), InsertPos, Args);
+  auto *Common = getCommonPtr();
+  return findSpecializationImpl(Common->Specializations, InsertPos, Args);
 }
 
 void FunctionTemplateDecl::addSpecialization(
       FunctionTemplateSpecializationInfo *Info, void *InsertPos) {
-  addSpecializationImpl<FunctionTemplateDecl>(getSpecializations(), Info,
+  auto *Common = getCommonPtr();
+  addSpecializationImpl<FunctionTemplateDecl>(Common->Specializations, Info,
                                               InsertPos);
 }
 
@@ -455,8 +491,9 @@ ClassTemplateDecl *ClassTemplateDecl::CreateDeserialized(ASTContext &C,
                                        DeclarationName(), nullptr, nullptr);
 }
 
-void ClassTemplateDecl::LoadLazySpecializations() const {
-  loadLazySpecializationsImpl();
+void ClassTemplateDecl::LoadLazySpecializations(
+                                             bool OnlyPartial/*=false*/) const {
+  loadLazySpecializationsImpl(OnlyPartial);
 }
 
 llvm::FoldingSetVector<ClassTemplateSpecializationDecl> &
@@ -467,7 +504,7 @@ ClassTemplateDecl::getSpecializations() const {
 
 llvm::FoldingSetVector<ClassTemplatePartialSpecializationDecl> &
 ClassTemplateDecl::getPartialSpecializations() const {
-  LoadLazySpecializations();
+  LoadLazySpecializations(/*PartialOnly = */ true);
   return getCommonPtr()->PartialSpecializations;
 }
 
@@ -486,7 +523,9 @@ ClassTemplateDecl::findSpecialization(ArrayRef<TemplateArgument> Args,
 
 void ClassTemplateDecl::AddSpecialization(ClassTemplateSpecializationDecl *D,
                                           void *InsertPos) {
-  addSpecializationImpl<ClassTemplateDecl>(getSpecializations(), D, InsertPos);
+  auto *Common = getCommonPtr();
+  addSpecializationImpl<ClassTemplateDecl>(Common->Specializations, D,
+                                           InsertPos);
 }
 
 ClassTemplatePartialSpecializationDecl *
@@ -866,6 +905,14 @@ TemplateArgumentList::CreateCopy(ASTContext &Context,
   return new (Mem) TemplateArgumentList(Args);
 }
 
+unsigned TemplateArgumentList::ComputeODRHash(ArrayRef<TemplateArgument> Args) {
+  ODRHash Hasher;
+  for (TemplateArgument TA : Args)
+    Hasher.AddTemplateArgument(TA);
+
+  return Hasher.CalculateHash();
+}
+
 FunctionTemplateSpecializationInfo *FunctionTemplateSpecializationInfo::Create(
     ASTContext &C, FunctionDecl *FD, FunctionTemplateDecl *Template,
     TemplateSpecializationKind TSK, const TemplateArgumentList *TemplateArgs,
@@ -1161,8 +1208,9 @@ VarTemplateDecl *VarTemplateDecl::CreateDeserialized(ASTContext &C,
                                      DeclarationName(), nullptr, nullptr);
 }
 
-void VarTemplateDecl::LoadLazySpecializations() const {
-  loadLazySpecializationsImpl();
+void VarTemplateDecl::LoadLazySpecializations(
+                                             bool OnlyPartial/*=false*/) const {
+  loadLazySpecializationsImpl(OnlyPartial);
 }
 
 llvm::FoldingSetVector<VarTemplateSpecializationDecl> &
@@ -1173,7 +1221,7 @@ VarTemplateDecl::getSpecializations() const {
 
 llvm::FoldingSetVector<VarTemplatePartialSpecializationDecl> &
 VarTemplateDecl::getPartialSpecializations() const {
-  LoadLazySpecializations();
+  LoadLazySpecializations(/*PartialOnly = */ true);
   return getCommonPtr()->PartialSpecializations;
 }
 
@@ -1192,7 +1240,8 @@ VarTemplateDecl::findSpecialization(ArrayRef<TemplateArgument> Args,
 
 void VarTemplateDecl::AddSpecialization(VarTemplateSpecializationDecl *D,
                                         void *InsertPos) {
-  addSpecializationImpl<VarTemplateDecl>(getSpecializations(), D, InsertPos);
+  auto *Common = getCommonPtr();
+  addSpecializationImpl<VarTemplateDecl>(Common->Specializations, D, InsertPos);
 }
 
 VarTemplatePartialSpecializationDecl *
diff --git a/lib/AST/ExternalASTSource.cpp b/lib/AST/ExternalASTSource.cpp
index 25783318..754bbb9b 100644
--- a/lib/AST/ExternalASTSource.cpp
+++ b/lib/AST/ExternalASTSource.cpp
@@ -30,6 +30,10 @@ char ExternalASTSource::ID;
 
 ExternalASTSource::~ExternalASTSource() = default;
 
+uint32_t ExternalASTSource::getGeneration(const ASTContext &C) const {
+  return C.getGeneration();
+}
+
 llvm::Optional<ASTSourceDescriptor>
 ExternalASTSource::getSourceDescriptor(unsigned ID) {
   return None;
@@ -109,19 +113,5 @@ void ExternalASTSource::FindExternalLexicalDecls(
 void ExternalASTSource::getMemoryBufferSizes(MemoryBufferSizes &sizes) const {}
 
 uint32_t ExternalASTSource::incrementGeneration(ASTContext &C) {
-  uint32_t OldGeneration = CurrentGeneration;
-
-  // Make sure the generation of the topmost external source for the context is
-  // incremented. That might not be us.
-  auto *P = C.getExternalSource();
-  if (P && P != this)
-    CurrentGeneration = P->incrementGeneration(C);
-  else {
-    // FIXME: Only bump the generation counter if the current generation number
-    // has been observed?
-    if (!++CurrentGeneration)
-      llvm::report_fatal_error("generation counter overflowed", false);
-  }
-
-  return OldGeneration;
+  return C.incrementGeneration();
 }
diff --git a/lib/AST/ODRHash.cpp b/lib/AST/ODRHash.cpp
index 735bcff8..174ba52a 100644
--- a/lib/AST/ODRHash.cpp
+++ b/lib/AST/ODRHash.cpp
@@ -157,32 +157,34 @@ void ODRHash::AddTemplateName(TemplateName Name) {
 void ODRHash::AddTemplateArgument(TemplateArgument TA) {
   const auto Kind = TA.getKind();
   ID.AddInteger(Kind);
-
   switch (Kind) {
-    case TemplateArgument::Null:
-      llvm_unreachable("Expected valid TemplateArgument");
-    case TemplateArgument::Type:
-      AddQualType(TA.getAsType());
-      break;
-    case TemplateArgument::Declaration:
-      AddDecl(TA.getAsDecl());
-      break;
-    case TemplateArgument::NullPtr:
-    case TemplateArgument::Integral:
-      break;
-    case TemplateArgument::Template:
-    case TemplateArgument::TemplateExpansion:
-      AddTemplateName(TA.getAsTemplateOrTemplatePattern());
-      break;
-    case TemplateArgument::Expression:
-      AddStmt(TA.getAsExpr());
-      break;
-    case TemplateArgument::Pack:
-      ID.AddInteger(TA.pack_size());
-      for (auto SubTA : TA.pack_elements()) {
-        AddTemplateArgument(SubTA);
-      }
-      break;
+  case TemplateArgument::Null:
+    llvm_unreachable("Require valid TemplateArgument");
+  case TemplateArgument::Type:
+    AddQualType(TA.getAsType());
+    break;
+  case TemplateArgument::Declaration:
+    AddDecl(TA.getAsDecl());
+    break;
+  case TemplateArgument::NullPtr:
+    AddQualType(TA.getNullPtrType());
+    break;
+  case TemplateArgument::Integral:
+    TA.getAsIntegral().Profile(ID);
+    AddQualType(TA.getIntegralType());
+    break;
+  case TemplateArgument::Template:
+  case TemplateArgument::TemplateExpansion:
+    AddTemplateName(TA.getAsTemplateOrTemplatePattern());
+    break;
+  case TemplateArgument::Expression:
+    AddStmt(TA.getAsExpr());
+    break;
+  case TemplateArgument::Pack:
+    ID.AddInteger(TA.pack_size());
+    for (auto SubTA : TA.pack_elements())
+      AddTemplateArgument(SubTA);
+    break;
   }
 }
 
@@ -649,6 +651,21 @@ void ODRHash::AddDecl(const Decl *D) {
     for (const TemplateArgument &TA : List.asArray())
       AddTemplateArgument(TA);
   }
+
+  // If this was a specialization we should take into account its template
+  // arguments. This helps to reduce collisions coming when visiting template
+  // specialization types (eg. when processing type template arguments).
+  ArrayRef<TemplateArgument> Args;
+  if (auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(D))
+    Args = CTSD->getTemplateArgs().asArray();
+  else if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(D))
+    Args = VTSD->getTemplateArgs().asArray();
+  else if (auto *FD = dyn_cast<FunctionDecl>(D))
+    if (FD->getTemplateSpecializationArgs())
+      Args = FD->getTemplateSpecializationArgs()->asArray();
+
+  for (auto &TA : Args)
+    AddTemplateArgument(TA);
 }
 
 namespace {
diff --git a/lib/AST/TemplateBase.cpp b/lib/AST/TemplateBase.cpp
index f44230d1..72dadd2f 100644
--- a/lib/AST/TemplateBase.cpp
+++ b/lib/AST/TemplateBase.cpp
@@ -130,8 +130,14 @@ static void printIntegral(const TemplateArgument &TemplArg, raw_ostream &Out,
     } else
       Out << "(" << T->getCanonicalTypeInternal().getAsString(Policy) << ")"
           << Val;
-  } else
+  } else {
     Out << Val;
+    // Handle cases where the value is too large to fit into the underlying type
+    // i.e. where the unsignedness matters.
+    if (T->isBuiltinType())
+      if (Val.isUnsigned() && Val.getBitWidth() == 64 && Val.countLeadingOnes())
+        Out << "ull";
+  }
 }
 
 static unsigned getArrayDepth(QualType type) {
diff --git a/lib/AST/TypePrinter.cpp b/lib/AST/TypePrinter.cpp
index 5de22f76..8cd25dc6 100644
--- a/lib/AST/TypePrinter.cpp
+++ b/lib/AST/TypePrinter.cpp
@@ -80,6 +80,21 @@ namespace {
     }
   };
 
+  class DefaultTemplateArgsPolicyRAII {
+    PrintingPolicy &Policy;
+    bool Old;
+
+  public:
+    explicit DefaultTemplateArgsPolicyRAII(PrintingPolicy &Policy)
+        : Policy(Policy), Old(Policy.SuppressDefaultTemplateArgs) {
+      Policy.SuppressDefaultTemplateArgs = false;
+    }
+
+    ~DefaultTemplateArgsPolicyRAII() {
+      Policy.SuppressDefaultTemplateArgs = Old;
+    }
+  };
+
   class ElaboratedTypePolicyRAII {
     PrintingPolicy &Policy;
     bool SuppressTagKeyword;
@@ -1442,6 +1457,7 @@ void TypePrinter::printTemplateId(const TemplateSpecializationType *T,
   IncludeStrongLifetimeRAII Strong(Policy);
 
   TemplateDecl *TD = T->getTemplateName().getAsTemplateDecl();
+  // FIXME: Null TD never excercised in test suite.
   if (FullyQualify && TD) {
     if (!Policy.SuppressScope)
       AppendScope(TD->getDeclContext(), OS, TD->getDeclName());
@@ -1452,7 +1468,9 @@ void TypePrinter::printTemplateId(const TemplateSpecializationType *T,
     T->getTemplateName().print(OS, Policy);
   }
 
-  printTemplateArgumentList(OS, T->template_arguments(), Policy);
+  DefaultTemplateArgsPolicyRAII TemplateArgs(Policy);
+  const TemplateParameterList *TPL = TD ? TD->getTemplateParameters() : nullptr;
+  printTemplateArgumentList(OS, T->template_arguments(), Policy, TPL);
   spaceBeforePlaceHolder(OS);
 }
 
diff --git a/lib/Analysis/CFG.cpp b/lib/Analysis/CFG.cpp
index 87c2f6f9..ba5eceda 100644
--- a/lib/Analysis/CFG.cpp
+++ b/lib/Analysis/CFG.cpp
@@ -542,7 +542,6 @@ private:
   // Visitors to walk an AST and construct the CFG.
   CFGBlock *VisitInitListExpr(InitListExpr *ILE, AddStmtChoice asc);
   CFGBlock *VisitAddrLabelExpr(AddrLabelExpr *A, AddStmtChoice asc);
-  CFGBlock *VisitAttributedStmt(AttributedStmt *A, AddStmtChoice asc);
   CFGBlock *VisitBinaryOperator(BinaryOperator *B, AddStmtChoice asc);
   CFGBlock *VisitBreakStmt(BreakStmt *B);
   CFGBlock *VisitCallExpr(CallExpr *C, AddStmtChoice asc);
@@ -2150,9 +2149,6 @@ CFGBlock *CFGBuilder::Visit(Stmt * S, AddStmtChoice asc,
     case Stmt::InitListExprClass:
       return VisitInitListExpr(cast<InitListExpr>(S), asc);
 
-    case Stmt::AttributedStmtClass:
-      return VisitAttributedStmt(cast<AttributedStmt>(S), asc);
-
     case Stmt::AddrLabelExprClass:
       return VisitAddrLabelExpr(cast<AddrLabelExpr>(S), asc);
 
@@ -2402,32 +2398,8 @@ CFGBlock *CFGBuilder::VisitAddrLabelExpr(AddrLabelExpr *A,
   return Block;
 }
 
-static bool isFallthroughStatement(const AttributedStmt *A) {
-  bool isFallthrough = hasSpecificAttr<FallThroughAttr>(A->getAttrs());
-  assert((!isFallthrough || isa<NullStmt>(A->getSubStmt())) &&
-         "expected fallthrough not to have children");
-  return isFallthrough;
-}
-
-CFGBlock *CFGBuilder::VisitAttributedStmt(AttributedStmt *A,
-                                          AddStmtChoice asc) {
-  // AttributedStmts for [[likely]] can have arbitrary statements as children,
-  // and the current visitation order here would add the AttributedStmts
-  // for [[likely]] after the child nodes, which is undesirable: For example,
-  // if the child contains an unconditional return, the [[likely]] would be
-  // considered unreachable.
-  // So only add the AttributedStmt for FallThrough, which has CFG effects and
-  // also no children, and omit the others. None of the other current StmtAttrs
-  // have semantic meaning for the CFG.
-  if (isFallthroughStatement(A) && asc.alwaysAdd(*this, A)) {
-    autoCreateBlock();
-    appendStmt(Block, A);
-  }
-
-  return VisitChildren(A);
-}
-
-CFGBlock *CFGBuilder::VisitUnaryOperator(UnaryOperator *U, AddStmtChoice asc) {
+CFGBlock *CFGBuilder::VisitUnaryOperator(UnaryOperator *U,
+           AddStmtChoice asc) {
   if (asc.alwaysAdd(*this, U)) {
     autoCreateBlock();
     appendStmt(Block, U);
@@ -3361,7 +3333,7 @@ CFGBlock *CFGBuilder::VisitGCCAsmStmt(GCCAsmStmt *G, AddStmtChoice asc) {
   // Save "Succ" in BackpatchBlocks. In the backpatch processing, "Succ" is
   // used to avoid adding "Succ" again.
   BackpatchBlocks.push_back(JumpSource(Succ, ScopePos));
-  return VisitChildren(G);
+  return Block;
 }
 
 CFGBlock *CFGBuilder::VisitForStmt(ForStmt *F) {
diff --git a/lib/Analysis/UninitializedValues.cpp b/lib/Analysis/UninitializedValues.cpp
index 811146e5..67cd3972 100644
--- a/lib/Analysis/UninitializedValues.cpp
+++ b/lib/Analysis/UninitializedValues.cpp
@@ -591,8 +591,8 @@ public:
 
         if (AtPredExit == MayUninitialized) {
           // If the predecessor's terminator is an "asm goto" that initializes
-          // the variable, then don't count it as "initialized" on the indirect
-          // paths.
+          // the variable, then it won't be counted as "initialized" on the
+          // non-fallthrough paths.
           CFGTerminator term = Pred->getTerminator();
           if (const auto *as = dyn_cast_or_null<GCCAsmStmt>(term.getStmt())) {
             const CFGBlock *fallthrough = *Pred->succ_begin();
@@ -810,21 +810,13 @@ void TransferFunctions::VisitGCCAsmStmt(GCCAsmStmt *as) {
   if (!as->isAsmGoto())
     return;
 
-  ASTContext &C = ac.getASTContext();
-  for (const Expr *O : as->outputs()) {
-    const Expr *Ex = stripCasts(C, O);
-
-    // Strip away any unary operators. Invalid l-values are reported by other
-    // semantic analysis passes.
-    while (const auto *UO = dyn_cast<UnaryOperator>(Ex))
-      Ex = stripCasts(C, UO->getSubExpr());
-
-    // Mark the variable as potentially uninitialized for those cases where
-    // it's used on an indirect path, where it's not guaranteed to be
-    // defined.
-    if (const VarDecl *VD = findVar(Ex).getDecl())
-      vals[VD] = MayUninitialized;
-  }
+  for (const Expr *o : as->outputs())
+    if (const VarDecl *VD = findVar(o).getDecl())
+      if (vals[VD] != Initialized)
+        // If the variable isn't initialized by the time we get here, then we
+        // mark it as potentially uninitialized for those cases where it's used
+        // on an indirect path, where it's not guaranteed to be defined.
+        vals[VD] = MayUninitialized;
 }
 
 void TransferFunctions::VisitObjCMessageExpr(ObjCMessageExpr *ME) {
diff --git a/lib/Basic/Diagnostic.cpp b/lib/Basic/Diagnostic.cpp
index d3b2122e..2152e5bb 100644
--- a/lib/Basic/Diagnostic.cpp
+++ b/lib/Basic/Diagnostic.cpp
@@ -130,7 +130,7 @@ bool DiagnosticsEngine::popMappings(SourceLocation Loc) {
   return true;
 }
 
-void DiagnosticsEngine::Reset() {
+void DiagnosticsEngine::Reset(bool soft /*=false*/) {
   ErrorOccurred = false;
   UncompilableErrorOccurred = false;
   FatalErrorOccurred = false;
@@ -145,6 +145,7 @@ void DiagnosticsEngine::Reset() {
   LastDiagLevel = DiagnosticIDs::Ignored;
   DelayedDiagID = 0;
 
+  if (!soft) {
   // Clear state related to #pragma diagnostic.
   DiagStates.clear();
   DiagStatesByLoc.clear();
@@ -154,6 +155,7 @@ void DiagnosticsEngine::Reset() {
   // through command-line.
   DiagStates.emplace_back();
   DiagStatesByLoc.appendFirst(&DiagStates.back());
+  }
 }
 
 void DiagnosticsEngine::SetDelayedDiagnostic(unsigned DiagID, StringRef Arg1,
@@ -191,7 +193,29 @@ void DiagnosticsEngine::DiagStateMap::append(SourceManager &SrcMgr,
        Offset = F->ParentOffset, F = F->Parent) {
     F->HasLocalTransitions = true;
     auto &Last = F->StateTransitions.back();
-    assert(Last.Offset <= Offset && "state transitions added out of order");
+    if (Last.Offset > Offset) {
+      // Deal with a state change induce by recursive parsing.  The first parsing is
+      // suspended and a (recursive) parsing is started between associated (in the upper/outer
+      // file) with a newer line (hence greater offset).  After the end of the recursive
+      // parsing, we go back to the first parsing and any state change will done 'earlier'
+      // and trigger:
+      //   assert(Last.Offset <= Offset && "state transitions added out of order");
+      auto OnePastIt = std::upper_bound(
+        F->StateTransitions.begin(), F->StateTransitions.end(), Offset,
+        [](unsigned Offset, const DiagStatePoint &P) {
+          return Offset < P.Offset;
+        });
+      if (OnePastIt == F->StateTransitions.begin() || (OnePastIt[-1].Offset != Offset)) {
+        F->StateTransitions.insert( OnePastIt, {State, Offset});
+      } else {
+        auto &Prev = OnePastIt[-1];
+        if (Prev.State == State)
+          break;
+        Prev.State = State;
+        continue;
+      }
+      continue;
+    }
 
     if (Last.Offset == Offset) {
       if (Last.State == State)
diff --git a/lib/Basic/FileManager.cpp b/lib/Basic/FileManager.cpp
index 74cd2f29..ef36e51d 100644
--- a/lib/Basic/FileManager.cpp
+++ b/lib/Basic/FileManager.cpp
@@ -207,7 +207,25 @@ FileManager::getFileRef(StringRef Filename, bool openFile, bool CacheFailure) {
   // See if there is already an entry in the map.
   auto SeenFileInsertResult =
       SeenFileEntries.insert({Filename, std::errc::no_such_file_or_directory});
-  if (!SeenFileInsertResult.second) {
+
+  auto *NamedFileEnt = &*SeenFileInsertResult.first;
+
+  const FileEntry *StaleFileEntry = 0;
+  bool needsRereading = false;
+  if (NamedFileEnt && NamedFileEnt->getValue()) {
+    FileEntryRef::MapValue Value = *NamedFileEnt->getValue();
+    if (Value.V.is<FileEntry *>()) {
+      auto found = FileEntriesToReread.find(Value.V.get<FileEntry*>());
+      if (found != FileEntriesToReread.end()) {
+        needsRereading = true;
+        StaleFileEntry = *found;
+        FileEntriesToReread.erase(found);
+      }
+    }
+  }
+
+  // See if there is already an entry in the map.
+  if (!SeenFileInsertResult.second && !needsRereading) {
     if (!SeenFileInsertResult.first->second)
       return llvm::errorCodeToError(
           SeenFileInsertResult.first->second.getError());
@@ -222,8 +240,6 @@ FileManager::getFileRef(StringRef Filename, bool openFile, bool CacheFailure) {
 
   // We've not seen this before. Fill it in.
   ++NumFileCacheMisses;
-  auto *NamedFileEnt = &*SeenFileInsertResult.first;
-  assert(!NamedFileEnt->second && "should be newly-created");
 
   // Get the null-terminated file name as stored as the key of the
   // SeenFileEntries map.
@@ -304,6 +320,9 @@ FileManager::getFileRef(StringRef Filename, bool openFile, bool CacheFailure) {
     // multiple names.
     if (&DirInfo.getDirEntry() != UFE.Dir && Status.IsVFSMapped)
       UFE.Dir = &DirInfo.getDirEntry();
+  }
+  if (UFE.isValid() &&
+      llvm::sys::toTimeT(Status.getLastModificationTime()) == UFE.ModTime) {
 
     // Always update LastRef to the last name by which a file was accessed.
     // FIXME: Neither this nor always using the first reference is correct; we
@@ -335,6 +354,20 @@ FileManager::getFileRef(StringRef Filename, bool openFile, bool CacheFailure) {
     // We should still fill the path even if we aren't opening the file.
     fillRealPathName(&UFE, InterndFileName);
   }
+
+  if (StaleFileEntry) {
+    // Find occurrences of old FileEntry; update with new one:
+    for (auto& fe: SeenFileEntries) {
+      if (fe.getValue()) {
+        FileEntryRef::MapValue Value = *fe.getValue();
+        if (Value.V.is<FileEntry *>()
+            && Value.V.get<FileEntry*>() == StaleFileEntry) {
+          fe.setValue(FileEntryRef::MapValue(UFE, DirInfo));
+        }
+      }
+    }
+  }
+
   return ReturnedRef;
 }
 
@@ -580,6 +613,12 @@ FileManager::getNoncachedStatValue(StringRef Path,
   return std::error_code();
 }
 
+void FileManager::invalidateCache(FileEntry *Entry) {
+  assert(Entry && "Cannot invalidate a NULL FileEntry");
+  FileEntriesToReread.insert(Entry->getLastRef());
+  Entry->IsValid = false;
+}
+
 void FileManager::GetUniqueIDMapping(
                    SmallVectorImpl<const FileEntry *> &UIDToFiles) const {
   UIDToFiles.clear();
diff --git a/lib/Basic/SourceManager.cpp b/lib/Basic/SourceManager.cpp
index 8cba379a..42abc296 100644
--- a/lib/Basic/SourceManager.cpp
+++ b/lib/Basic/SourceManager.cpp
@@ -358,6 +358,25 @@ bool SourceManager::isMainFile(const FileEntry &SourceFile) {
   return false;
 }
 
+void SourceManager::invalidateCache(FileID FID) {
+  const FileEntry* Entry = getFileEntryForID(FID);
+  if (!Entry)
+    return;
+  if (ContentCache *&E = FileInfos[Entry]) {
+    E->setBuffer(nullptr);
+    E = 0;
+  }
+  if (!FID.isInvalid()) {
+    const SrcMgr::SLocEntry& SLocE = getSLocEntry(FID);
+    if (SLocE.isFile()) {
+      SrcMgr::ContentCache& CC =
+        const_cast<SrcMgr::ContentCache&>(SLocE.getFile().getContentCache());
+      CC.setBuffer(nullptr);
+    }
+  }
+  getFileManager().invalidateCache(const_cast<FileEntry*>(Entry));
+}
+
 void SourceManager::initializeForReplay(const SourceManager &Old) {
   assert(MainFileID.isInvalid() && "expected uninitialized SourceManager");
 
@@ -1505,6 +1524,15 @@ StringRef SourceManager::getBufferName(SourceLocation Loc,
   auto B = getBufferOrNone(getFileID(Loc));
   if (Invalid)
     *Invalid = !B;
+
+  // Try to get the name without reading the buffer.
+  FileID FID = getFileID(Loc);
+  const SrcMgr::SLocEntry &Entry = getSLocEntry(FID, Invalid);
+  if (!Invalid && Entry.isFile()) {
+    if (const FileEntry* FE = Entry.getFile().getContentCache().ContentsEntry)
+      return FE->getName();
+  }
+
   return B ? B->getBufferIdentifier() : "<invalid buffer>";
 }
 
@@ -2067,7 +2095,10 @@ bool SourceManager::isBeforeInTranslationUnit(SourceLocation LHS,
       return LIsScratch;
     return LOffs.second < ROffs.second;
   }
-  llvm_unreachable("Unsortable locations found");
+  //AXEL: Work around diags from include chains not rooted in main file.
+  //AXEL: llvm_unreachable("Unsortable locations found");
+  assert(0 && "Unsortable locations found");
+  return LOffs.first < ROffs.first;
 }
 
 std::pair<bool, bool> SourceManager::isInTheSameTranslationUnit(
diff --git a/lib/Basic/Targets/OSTargets.h b/lib/Basic/Targets/OSTargets.h
index 12df95c1..3fe39ed6 100644
--- a/lib/Basic/Targets/OSTargets.h
+++ b/lib/Basic/Targets/OSTargets.h
@@ -461,8 +461,10 @@ protected:
     if (this->HasFloat128)
       Builder.defineMacro("__FLOAT128__");
 
-    if (Opts.C11)
+    if (Opts.C11) {
+      Builder.defineMacro("__STDC_NO_ATOMICS__");
       Builder.defineMacro("__STDC_NO_THREADS__");
+    }
   }
 
 public:
diff --git a/lib/Basic/Targets/PPC.cpp b/lib/Basic/Targets/PPC.cpp
index ecfbe284..59656888 100644
--- a/lib/Basic/Targets/PPC.cpp
+++ b/lib/Basic/Targets/PPC.cpp
@@ -243,10 +243,7 @@ static void defineXLCompatMacros(MacroBuilder &Builder) {
 void PPCTargetInfo::getTargetDefines(const LangOptions &Opts,
                                      MacroBuilder &Builder) const {
 
-  // We define the XLC compatibility macros only on AIX and Linux since XLC
-  // was never available on any other platforms.
-  if (getTriple().isOSAIX() || getTriple().isOSLinux())
-    defineXLCompatMacros(Builder);
+  defineXLCompatMacros(Builder);
 
   // Target identification.
   Builder.defineMacro("__ppc__");
diff --git a/lib/Basic/Targets/Sparc.h b/lib/Basic/Targets/Sparc.h
index e9f8c10d..07844aba 100644
--- a/lib/Basic/Targets/Sparc.h
+++ b/lib/Basic/Targets/Sparc.h
@@ -50,6 +50,8 @@ public:
 
   bool hasFeature(StringRef Feature) const override;
 
+  bool hasSjLjLowering() const override { return true; }
+
   ArrayRef<Builtin::Info> getTargetBuiltins() const override {
     // FIXME: Implement!
     return None;
@@ -178,6 +180,7 @@ public:
   void getTargetDefines(const LangOptions &Opts,
                         MacroBuilder &Builder) const override;
 
+  bool hasSjLjLowering() const override { return true; }
   bool hasExtIntType() const override { return true; }
 };
 
diff --git a/lib/CodeGen/CGCUDANV.cpp b/lib/CodeGen/CGCUDANV.cpp
index 88030fee..5905d57e 100644
--- a/lib/CodeGen/CGCUDANV.cpp
+++ b/lib/CodeGen/CGCUDANV.cpp
@@ -711,7 +711,7 @@ llvm::Function *CGNVCUDARuntime::makeModuleCtorFunction() {
   }
 
   llvm::Function *ModuleCtorFunc = llvm::Function::Create(
-      llvm::FunctionType::get(VoidTy, VoidPtrTy, false),
+      llvm::FunctionType::get(VoidTy, false),
       llvm::GlobalValue::InternalLinkage,
       addUnderscoredPrefixToName("_module_ctor"), &TheModule);
   llvm::BasicBlock *CtorEntryBB =
@@ -947,7 +947,7 @@ llvm::Function *CGNVCUDARuntime::makeModuleDtorFunction() {
       addUnderscoredPrefixToName("UnregisterFatBinary"));
 
   llvm::Function *ModuleDtorFunc = llvm::Function::Create(
-      llvm::FunctionType::get(VoidTy, VoidPtrTy, false),
+      llvm::FunctionType::get(VoidTy, false),
       llvm::GlobalValue::InternalLinkage,
       addUnderscoredPrefixToName("_module_dtor"), &TheModule);
 
diff --git a/lib/CodeGen/CGDeclCXX.cpp b/lib/CodeGen/CGDeclCXX.cpp
index 553fedeb..f6f4e380 100644
--- a/lib/CodeGen/CGDeclCXX.cpp
+++ b/lib/CodeGen/CGDeclCXX.cpp
@@ -531,9 +531,19 @@ CodeGenModule::EmitCXXGlobalVarDeclInitFunc(const VarDecl *D,
     getCXXABI().getMangleContext().mangleDynamicInitializer(D, Out);
   }
 
+  // Use the module name to make the initializer unique accross modules.
+  SmallString<128> moduleName(TheModule.getName());
+  for (size_t i = 0; i < moduleName.size(); ++i) {
+    // Replace everything that's not [a-zA-Z0-9._] with a _. This set happens
+    // to be the set of C preprocessing numbers.
+    if (!isPreprocessingNumberBody(moduleName[i]))
+      moduleName[i] = '_';
+  }
+
   // Create a variable initialization function.
   llvm::Function *Fn = CreateGlobalInitOrCleanUpFunction(
-      FTy, FnName.str(), getTypes().arrangeNullaryFunction(), D->getLocation());
+      FTy, llvm::Twine(FnName)+moduleName.str() + "_",
+      getTypes().arrangeNullaryFunction(), D->getLocation());
 
   auto *ISA = D->getAttr<InitSegAttr>();
   CodeGenFunction(*this).GenerateCXXGlobalVarDeclInitFunc(Fn, D, Addr,
diff --git a/lib/CodeGen/CGExprCXX.cpp b/lib/CodeGen/CGExprCXX.cpp
index f42759e9..dbbf9b79 100644
--- a/lib/CodeGen/CGExprCXX.cpp
+++ b/lib/CodeGen/CGExprCXX.cpp
@@ -97,8 +97,9 @@ RValue CodeGenFunction::EmitCXXDestructorCall(
   const CXXMethodDecl *DtorDecl = cast<CXXMethodDecl>(Dtor.getDecl());
 
   assert(!ThisTy.isNull());
-  assert(ThisTy->getAsCXXRecordDecl() == DtorDecl->getParent() &&
-         "Pointer/Object mixup");
+  assert(
+      declaresSameEntity(ThisTy->getAsCXXRecordDecl(), DtorDecl->getParent()) &&
+      "Pointer/Object mixup");
 
   LangAS SrcAS = ThisTy.getAddressSpace();
   LangAS DstAS = DtorDecl->getMethodQualifiers().getAddressSpace();
diff --git a/lib/CodeGen/CodeGenModule.cpp b/lib/CodeGen/CodeGenModule.cpp
index 49a1396b..35503322 100644
--- a/lib/CodeGen/CodeGenModule.cpp
+++ b/lib/CodeGen/CodeGenModule.cpp
@@ -410,6 +410,7 @@ void CodeGenModule::checkAliases() {
 
 void CodeGenModule::clear() {
   DeferredDeclsToEmit.clear();
+  EmittedDeferredDecls.clear();
   if (OpenMPRuntime)
     OpenMPRuntime->clear();
 }
@@ -475,6 +476,9 @@ static void setVisibilityFromDLLStorageClass(const clang::LangOptions &LO,
 
 void CodeGenModule::Release() {
   EmitDeferred();
+  DeferredDecls.insert(EmittedDeferredDecls.begin(),
+                       EmittedDeferredDecls.end());
+  EmittedDeferredDecls.clear();
   EmitVTablesOpportunistically();
   applyGlobalValReplacements();
   applyReplacements();
@@ -1456,6 +1460,7 @@ void CodeGenModule::EmitCtorList(CtorList &Fns, const char *GlobalName) {
   // Construct the constructor and destructor arrays.
   ConstantInitBuilder builder(*this);
   auto ctors = builder.beginArray(CtorStructTy);
+
   for (const auto &I : Fns) {
     auto ctor = ctors.beginStruct(CtorStructTy);
     ctor.addInt(Int32Ty, I.Priority);
@@ -2239,7 +2244,9 @@ static void emitUsed(CodeGenModule &CGM, StringRef Name,
 
 void CodeGenModule::emitLLVMUsed() {
   emitUsed(*this, "llvm.used", LLVMUsed);
+  LLVMUsed.clear();
   emitUsed(*this, "llvm.compiler.used", LLVMCompilerUsed);
+  LLVMCompilerUsed.clear();
 }
 
 void CodeGenModule::AppendLinkerOptions(StringRef Opts) {
@@ -2411,7 +2418,7 @@ void CodeGenModule::EmitDeferred() {
   // needed for further handling.
   if (getLangOpts().CUDA && getLangOpts().CUDAIsDevice)
     for (const auto *V : getContext().CUDADeviceVarODRUsedByHost)
-      DeferredDeclsToEmit.push_back(V);
+      addDeferredDeclToEmit(V, "");
 
   // Stop if we're out of both deferred vtables and deferred declarations.
   if (DeferredDeclsToEmit.empty())
@@ -2514,18 +2521,21 @@ llvm::Constant *CodeGenModule::EmitAnnotationString(StringRef Str) {
 
 llvm::Constant *CodeGenModule::EmitAnnotationUnit(SourceLocation Loc) {
   SourceManager &SM = getContext().getSourceManager();
-  PresumedLoc PLoc = SM.getPresumedLoc(Loc);
-  if (PLoc.isValid())
-    return EmitAnnotationString(PLoc.getFilename());
+  //PresumedLoc PLoc = SM.getPresumedLoc(Loc);
+  //if (PLoc.isValid())
+  //  return EmitAnnotationString(PLoc.getFilename());
   return EmitAnnotationString(SM.getBufferName(Loc));
 }
 
 llvm::Constant *CodeGenModule::EmitAnnotationLineNo(SourceLocation L) {
+  return llvm::ConstantInt::get(Int32Ty, 1);
+#if 0
   SourceManager &SM = getContext().getSourceManager();
   PresumedLoc PLoc = SM.getPresumedLoc(L);
   unsigned LineNo = PLoc.isValid() ? PLoc.getLine() :
     SM.getExpansionLineNumber(L);
   return llvm::ConstantInt::get(Int32Ty, LineNo);
+#endif
 }
 
 llvm::Constant *CodeGenModule::EmitAnnotationArgs(const AnnotateAttr *Attr) {
@@ -2980,6 +2990,7 @@ void CodeGenModule::EmitGlobal(GlobalDecl GD) {
   if (MustBeEmitted(Global) && MayBeEmittedEagerly(Global)) {
     // Emit the definition if it can't be deferred.
     EmitGlobalDefinition(GD);
+    addEmittedDeferredDecl(GD, StringRef());
     return;
   }
 
@@ -2994,11 +3005,11 @@ void CodeGenModule::EmitGlobal(GlobalDecl GD) {
   StringRef MangledName = getMangledName(GD);
   if (GetGlobalValue(MangledName) != nullptr) {
     // The value has already been used and should therefore be emitted.
-    addDeferredDeclToEmit(GD);
+    addDeferredDeclToEmit(GD, MangledName);
   } else if (MustBeEmitted(Global)) {
     // The value must be emitted, but cannot be emitted eagerly.
     assert(!MayBeEmittedEagerly(Global));
-    addDeferredDeclToEmit(GD);
+    addDeferredDeclToEmit(GD, MangledName);
   } else {
     // Otherwise, remember that we saw a deferred decl with this name.  The
     // first use of the mangled name will cause it to move into
@@ -3625,7 +3636,7 @@ llvm::Constant *CodeGenModule::GetOrCreateLLVMFunction(
     if (D && isa<CXXDestructorDecl>(D) &&
         getCXXABI().useThunkForDtorVariant(cast<CXXDestructorDecl>(D),
                                            GD.getDtorType()))
-      addDeferredDeclToEmit(GD);
+      addDeferredDeclToEmit(GD, MangledName);
 
     // This is the first use or definition of a mangled name.  If there is a
     // deferred decl with this name, remember that we need to emit it at the end
@@ -3635,7 +3646,7 @@ llvm::Constant *CodeGenModule::GetOrCreateLLVMFunction(
       // Move the potentially referenced deferred decl to the
       // DeferredDeclsToEmit list, and remove it from DeferredDecls (since we
       // don't need it anymore).
-      addDeferredDeclToEmit(DDI->second);
+      addDeferredDeclToEmit(DDI->second, MangledName);
       DeferredDecls.erase(DDI);
 
       // Otherwise, there are cases we have to worry about where we're
@@ -3655,7 +3666,7 @@ llvm::Constant *CodeGenModule::GetOrCreateLLVMFunction(
            FD = FD->getPreviousDecl()) {
         if (isa<CXXRecordDecl>(FD->getLexicalDeclContext())) {
           if (FD->doesThisDeclarationHaveABody()) {
-            addDeferredDeclToEmit(GD.getWithDecl(FD));
+            addDeferredDeclToEmit(GD.getWithDecl(FD), MangledName);
             break;
           }
         }
@@ -3908,7 +3919,7 @@ CodeGenModule::GetOrCreateLLVMGlobal(StringRef MangledName, llvm::Type *Ty,
   if (DDI != DeferredDecls.end()) {
     // Move the potentially referenced deferred decl to the DeferredDeclsToEmit
     // list, and remove it from DeferredDecls (since we don't need it anymore).
-    addDeferredDeclToEmit(DDI->second);
+    addDeferredDeclToEmit(DDI->second, MangledName);
     DeferredDecls.erase(DDI);
   }
 
diff --git a/lib/CodeGen/CodeGenModule.h b/lib/CodeGen/CodeGenModule.h
index 47dc6f41..6395c81a 100644
--- a/lib/CodeGen/CodeGenModule.h
+++ b/lib/CodeGen/CodeGenModule.h
@@ -37,6 +37,8 @@
 #include "llvm/IR/ValueHandle.h"
 #include "llvm/Transforms/Utils/SanitizerStats.h"
 
+#include <unordered_map>
+
 namespace llvm {
 class Module;
 class Constant;
@@ -53,6 +55,7 @@ class IndexedInstrProfReader;
 namespace clang {
 class ASTContext;
 class AtomicType;
+class CodeGeneratorImpl; // hack needed by cling
 class FunctionDecl;
 class IdentifierInfo;
 class ObjCMethodDecl;
@@ -347,11 +350,31 @@ private:
   /// yet.
   std::map<StringRef, GlobalDecl> DeferredDecls;
 
+  /// Decls that were DeferredDecls and have now been emitted.
+  std::map<StringRef, GlobalDecl> EmittedDeferredDecls;
+  void addEmittedDeferredDecl(GlobalDecl GD, StringRef MangledName) {
+    bool IsAFunction = isa<FunctionDecl>(GD.getDecl());
+    const VarDecl* VD = IsAFunction ? nullptr : dyn_cast<VarDecl>(GD.getDecl());
+    assert((IsAFunction || VD) && "Unexpected Decl type!");
+    bool ExcludeCtor = false; // FIXME: this is too simple!
+    llvm::GlobalValue::LinkageTypes L
+      = IsAFunction ? getFunctionLinkage(GD) :
+      getLLVMLinkageVarDefinition(VD, isTypeConstant(VD->getType(),
+                                                     ExcludeCtor));
+    if (llvm::GlobalValue::isWeakForLinker(L)
+        || llvm::GlobalValue::isInternalLinkage(L)) {
+      if (MangledName.empty())
+        MangledName = getMangledName(GD);
+      EmittedDeferredDecls[MangledName] = GD;
+    }
+  }
+
   /// This is a list of deferred decls which we have seen that *are* actually
   /// referenced. These get code generated when the module is done.
   std::vector<GlobalDecl> DeferredDeclsToEmit;
-  void addDeferredDeclToEmit(GlobalDecl GD) {
+  void addDeferredDeclToEmit(GlobalDecl GD, StringRef MangledName) {
     DeferredDeclsToEmit.emplace_back(GD);
+    addEmittedDeferredDecl(GD, MangledName);
   }
 
   /// List of alias we have emitted. Used to make sure that what they point to
@@ -1626,6 +1649,7 @@ private:
 
   llvm::Metadata *CreateMetadataIdentifierImpl(QualType T, MetadataTypeMap &Map,
                                                StringRef Suffix);
+  friend class clang::CodeGeneratorImpl; // hack needed by cling
 };
 
 }  // end namespace CodeGen
diff --git a/lib/CodeGen/ModuleBuilder.cpp b/lib/CodeGen/ModuleBuilder.cpp
index b63f756c..5c1bbf79 100644
--- a/lib/CodeGen/ModuleBuilder.cpp
+++ b/lib/CodeGen/ModuleBuilder.cpp
@@ -12,6 +12,7 @@
 
 #include "clang/CodeGen/ModuleBuilder.h"
 #include "CGDebugInfo.h"
+#include "CGCXXABI.h"
 #include "CodeGenModule.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/DeclObjC.h"
@@ -29,12 +30,20 @@ using namespace clang;
 using namespace CodeGen;
 
 namespace {
+  struct CXXABICtxSwapper: clang::CodeGen::CGCXXABI {
+    void SwapCtx(clang::CodeGen::CGCXXABI &other) {
+      std::swap(MangleCtx, ((CXXABICtxSwapper&)other).MangleCtx);
+    }
+  };
+}
+
+namespace clang {
   class CodeGeneratorImpl : public CodeGenerator {
     DiagnosticsEngine &Diags;
     ASTContext *Ctx;
     const HeaderSearchOptions &HeaderSearchOpts; // Only used for debug info.
     const PreprocessorOptions &PreprocessorOpts; // Only used for debug info.
-    const CodeGenOptions CodeGenOpts;  // Intentionally copied in.
+    CodeGenOptions CodeGenOpts;  // Intentionally copied in.
 
     unsigned HandlingTopLevelDecls;
 
@@ -104,6 +113,11 @@ namespace {
     }
 
     llvm::Module *ReleaseModule() {
+      // Remove pending etc decls in case of error; the asserts in StartModule()
+      // will rightfully be confused otherwise, as none of the decls were
+      // emitted.
+      if (Diags.hasErrorOccurred())
+        Builder->clear();
       return M.release();
     }
 
@@ -126,6 +140,159 @@ namespace {
       return Builder->GetAddrOfGlobal(global, ForDefinition_t(isForDefinition));
     }
 
+    llvm::Module *StartModule(llvm::StringRef ModuleName,
+                              llvm::LLVMContext& C,
+                              const CodeGenOptions& CGO) {
+      assert(!M && "Replacing existing Module?");
+
+      std::unique_ptr<CodeGen::CodeGenModule> OldBuilder;
+      OldBuilder.swap(Builder);
+      CodeGenOpts = CGO;
+      M.reset(new llvm::Module(ModuleName, C));
+      Initialize(*Ctx);
+
+      assert(OldBuilder->DeferredDeclsToEmit.empty()
+             && "Should have emitted all decls deferred to emit.");
+      assert(Builder->DeferredDecls.empty()
+             && "Newly created module should not have deferred decls");
+      Builder->DeferredDecls.swap(OldBuilder->DeferredDecls);
+
+      assert(OldBuilder->EmittedDeferredDecls.empty()
+             && "Still have (unmerged) EmittedDeferredDecls deferred decls");
+
+      assert(Builder->DeferredVTables.empty()
+             && "Newly created module should not have deferred vtables");
+      Builder->DeferredVTables.swap(OldBuilder->DeferredVTables);
+
+      assert(Builder->Manglings.empty()
+             && "Newly created module should not have manglings");
+      // Calls swap() internally, *also* swapping the Allocator object which is
+      // essential to keep the storage!
+      Builder->Manglings = std::move(OldBuilder->Manglings);
+
+      assert(Builder->WeakRefReferences.empty()
+             && "Newly created module should not have weakRefRefs");
+      Builder->WeakRefReferences.swap(OldBuilder->WeakRefReferences);
+
+      ((CXXABICtxSwapper&)*Builder->ABI).SwapCtx(*OldBuilder->ABI);
+      Builder->TBAA.swap(OldBuilder->TBAA);
+
+      return M.get();
+    }
+
+    void print(llvm::raw_ostream& out) {
+      out << "\n\nCodeGen:\n";
+      //llvm::SmallPtrSet<llvm::GlobalValue*, 10> WeakRefReferences;
+      out << " WeakRefReferences (llvm::SmallPtrSet<llvm::GlobalValue*, 10>)\n";
+      for(auto I = Builder->WeakRefReferences.begin(),
+            E = Builder->WeakRefReferences.end(); I != E; ++I) {
+        (*I)->print(out);
+        out << "\n";
+      }
+
+      //llvm::StringMap<GlobalDecl> DeferredDecls;
+      out << " DeferredDecls (llvm::StringMap<GlobalDecl>)\n";
+      for(auto I = Builder->DeferredDecls.begin(),
+            E = Builder->DeferredDecls.end(); I != E; ++I) {
+        out << I->first.str().c_str();
+        I->second.getDecl()->print(out);
+        out << "\n";
+      }
+
+      //std::vector<DeferredGlobal> DeferredDeclsToEmit;
+      out << " DeferredDeclsToEmit (std::vector<DeferredGlobal>)\n";
+      for(auto I = Builder->DeferredDeclsToEmit.begin(),
+            E = Builder->DeferredDeclsToEmit.end(); I != E; ++I) {
+        I->getDecl()->print(out);
+        out << "\n";
+      }
+
+      //std::vector<GlobalDecl> Aliases;
+      out << " Aliases (std::vector<GlobalDecl>)\n";
+      for(auto I = Builder->Aliases.begin(),
+            E = Builder->Aliases.end(); I != E; ++I) {
+        I->getDecl()->print(out);
+        out << "\n";
+      }
+      //typedef llvm::StringMap<llvm::TrackingVH<llvm::Constant> >
+      // ReplacementsTy;
+      //ReplacementsTy Replacements;
+      out
+        << " Replacements (llvm::StringMap<llvm::TrackingVH<llvm::Constant>>\n";
+      for(auto I = Builder->Replacements.begin(),
+            E = Builder->Replacements.end(); I != E; ++I) {
+        out << I->getKey().str().c_str();
+        (*I->getValue()).print(out);
+        out << "\n";
+      }
+
+      //std::vector<const CXXRecordDecl*> DeferredVTables;
+      out << " DeferredVTables (std::vector<const CXXRecordDecl*>\n";
+      for(auto I = Builder->DeferredVTables.begin(),
+            E = Builder->DeferredVTables.end(); I != E; ++I) {
+        (*I)->print(out);
+        out << "\n";
+      }
+
+      //std::vector<llvm::WeakVH> LLVMUsed;
+      out << " LLVMUsed (std::vector<llvm::WeakVH> >\n";
+      for(auto I = Builder->LLVMUsed.begin(),
+            E = Builder->LLVMUsed.end(); I != E; ++I) {
+        (*I)->print(out);
+        out << "\n";
+      }
+
+      // typedef std::vector<std::pair<llvm::Constant*, int> > CtorList;
+      //CtorList GlobalCtors;
+      out << " GlobalCtors (std::vector<std::pair<llvm::Constant*, int> >\n";
+      for(auto I = Builder->GlobalCtors.begin(),
+            E = Builder->GlobalCtors.end(); I != E; ++I) {
+        out << I->Initializer << " : " << I->AssociatedData;
+        out << "\n";
+      }
+
+      //CtorList GlobalDtors;
+      out << " GlobalDtors (std::vector<std::pair<llvm::Constant*, int> >\n";
+      for(auto I = Builder->GlobalDtors.begin(),
+            E = Builder->GlobalDtors.end(); I != E; ++I) {
+        out << I->Initializer << " : " << I->AssociatedData;
+        out << "\n";
+      }
+
+      //llvm::DenseMap<GlobalDecl, StringRef> MangledDeclNames;
+      //std::vector<llvm::Constant*> Annotations;
+      //llvm::StringMap<llvm::Constant*> AnnotationStrings;
+      //llvm::StringMap<llvm::Constant*> CFConstantStringMap;
+      //llvm::StringMap<llvm::GlobalVariable*> ConstantStringMap;
+      out << " ConstantStringMap (llvm::DenseMap<llvm::Constant *, "
+             "llvm::GlobalVariable *>)\n";
+      for(auto I = Builder->ConstantStringMap.begin(),
+            E = Builder->ConstantStringMap.end(); I != E; ++I) {
+        I->first->print(out);
+        I->second->print(out);
+        out << "\n";
+      }
+
+      //llvm::DenseMap<const Decl*, llvm::Constant *> StaticLocalDeclMap;
+      //llvm::DenseMap<const Decl*, llvm::GlobalVariable*> StaticLocalDeclGuardMap;
+      //llvm::DenseMap<const Expr*, llvm::Constant *> MaterializedGlobalTemporaryMap;
+      //llvm::DenseMap<QualType, llvm::Constant *> AtomicSetterHelperFnMap;
+      //llvm::DenseMap<QualType, llvm::Constant *> AtomicGetterHelperFnMap;
+      //llvm::DenseMap<QualType, llvm::Constant *> TypeDescriptorMap;
+      //StaticExternCMap StaticExternCValues;
+      //std::vector<std::pair<const VarDecl *, llvm::GlobalVariable *> >
+      // CXXThreadLocals;
+      //std::vector<llvm::Constant*> CXXThreadLocalInits;
+      //std::vector<llvm::Constant*> CXXGlobalInits;
+      //llvm::DenseMap<const Decl*, unsigned> DelayedCXXInitPosition;
+      //SmallVector<GlobalInitData, 8> PrioritizedCXXGlobalInits;
+      //std::vector<std::pair<llvm::WeakVH,llvm::Constant*> > CXXGlobalDtors;
+      //llvm::SetVector<clang::Module *> ImportedModules;
+      //SmallVector<llvm::Value *, 16> LinkerOptionsMetadata;
+      //
+      out.flush();
+    }
+
     llvm::Module *StartModule(llvm::StringRef ModuleName,
                               llvm::LLVMContext &C) {
       assert(!M && "Replacing existing Module?");
@@ -134,6 +301,21 @@ namespace {
       return M.get();
     }
 
+    void forgetGlobal(llvm::GlobalValue* GV) {
+      for (auto I = Builder->ConstantStringMap.begin(),
+            E = Builder->ConstantStringMap.end(); I != E; ++I) {
+        if (I->second == GV) {
+          Builder->ConstantStringMap.erase(I);
+          break;
+        }
+      }
+    }
+
+    void forgetDecl(const GlobalDecl& GD, llvm::StringRef MangledName) {
+      Builder->DeferredDecls.erase(MangledName);
+      Builder->Manglings.erase(MangledName);
+    }
+
     void Initialize(ASTContext &Context) override {
       Ctx = &Context;
 
@@ -331,11 +513,31 @@ llvm::Constant *CodeGenerator::GetAddrOfGlobal(GlobalDecl global,
            ->GetAddrOfGlobal(global, isForDefinition);
 }
 
+void CodeGenerator::print(llvm::raw_ostream& out) {
+  static_cast<CodeGeneratorImpl*>(this)->print(out);
+}
+
 llvm::Module *CodeGenerator::StartModule(llvm::StringRef ModuleName,
                                          llvm::LLVMContext &C) {
   return static_cast<CodeGeneratorImpl*>(this)->StartModule(ModuleName, C);
 }
 
+void CodeGenerator::forgetGlobal(llvm::GlobalValue* GV) {
+  static_cast<CodeGeneratorImpl*>(this)->forgetGlobal(GV);
+}
+
+void CodeGenerator::forgetDecl(const GlobalDecl& GD,
+                               llvm::StringRef MangledName) {
+  static_cast<CodeGeneratorImpl*>(this)->forgetDecl(GD, MangledName);
+}
+
+
+llvm::Module *CodeGenerator::StartModule(llvm::StringRef ModuleName,
+                                         llvm::LLVMContext& C,
+                                         const CodeGenOptions& CGO) {
+  return static_cast<CodeGeneratorImpl*>(this)->StartModule(ModuleName, C, CGO);
+}
+
 CodeGenerator *clang::CreateLLVMCodeGen(
     DiagnosticsEngine &Diags, llvm::StringRef ModuleName,
     const HeaderSearchOptions &HeaderSearchOpts,
diff --git a/lib/Driver/ToolChains/Arch/AArch64.cpp b/lib/Driver/ToolChains/Arch/AArch64.cpp
index 0e354a49..ed8c7e94 100644
--- a/lib/Driver/ToolChains/Arch/AArch64.cpp
+++ b/lib/Driver/ToolChains/Arch/AArch64.cpp
@@ -191,7 +191,7 @@ void aarch64::getAArch64TargetFeatures(const Driver &D,
   bool success = true;
   // Enable NEON by default.
   Features.push_back("+neon");
-  llvm::StringRef WaMArch;
+  llvm::StringRef WaMArch = "";
   if (ForAS)
     for (const auto *A :
          Args.filtered(options::OPT_Wa_COMMA, options::OPT_Xassembler))
@@ -201,7 +201,7 @@ void aarch64::getAArch64TargetFeatures(const Driver &D,
   // Call getAArch64ArchFeaturesFromMarch only if "-Wa,-march=" or
   // "-Xassembler -march" is detected. Otherwise it may return false
   // and causes Clang to error out.
-  if (!WaMArch.empty())
+  if (WaMArch.size())
     success = getAArch64ArchFeaturesFromMarch(D, WaMArch, Args, Features);
   else if ((A = Args.getLastArg(options::OPT_march_EQ)))
     success = getAArch64ArchFeaturesFromMarch(D, A->getValue(), Args, Features);
@@ -222,15 +222,8 @@ void aarch64::getAArch64TargetFeatures(const Driver &D,
     success = getAArch64MicroArchFeaturesFromMcpu(
         D, getAArch64TargetCPU(Args, Triple, A), Args, Features);
 
-  if (!success) {
-    auto Diag = D.Diag(diag::err_drv_clang_unsupported);
-    // If "-Wa,-march=" is used, 'WaMArch' will contain the argument's value,
-    // while 'A' is uninitialized. Only dereference 'A' in the other case.
-    if (!WaMArch.empty())
-      Diag << "-march=" + WaMArch.str();
-    else
-      Diag << A->getAsString(Args);
-  }
+  if (!success)
+    D.Diag(diag::err_drv_clang_unsupported) << A->getAsString(Args);
 
   if (Args.getLastArg(options::OPT_mgeneral_regs_only)) {
     Features.push_back("-fp-armv8");
diff --git a/lib/Format/TokenAnnotator.cpp b/lib/Format/TokenAnnotator.cpp
index 86c9ac4a..11dc661a 100644
--- a/lib/Format/TokenAnnotator.cpp
+++ b/lib/Format/TokenAnnotator.cpp
@@ -3604,16 +3604,6 @@ static bool isAllmanLambdaBrace(const FormatToken &Tok) {
           !Tok.isOneOf(TT_ObjCBlockLBrace, TT_DictLiteral));
 }
 
-// Returns the first token on the line that is not a comment.
-static const FormatToken *getFirstNonComment(const AnnotatedLine &Line) {
-  const FormatToken *Next = Line.First;
-  if (!Next)
-    return Next;
-  if (Next->is(tok::comment))
-    Next = Next->getNextNonComment();
-  return Next;
-}
-
 bool TokenAnnotator::mustBreakBefore(const AnnotatedLine &Line,
                                      const FormatToken &Right) {
   const FormatToken &Left = *Right.Previous;
@@ -3795,34 +3785,12 @@ bool TokenAnnotator::mustBreakBefore(const AnnotatedLine &Line,
   if (Right.is(TT_InlineASMBrace))
     return Right.HasUnescapedNewline;
 
-  if (isAllmanBrace(Left) || isAllmanBrace(Right)) {
-    auto FirstNonComment = getFirstNonComment(Line);
-    bool AccessSpecifier =
-        FirstNonComment &&
-        FirstNonComment->isOneOf(Keywords.kw_internal, tok::kw_public,
-                                 tok::kw_private, tok::kw_protected);
-
-    if (Style.BraceWrapping.AfterEnum) {
-      if (Line.startsWith(tok::kw_enum) ||
-          Line.startsWith(tok::kw_typedef, tok::kw_enum))
-        return true;
-      // Ensure BraceWrapping for `public enum A {`.
-      if (AccessSpecifier && FirstNonComment->Next &&
-          FirstNonComment->Next->is(tok::kw_enum))
-        return true;
-    }
-
-    // Ensure BraceWrapping for `public interface A {`.
-    if (Style.BraceWrapping.AfterClass &&
-        ((AccessSpecifier && FirstNonComment->Next &&
-          FirstNonComment->Next->is(Keywords.kw_interface)) ||
-         Line.startsWith(Keywords.kw_interface)))
-      return true;
-
-    return (Line.startsWith(tok::kw_class) && Style.BraceWrapping.AfterClass) ||
+  if (isAllmanBrace(Left) || isAllmanBrace(Right))
+    return (Line.startsWith(tok::kw_enum) && Style.BraceWrapping.AfterEnum) ||
+           (Line.startsWith(tok::kw_typedef, tok::kw_enum) &&
+            Style.BraceWrapping.AfterEnum) ||
+           (Line.startsWith(tok::kw_class) && Style.BraceWrapping.AfterClass) ||
            (Line.startsWith(tok::kw_struct) && Style.BraceWrapping.AfterStruct);
-  }
-
   if (Left.is(TT_ObjCBlockLBrace) &&
       Style.AllowShortBlocksOnASingleLine == FormatStyle::SBS_Never)
     return true;
diff --git a/lib/Format/UnwrappedLineParser.cpp b/lib/Format/UnwrappedLineParser.cpp
index 84878750..673986d1 100644
--- a/lib/Format/UnwrappedLineParser.cpp
+++ b/lib/Format/UnwrappedLineParser.cpp
@@ -2532,8 +2532,6 @@ bool UnwrappedLineParser::parseEnum() {
   if (FormatTok->Tok.is(tok::kw_enum))
     nextToken();
 
-  const FormatToken &InitialToken = *FormatTok;
-
   // In TypeScript, "enum" can also be used as property name, e.g. in interface
   // declarations. An "enum" keyword followed by a colon would be a syntax
   // error and thus assume it is just an identifier.
@@ -2580,8 +2578,7 @@ bool UnwrappedLineParser::parseEnum() {
     return true;
   }
 
-  if (!Style.AllowShortEnumsOnASingleLine &&
-      ShouldBreakBeforeBrace(Style, InitialToken))
+  if (!Style.AllowShortEnumsOnASingleLine)
     addUnwrappedLine();
   // Parse enum body.
   nextToken();
diff --git a/lib/Format/WhitespaceManager.cpp b/lib/Format/WhitespaceManager.cpp
index 74136d2f..a822e0aa 100644
--- a/lib/Format/WhitespaceManager.cpp
+++ b/lib/Format/WhitespaceManager.cpp
@@ -1146,15 +1146,14 @@ WhitespaceManager::CellDescriptions WhitespaceManager::getCells(unsigned Start,
       } else if (C.Tok->is(tok::comma)) {
         if (!Cells.empty())
           Cells.back().EndIndex = i;
-        if (C.Tok->getNextNonComment()->isNot(tok::r_brace)) // dangling comma
-          ++Cell;
+        Cell++;
       }
     } else if (Depth == 1) {
       if (C.Tok == MatchingParen) {
         if (!Cells.empty())
           Cells.back().EndIndex = i;
         Cells.push_back(CellDescription{i, ++Cell, i + 1, false, nullptr});
-        CellCount = C.Tok->Previous->isNot(tok::comma) ? Cell + 1 : Cell;
+        CellCount = Cell + 1;
         // Go to the next non-comment and ensure there is a break in front
         const auto *NextNonComment = C.Tok->getNextNonComment();
         while (NextNonComment->is(tok::comma))
@@ -1191,17 +1190,6 @@ WhitespaceManager::CellDescriptions WhitespaceManager::getCells(unsigned Start,
         // So if we split a line previously and the tail line + this token is
         // less then the column limit we remove the split here and just put
         // the column start at a space past the comma
-        //
-        // FIXME This if branch covers the cases where the column is not
-        // the first column. This leads to weird pathologies like the formatting
-        // auto foo = Items{
-        //     Section{
-        //             0, bar(),
-        //     }
-        // };
-        // Well if it doesn't lead to that it's indicative that the line
-        // breaking should be revisited. Unfortunately alot of other options
-        // interact with this
         auto j = i - 1;
         if ((j - 1) > Start && Changes[j].Tok->is(tok::comma) &&
             Changes[j - 1].NewlinesBefore > 0) {
diff --git a/lib/Frontend/CompilerInvocation.cpp b/lib/Frontend/CompilerInvocation.cpp
index 7025028b..e1998cbb 100644
--- a/lib/Frontend/CompilerInvocation.cpp
+++ b/lib/Frontend/CompilerInvocation.cpp
@@ -4605,9 +4605,10 @@ clang::createVFSFromCompilerInvocation(
     const CompilerInvocation &CI, DiagnosticsEngine &Diags,
     IntrusiveRefCntPtr<llvm::vfs::FileSystem> BaseFS) {
   if (CI.getHeaderSearchOpts().VFSOverlayFiles.empty())
-    return BaseFS;
+    return CI.getOverlay();
 
   IntrusiveRefCntPtr<llvm::vfs::FileSystem> Result = BaseFS;
+
   // earlier vfs files are on the bottom
   for (const auto &File : CI.getHeaderSearchOpts().VFSOverlayFiles) {
     llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>> Buffer =
@@ -4625,7 +4626,7 @@ clang::createVFSFromCompilerInvocation(
       continue;
     }
 
-    Result = FS;
+    CI.getOverlay()->pushOverlay(FS);
   }
-  return Result;
+  return CI.getOverlay();
 }
diff --git a/lib/Frontend/VerifyDiagnosticConsumer.cpp b/lib/Frontend/VerifyDiagnosticConsumer.cpp
index 0503ae46..c59da6db 100644
--- a/lib/Frontend/VerifyDiagnosticConsumer.cpp
+++ b/lib/Frontend/VerifyDiagnosticConsumer.cpp
@@ -547,6 +547,11 @@ static bool ParseDirective(StringRef S, ExpectedData *ED, SourceManager &SM,
           Optional<FileEntryRef> File =
               PP->LookupFile(Pos, Filename, false, nullptr, nullptr, CurDir,
                              nullptr, nullptr, nullptr, nullptr, nullptr);
+
+          // Check if the file was virtual
+          if (!File)
+            File = SM.getFileManager().getOptionalFileRef(Filename);
+
           if (!File) {
             Diags.Report(Pos.getLocWithOffset(PH.C - PH.Begin),
                          diag::err_verify_missing_file)
diff --git a/lib/Headers/__clang_cuda_runtime_wrapper.h b/lib/Headers/__clang_cuda_runtime_wrapper.h
index 31126292..f401964b 100644
--- a/lib/Headers/__clang_cuda_runtime_wrapper.h
+++ b/lib/Headers/__clang_cuda_runtime_wrapper.h
@@ -41,7 +41,6 @@
 #include <cmath>
 #include <cstdlib>
 #include <stdlib.h>
-#include <string.h>
 #undef __CUDACC__
 
 // Preserve common macros that will be changed below by us or by CUDA
@@ -206,6 +205,11 @@ inline __host__ double __signbitd(double x) {
 #endif
 
 #if CUDA_VERSION >= 9000
+// CUDA-9.2 needs host-side memcpy for some host functions in
+// device_functions.hpp
+#if CUDA_VERSION >= 9020
+#include <string.h>
+#endif
 #include "crt/math_functions.hpp"
 #else
 #include "math_functions.hpp"
diff --git a/lib/Lex/HeaderSearch.cpp b/lib/Lex/HeaderSearch.cpp
index d5adbcf6..3fb5c61d 100644
--- a/lib/Lex/HeaderSearch.cpp
+++ b/lib/Lex/HeaderSearch.cpp
@@ -152,13 +152,23 @@ std::string HeaderSearch::getPrebuiltModuleFileName(StringRef ModuleName,
   if (FileMapOnly || HSOpts->PrebuiltModulePaths.empty())
     return {};
 
+
+  llvm::StringRef ModuleCachePath = getModuleCachePath();
+  bool CacheFailure = true;
+
   // Then go through each prebuilt module directory and try to find the pcm
   // file.
   for (const std::string &Dir : HSOpts->PrebuiltModulePaths) {
     SmallString<256> Result(Dir);
     llvm::sys::fs::make_absolute(Result);
     llvm::sys::path::append(Result, ModuleName + ".pcm");
-    if (getFileMgr().getFile(Result.str()))
+    // If we have the same ModuleCachePath and PrebuiltModulePath pointing
+    // to the same folder we should not cache the file lookup failure as it
+    // may be currently building an implicit module.
+    if (!ModuleCachePath.empty() && ModuleCachePath == Dir)
+      CacheFailure = false;
+
+    if (getFileMgr().getFile(Result.str(), /*Open=*/false, CacheFailure))
       return std::string(Result);
   }
   return {};
@@ -182,6 +192,7 @@ std::string HeaderSearch::getPrebuiltImplicitModuleFileName(Module *Module) {
   return {};
 }
 
+
 std::string HeaderSearch::getCachedModuleFileName(StringRef ModuleName,
                                                   StringRef ModuleMapPath) {
   return getCachedModuleFileNameImpl(ModuleName, ModuleMapPath,
@@ -345,10 +356,11 @@ StringRef DirectoryLookup::getName() const {
 Optional<FileEntryRef> HeaderSearch::getFileAndSuggestModule(
     StringRef FileName, SourceLocation IncludeLoc, const DirectoryEntry *Dir,
     bool IsSystemHeaderDir, Module *RequestingModule,
-    ModuleMap::KnownHeader *SuggestedModule) {
+    ModuleMap::KnownHeader *SuggestedModule,
+    bool OpenFile /*= true*/, bool CacheFailures /*= true*/) {
   // If we have a module map that might map this header, load it and
   // check whether we'll have a suggestion for a module.
-  auto File = getFileMgr().getFileRef(FileName, /*OpenFile=*/true);
+  auto File = getFileMgr().getFileRef(FileName, OpenFile, CacheFailures);
   if (!File) {
     // For rare, surprising errors (e.g. "out of file handles"), diag the EC
     // message.
@@ -378,7 +390,8 @@ Optional<FileEntryRef> DirectoryLookup::LookupFile(
     SmallVectorImpl<char> *SearchPath, SmallVectorImpl<char> *RelativePath,
     Module *RequestingModule, ModuleMap::KnownHeader *SuggestedModule,
     bool &InUserSpecifiedSystemFramework, bool &IsFrameworkFound,
-    bool &IsInHeaderMap, SmallVectorImpl<char> &MappedName) const {
+    bool &IsInHeaderMap, SmallVectorImpl<char> &MappedName,
+    bool OpenFile) const {
   InUserSpecifiedSystemFramework = false;
   IsInHeaderMap = false;
   MappedName.clear();
@@ -400,7 +413,8 @@ Optional<FileEntryRef> DirectoryLookup::LookupFile(
 
     return HS.getFileAndSuggestModule(TmpDir, IncludeLoc, getDir(),
                                       isSystemHeaderDirectory(),
-                                      RequestingModule, SuggestedModule);
+                                      RequestingModule, SuggestedModule,
+                                      OpenFile);
   }
 
   if (isFramework())
@@ -440,7 +454,7 @@ Optional<FileEntryRef> DirectoryLookup::LookupFile(
       FixupSearchPath();
       return *Result;
     }
-  } else if (auto Res = HS.getFileMgr().getOptionalFileRef(Dest)) {
+  } else if (auto Res = HS.getFileMgr().getOptionalFileRef(Dest, OpenFile)) {
     FixupSearchPath();
     return *Res;
   }
@@ -758,7 +772,7 @@ Optional<FileEntryRef> HeaderSearch::LookupFile(
     SmallVectorImpl<char> *SearchPath, SmallVectorImpl<char> *RelativePath,
     Module *RequestingModule, ModuleMap::KnownHeader *SuggestedModule,
     bool *IsMapped, bool *IsFrameworkFound, bool SkipCache,
-    bool BuildSystemModule) {
+    bool BuildSystemModule, bool OpenFile, bool CacheFailures) {
   if (IsMapped)
     *IsMapped = false;
 
@@ -785,7 +799,8 @@ Optional<FileEntryRef> HeaderSearch::LookupFile(
     // Otherwise, just return the file.
     return getFileAndSuggestModule(Filename, IncludeLoc, nullptr,
                                    /*IsSystemHeaderDir*/false,
-                                   RequestingModule, SuggestedModule);
+                                   RequestingModule, SuggestedModule,
+                                   OpenFile, CacheFailures);
   }
 
   // This is the header that MSVC's header search would have found.
@@ -821,7 +836,8 @@ Optional<FileEntryRef> HeaderSearch::LookupFile(
           BuildSystemModule;
       if (Optional<FileEntryRef> FE = getFileAndSuggestModule(
               TmpDir, IncludeLoc, IncluderAndDir.second, IncluderIsSystemHeader,
-              RequestingModule, SuggestedModule)) {
+              RequestingModule, SuggestedModule,
+              OpenFile, CacheFailures)) {
         if (!Includer) {
           assert(First && "only first includer can have no file");
           return FE;
@@ -921,7 +937,7 @@ Optional<FileEntryRef> HeaderSearch::LookupFile(
     Optional<FileEntryRef> File = SearchDirs[i].LookupFile(
         Filename, *this, IncludeLoc, SearchPath, RelativePath, RequestingModule,
         SuggestedModule, InUserSpecifiedSystemFramework, IsFrameworkFoundInDir,
-        IsInHeaderMap, MappedName);
+        IsInHeaderMap, MappedName, OpenFile);
     if (!MappedName.empty()) {
       assert(IsInHeaderMap && "MappedName should come from a header map");
       CacheLookup.MappedName =
diff --git a/lib/Lex/Lexer.cpp b/lib/Lex/Lexer.cpp
index 64944492..94d9f1a5 100644
--- a/lib/Lex/Lexer.cpp
+++ b/lib/Lex/Lexer.cpp
@@ -791,6 +791,10 @@ SourceLocation Lexer::getLocForEndOfToken(SourceLocation Loc, unsigned Offset,
       return {}; // Points inside the macro expansion.
   }
 
+  // Don't hit the file system for ASTReader tokens.
+  if (SM.isLoadedSourceLocation(Loc))
+    return Loc;
+
   unsigned Len = Lexer::MeasureTokenLength(Loc, SM, LangOpts);
   if (Len > Offset)
     Len = Len - Offset;
diff --git a/lib/Lex/PPDirectives.cpp b/lib/Lex/PPDirectives.cpp
index 3fa87466..72f2aa09 100644
--- a/lib/Lex/PPDirectives.cpp
+++ b/lib/Lex/PPDirectives.cpp
@@ -811,7 +811,8 @@ Optional<FileEntryRef> Preprocessor::LookupFile(
     const DirectoryLookup *&CurDir, SmallVectorImpl<char> *SearchPath,
     SmallVectorImpl<char> *RelativePath,
     ModuleMap::KnownHeader *SuggestedModule, bool *IsMapped,
-    bool *IsFrameworkFound, bool SkipCache) {
+    bool *IsFrameworkFound, bool SkipCache, bool OpenFile,
+    bool CacheFailures) {
   Module *RequestingModule = getModuleForLocation(FilenameLoc);
   bool RequestingModuleIsModuleInterface = !SourceMgr.isInMainFile(FilenameLoc);
 
@@ -820,7 +821,7 @@ Optional<FileEntryRef> Preprocessor::LookupFile(
   SmallVector<std::pair<const FileEntry *, const DirectoryEntry *>, 16>
       Includers;
   bool BuildSystemModule = false;
-  if (!FromDir && !FromFile) {
+  if (!FromDir && !FromFile && getCurrentFileLexer()) {
     FileID FID = getCurrentFileLexer()->getFileID();
     const FileEntry *FileEnt = SourceMgr.getFileEntryForID(FID);
 
@@ -887,7 +888,7 @@ Optional<FileEntryRef> Preprocessor::LookupFile(
   Optional<FileEntryRef> FE = HeaderInfo.LookupFile(
       Filename, FilenameLoc, isAngled, FromDir, CurDir, Includers, SearchPath,
       RelativePath, RequestingModule, SuggestedModule, IsMapped,
-      IsFrameworkFound, SkipCache, BuildSystemModule);
+      IsFrameworkFound, SkipCache, BuildSystemModule, OpenFile, CacheFailures);
   if (FE) {
     if (SuggestedModule && !LangOpts.AsmPreprocessor)
       HeaderInfo.getModuleMap().diagnoseHeaderInclusion(
diff --git a/lib/Lex/PPMacroExpansion.cpp b/lib/Lex/PPMacroExpansion.cpp
index d8ad9d84..7db0481f 100644
--- a/lib/Lex/PPMacroExpansion.cpp
+++ b/lib/Lex/PPMacroExpansion.cpp
@@ -93,6 +93,20 @@ void Preprocessor::appendMacroDirective(IdentifierInfo *II, MacroDirective *MD){
     II->setChangedSinceDeserialization();
 }
 
+void Preprocessor::removeMacro(IdentifierInfo *II, MacroDirective *MD) {
+  assert(II && MD);
+  II->setHasMacroDefinition(false);
+  CurSubmoduleState->Macros.erase(II);
+  if (MacroDirective* prevMD = MD->getPrevious()) {
+    // Avoid assertion in appendMacroDirective.
+    MacroDirective* prevPrevMD = prevMD->getPrevious();
+    prevMD->setPrevious(0);
+    appendMacroDirective(II, prevMD);
+    prevMD->setPrevious(prevPrevMD);
+  }
+}
+
+
 void Preprocessor::setLoadedMacroDirective(IdentifierInfo *II,
                                            MacroDirective *ED,
                                            MacroDirective *MD) {
diff --git a/lib/Lex/Preprocessor.cpp b/lib/Lex/Preprocessor.cpp
index e376fff9..fca2983b 100644
--- a/lib/Lex/Preprocessor.cpp
+++ b/lib/Lex/Preprocessor.cpp
@@ -265,6 +265,43 @@ void Preprocessor::DumpMacro(const MacroInfo &MI) const {
   llvm::errs() << "\n";
 }
 
+void Preprocessor::printMacros(raw_ostream &OS) const {
+  for (macro_iterator I = macro_begin(), E = macro_end(); I != E; ++I) {
+    Preprocessor::printMacro(I->first, I->second.getLatest(), OS);
+  }
+}
+
+void Preprocessor::printMacro(const IdentifierInfo* II,const MacroDirective *MD,
+                              llvm::raw_ostream &OS) const {
+  OS << "<MD: " << MD << ">";
+  OS << II->getName() << " ";
+  OS << "(Tokens:)";
+  const MacroInfo* MI = MD->getMacroInfo();
+  for (unsigned i = 0, e = MI->getNumTokens(); i != e; ++i) {
+    const Token &Tok = MI->getReplacementToken(i);
+    OS << tok::getTokenName(Tok.getKind()) << " '"
+       << getSpelling(Tok) << "'";
+    OS << "\t";
+    if (Tok.isAtStartOfLine())
+      OS << " [StartOfLine]";
+    if (Tok.hasLeadingSpace())
+      OS << " [LeadingSpace]";
+    if (Tok.isExpandDisabled())
+      OS << " [ExpandDisabled]";
+    if (Tok.needsCleaning()) {
+      const char *Start = SourceMgr.getCharacterData(Tok.getLocation());
+      OS << " [UnClean='" << StringRef(Start, Tok.getLength())
+         << "']";
+    }
+    //Do not print location it uses the SourceManager dump to llvm::errs.
+    OS << "\tLoc=<";
+    Tok.getLocation().print(OS, SourceMgr);
+    OS << ">";
+    OS << "  ";
+  }
+  OS << "\n";
+}
+
 void Preprocessor::PrintStats() {
   llvm::errs() << "\n*** Preprocessor Stats:\n";
   llvm::errs() << NumDirectives << " directives found:\n";
diff --git a/lib/Parse/ParsePragma.cpp b/lib/Parse/ParsePragma.cpp
index 42072fe6..3fc3068c 100644
--- a/lib/Parse/ParsePragma.cpp
+++ b/lib/Parse/ParsePragma.cpp
@@ -301,6 +301,10 @@ void markAsReinjectedForRelexing(llvm::MutableArrayRef<clang::Token> Toks) {
 }  // end namespace
 
 void Parser::initializePragmaHandlers() {
+  // No pragma parsing for temporary parsers.
+  if (IsTemporary)
+     return;
+
   AlignHandler = std::make_unique<PragmaAlignHandler>();
   PP.AddPragmaHandler(AlignHandler.get());
 
@@ -434,6 +438,10 @@ void Parser::initializePragmaHandlers() {
 }
 
 void Parser::resetPragmaHandlers() {
+  // No pragma parsing for temporary parsers.
+  if (IsTemporary)
+     return;
+
   // Remove the pragma handlers we installed.
   PP.RemovePragmaHandler(AlignHandler.get());
   AlignHandler.reset();
diff --git a/lib/Parse/Parser.cpp b/lib/Parse/Parser.cpp
index c81dd03f..ed9aae49 100644
--- a/lib/Parse/Parser.cpp
+++ b/lib/Parse/Parser.cpp
@@ -48,15 +48,18 @@ IdentifierInfo *Parser::getSEHExceptKeyword() {
   return Ident__except;
 }
 
-Parser::Parser(Preprocessor &pp, Sema &actions, bool skipFunctionBodies)
+Parser::Parser(Preprocessor &pp, Sema &actions, bool skipFunctionBodies,
+               bool isTemporary /*=false*/)
     : PP(pp), PreferredType(pp.isCodeCompletionEnabled()), Actions(actions),
       Diags(PP.getDiagnostics()), GreaterThanIsOperator(true),
       ColonIsSacred(false), InMessageExpression(false),
-      TemplateParameterDepth(0), ParsingInObjCContainer(false) {
+      TemplateParameterDepth(0), ParsingInObjCContainer(false),
+      IsTemporary(isTemporary) {
   SkipFunctionBodies = pp.isCodeCompletionEnabled() || skipFunctionBodies;
   Tok.startToken();
   Tok.setKind(tok::eof);
-  Actions.CurScope = nullptr;
+  if (!IsTemporary)
+    Actions.CurScope = nullptr;
   NumCachedScopes = 0;
   CurParsedObjCImpl = nullptr;
 
@@ -65,9 +68,11 @@ Parser::Parser(Preprocessor &pp, Sema &actions, bool skipFunctionBodies)
   initializePragmaHandlers();
 
   CommentSemaHandler.reset(new ActionCommentHandler(actions));
-  PP.addCommentHandler(CommentSemaHandler.get());
+  if (!IsTemporary)
+    PP.addCommentHandler(CommentSemaHandler.get());
 
-  PP.setCodeCompletionHandler(*this);
+  if (!IsTemporary)
+    PP.setCodeCompletionHandler(*this);
 }
 
 DiagnosticBuilder Parser::Diag(SourceLocation Loc, unsigned DiagID) {
@@ -453,8 +458,10 @@ Parser::ParseScopeFlags::~ParseScopeFlags() {
 
 Parser::~Parser() {
   // If we still have scopes active, delete the scope tree.
+  if (!IsTemporary) {
   delete getCurScope();
   Actions.CurScope = nullptr;
+  }
 
   // Free the scope cache.
   for (unsigned i = 0, e = NumCachedScopes; i != e; ++i)
@@ -462,9 +469,11 @@ Parser::~Parser() {
 
   resetPragmaHandlers();
 
-  PP.removeCommentHandler(CommentSemaHandler.get());
+  if (!IsTemporary)
+    PP.removeCommentHandler(CommentSemaHandler.get());
 
-  PP.clearCodeCompletionHandler();
+  if (!IsTemporary)
+    PP.clearCodeCompletionHandler();
 
   DestroyTemplateIds();
 }
diff --git a/lib/Sema/HackForDefaultTemplateArg.h b/lib/Sema/HackForDefaultTemplateArg.h
new file mode 100644
index 00000000..e6af62c4
--- /dev/null
+++ b/lib/Sema/HackForDefaultTemplateArg.h
@@ -0,0 +1,52 @@
+//===------- HackForDefaultTemplateArg.h - Make template argument substitution mroe permissive -----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//===----------------------------------------------------------------------===//
+//
+//  Enabling this hack, make the template substitution more permissive and
+//  allows for replacement with non-canonical types.  This is usefull in the
+//  case of client code emulating opaque typedefs and/or wanting to recover
+//  the template instance name as the user would have written if (s)he 
+//  expanded the default paramater explicitly.   For example the user might
+//  have type: vector<int32_t> and the client wants to see:
+//  std::vector<int32_t,std::allocator<int32_t> >
+//
+//  For convenience purposes the implementation is located in
+//  SemaTemplate.cpp
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_SEMA_HACKFORDEFAULTTEMPLATEARG_H
+#define LLVM_CLANG_SEMA_HACKFORDEFAULTTEMPLATEARG_H
+
+namespace clang {
+namespace sema {
+
+///  \brief Enabling this hack makes the template substitution more permissive
+///  and allows for replacement with non-canonical types.  This is usefull in
+///  the case of client code emulating opaque typedefs and/or wanting to recover
+///  the template instance name as the user would have written if (s)he
+///  expanded the default paramater explicitly.   For example the user might
+///  have type: \c vector<int32_t> and the client wants to see:
+///  \c std::vector<int32_t,std::allocator<int32_t> >
+   
+class HackForDefaultTemplateArg {
+  /// \brief Private RAII object that set and reset the hack state.
+
+  static bool AllowNonCanonicalSubstEnabled;
+  bool OldValue;
+public:
+
+  HackForDefaultTemplateArg();
+  ~HackForDefaultTemplateArg();
+  
+  static bool AllowNonCanonicalSubst();
+};
+  
+} // sema
+} // clang
+
+#endif // LLVM_CLANG_SEMA_HACKFORDEFAULTTEMPLATEARG_H
diff --git a/lib/Sema/Sema.cpp b/lib/Sema/Sema.cpp
index 191d89ea..e595fb21 100644
--- a/lib/Sema/Sema.cpp
+++ b/lib/Sema/Sema.cpp
@@ -173,7 +173,7 @@ const unsigned Sema::MaximumAlignment;
 
 Sema::Sema(Preprocessor &pp, ASTContext &ctxt, ASTConsumer &consumer,
            TranslationUnitKind TUKind, CodeCompleteConsumer *CodeCompleter)
-    : ExternalSource(nullptr), isMultiplexExternalSource(false),
+    : ExternalSource(nullptr),
       CurFPFeatures(pp.getLangOpts()), LangOpts(pp.getLangOpts()), PP(pp),
       Context(ctxt), Consumer(consumer), Diags(PP.getDiagnostics()),
       SourceMgr(PP.getSourceManager()), CollectStats(false),
@@ -451,10 +451,6 @@ Sema::~Sema() {
         = dyn_cast_or_null<ExternalSemaSource>(Context.getExternalSource()))
     ExternalSema->ForgetSema();
 
-  // If Sema's ExternalSource is the multiplexer - we own it.
-  if (isMultiplexExternalSource)
-    delete ExternalSource;
-
   // Delete cached satisfactions.
   std::vector<ConstraintSatisfaction *> Satisfactions;
   Satisfactions.reserve(Satisfactions.size());
@@ -528,11 +524,12 @@ void Sema::addExternalSource(ExternalSemaSource *E) {
     return;
   }
 
-  if (isMultiplexExternalSource)
-    static_cast<MultiplexExternalSemaSource*>(ExternalSource)->addSource(*E);
+  if (MultiplexExternalSource.get())
+    MultiplexExternalSource->addSource(*E);
   else {
-    ExternalSource = new MultiplexExternalSemaSource(*ExternalSource, *E);
-    isMultiplexExternalSource = true;
+    MultiplexExternalSource
+      = new MultiplexExternalSemaSource(*ExternalSource, *E);
+    ExternalSource = MultiplexExternalSource.get();
   }
 }
 
@@ -1363,7 +1360,7 @@ void Sema::ActOnEndOfTranslationUnit() {
   }
 
   if (!Diags.isIgnored(diag::warn_mismatched_delete_new, SourceLocation())) {
-    if (ExternalSource)
+    if (ExternalSource && !PP.isIncrementalProcessingEnabled())
       ExternalSource->ReadMismatchingDeleteExpressions(DeleteExprs);
     for (const auto &DeletedFieldInfo : DeleteExprs) {
       for (const auto &DeleteExprLoc : DeletedFieldInfo.second) {
@@ -1371,6 +1368,7 @@ void Sema::ActOnEndOfTranslationUnit() {
                                   DeleteExprLoc.second);
       }
     }
+    DeleteExprs.clear();
   }
 
   // Check we've noticed that we're no longer parsing the initializer for every
diff --git a/lib/Sema/SemaCXXScopeSpec.cpp b/lib/Sema/SemaCXXScopeSpec.cpp
index 1c8f6329..2f70f6ae 100644
--- a/lib/Sema/SemaCXXScopeSpec.cpp
+++ b/lib/Sema/SemaCXXScopeSpec.cpp
@@ -23,7 +23,8 @@
 #include "llvm/ADT/STLExtras.h"
 using namespace clang;
 
-/// Find the current instantiation that associated with the given type.
+#include "HackForDefaultTemplateArg.h"
+
 static CXXRecordDecl *getCurrentInstantiationOf(QualType T,
                                                 DeclContext *CurContext) {
   if (T.isNull())
@@ -107,6 +108,10 @@ DeclContext *Sema::computeDeclContext(const CXXScopeSpec &SS,
           // into that class template definition.
           QualType Injected
             = ClassTemplate->getInjectedClassNameSpecialization();
+
+          // Injected might not be canonical
+          Injected = Injected.getCanonicalType();
+
           if (Context.hasSameType(Injected, ContextType))
             return ClassTemplate->getTemplatedDecl();
 
@@ -150,6 +155,12 @@ DeclContext *Sema::computeDeclContext(const CXXScopeSpec &SS,
   case NestedNameSpecifier::TypeSpec:
   case NestedNameSpecifier::TypeSpecWithTemplate: {
     const TagType *Tag = NNS->getAsType()->getAs<TagType>();
+    if (!Tag 
+	&& sema::HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+      // In case we are in the middle of a template name creation
+      // that tries to keep some of the typedef
+      Tag = NNS->getAsType()->getCanonicalTypeInternal()->getAs<TagType>();
+    }
     assert(Tag && "Non-tag type in nested-name-specifier");
     return Tag->getDecl();
   }
@@ -197,7 +208,7 @@ CXXRecordDecl *Sema::getCurrentInstantiationOf(NestedNameSpecifier *NNS) {
 /// a class template specialization that is not a complete type, we
 /// will attempt to instantiate that class template.
 bool Sema::RequireCompleteDeclContext(CXXScopeSpec &SS,
-                                      DeclContext *DC) {
+                                      DeclContext *&DC) {
   assert(DC && "given null context");
 
   TagDecl *tag = dyn_cast<TagDecl>(DC);
@@ -223,6 +234,12 @@ bool Sema::RequireCompleteDeclContext(CXXScopeSpec &SS,
   // The type must be complete.
   if (RequireCompleteType(loc, type, diag::err_incomplete_nested_name_spec,
                           SS.getRange())) {
+    // The actual information about the decl may have been loaded via an
+    // external source that created a new AST node/decl for the definition
+    // rather than reusing the one we had (DC) like the ASTReader does.
+    // To avoid the caller to continue using the still incomplete decl, let's
+    // set it to the definition.
+    DC = tag->getDefinition();
     SS.SetInvalid(SS.getRange());
     return true;
   }
@@ -534,9 +551,15 @@ bool Sema::BuildCXXNestedNameSpecifier(Scope *S, NestedNameSpecInfo &IdInfo,
     // nested-name-specifier.
 
     // The declaration context must be complete.
-    if (!LookupCtx->isDependentContext() &&
-        RequireCompleteDeclContext(SS, LookupCtx))
-      return true;
+    if (!LookupCtx->isDependentContext()) {
+      if (RequireCompleteDeclContext(SS, LookupCtx)) {
+        return true;
+      } else if (TagDecl* TD = dyn_cast<TagDecl>(LookupCtx)) {
+        // Update the DeclContext to point to the Tag definition.
+        LookupCtx = TD->getDefinition();
+      }
+    }
+
 
     LookupQualifiedName(Found, LookupCtx);
 
diff --git a/lib/Sema/SemaDecl.cpp b/lib/Sema/SemaDecl.cpp
index 205f5800..74268e59 100644
--- a/lib/Sema/SemaDecl.cpp
+++ b/lib/Sema/SemaDecl.cpp
@@ -331,9 +331,14 @@ ParsedType Sema::getTypeName(const IdentifierInfo &II, SourceLocation NameLoc,
       return nullptr;
     }
 
-    if (!LookupCtx->isDependentContext() &&
-        RequireCompleteDeclContext(*SS, LookupCtx))
-      return nullptr;
+    if (!LookupCtx->isDependentContext()) {
+      if (RequireCompleteDeclContext(*SS, LookupCtx)) {
+        return nullptr;
+      } else if (TagDecl* TD = dyn_cast<TagDecl>(LookupCtx)) {
+        // Update the DeclContext to point to the Tag definition.
+        LookupCtx = TD->getDefinition();
+      }
+    }
   }
 
   // FIXME: LookupNestedNameSpecifierName isn't the right kind of
@@ -15279,6 +15284,29 @@ bool Sema::CheckEnumRedeclaration(SourceLocation EnumLoc, bool IsScoped,
       return true;
     }
   } else if (IsFixed != Prev->isFixed()) {
+    // Determine whether this is a cling fwd decl.
+    auto hasFwdDeclAnnotation = [](const Decl *Prev) -> bool {
+      for(auto attr = Prev->specific_attr_begin<AnnotateAttr>(),
+               end = Prev->specific_attr_end<AnnotateAttr> ();
+          attr != end;
+          ++attr)
+      {
+        if (!attr->isInherited()) {
+          llvm::StringRef annotation = attr->getAnnotation();
+          assert(!annotation.empty() && "Empty annotation!");
+          static const char annoTag[] = "$clingAutoload$";
+          if (annotation.startswith(llvm::StringRef(annoTag, strlen(annoTag)))) {
+            // autoload annotation.
+            return true;
+          }
+        }
+      }
+      return false;
+    };
+
+    if (hasFwdDeclAnnotation(Prev))
+      return false;
+
     Diag(EnumLoc, diag::err_enum_redeclare_fixed_mismatch)
       << Prev->isFixed();
     Diag(Prev->getLocation(), diag::note_previous_declaration);
diff --git a/lib/Sema/SemaDeclCXX.cpp b/lib/Sema/SemaDeclCXX.cpp
index ac01beb1..5b3c407a 100644
--- a/lib/Sema/SemaDeclCXX.cpp
+++ b/lib/Sema/SemaDeclCXX.cpp
@@ -537,6 +537,8 @@ bool Sema::MergeCXXFunctionDecl(FunctionDecl *New, FunctionDecl *Old,
         }
       }
 
+      (void)DiagDefaultParamID;
+#if 0 // Disable until Diag is rewired
       // FIXME: If we knew where the '=' was, we could easily provide a fix-it
       // hint here. Alternatively, we could walk the type-source information
       // for NewParam to find the last source location in the type... but it
@@ -558,6 +560,7 @@ bool Sema::MergeCXXFunctionDecl(FunctionDecl *New, FunctionDecl *Old,
 
       Diag(OldParam->getLocation(), diag::note_previous_definition)
         << OldParam->getDefaultArgRange();
+#endif
     } else if (OldParamHasDfl) {
       // Merge the old default argument into the new parameter unless the new
       // function is a friend declaration in a template class. In the latter
@@ -12577,7 +12580,7 @@ bool Sema::CheckUsingDeclQualifier(SourceLocation UsingLoc, bool HasTypename,
     if (Cxx20Enumerator)
       return false; // OK
 
-    auto *RD = NamedContext
+    DeclContext *RD = NamedContext
                    ? cast<CXXRecordDecl>(NamedContext->getRedeclContext())
                    : nullptr;
     if (RD && !RequireCompleteDeclContext(const_cast<CXXScopeSpec &>(SS), RD)) {
diff --git a/lib/Sema/SemaExpr.cpp b/lib/Sema/SemaExpr.cpp
index 4179249e..ca41bc61 100644
--- a/lib/Sema/SemaExpr.cpp
+++ b/lib/Sema/SemaExpr.cpp
@@ -14134,6 +14134,39 @@ ExprResult Sema::CreateBuiltinBinOp(SourceLocation OpLoc,
 
   switch (Opc) {
   case BO_Assign:
+    // ROOT hack: we want to support constructs like n = new TNamed() and if n
+    // wasn't declared we should declare it.
+    if (DeclRefExpr* DRE = dyn_cast<DeclRefExpr>(LHSExpr)) {
+      if (VarDecl* VD = dyn_cast<VarDecl>(DRE->getDecl()))
+        if (const AutoType* aTy = dyn_cast<AutoType>(VD->getType().getTypePtr()))
+          if (const AnnotateAttr* A = VD->getAttr<AnnotateAttr>())
+            // If the deduction didn't take place and it is our special 
+            // annotation
+            if (!aTy->isDeduced() && A->getAnnotation().equals("__Auto")) {
+            QualType ResTy;
+            ASTContext& C = getASTContext();
+            TypeSourceInfo* TrivialTSI
+              = C.getTrivialTypeSourceInfo(VD->getType());
+            if (DeduceAutoType(TrivialTSI, RHSExpr, ResTy) != DAR_Succeeded) {
+               Diag(VD->getLocation(), diag::err_auto_var_requires_init)
+                  << VD->getDeclName() << VD->getType();
+               VD->setInvalidDecl();
+
+               return ExprError();
+            }
+            VD->setTypeSourceInfo(C.getTrivialTypeSourceInfo(ResTy));
+            VD->setType(ResTy);
+            VD->setInit(DefaultLvalueConversion(RHSExpr).get());
+            PushOnScopeChains(VD, getCurScope(), /*Add to ctx*/true);
+
+
+            // Here we need to return 'something' to make the parser happy. 
+            // A reference to the decl is semantically closest to what we want.
+            return BuildDeclRefExpr(VD, VD->getType(), VK_LValue, 
+                                    SourceLocation());
+          }
+    }
+
     ResultTy = CheckAssignmentOperands(LHS.get(), RHS, OpLoc, QualType());
     if (getLangOpts().CPlusPlus &&
         LHS.get()->getObjectKind() != OK_ObjCProperty) {
@@ -15868,7 +15901,7 @@ ExprResult Sema::BuildVAArgExpr(SourceLocation BuiltinLoc,
       // promoted type and the underlying type are the same except for
       // signedness. Ask the AST for the correctly corresponding type and see
       // if that's compatible.
-      if (!PromoteType.isNull() && !UnderlyingType->isBooleanType() &&
+      if (!PromoteType.isNull() &&
           PromoteType->isUnsignedIntegerType() !=
               UnderlyingType->isUnsignedIntegerType()) {
         UnderlyingType =
diff --git a/lib/Sema/SemaExprCXX.cpp b/lib/Sema/SemaExprCXX.cpp
index 7961e794..4d417cb9 100644
--- a/lib/Sema/SemaExprCXX.cpp
+++ b/lib/Sema/SemaExprCXX.cpp
@@ -96,7 +96,8 @@ ParsedType Sema::getConstructorName(IdentifierInfo &II,
     return ParsedType::make(T);
   }
 
-  if (SS.isNotEmpty() && RequireCompleteDeclContext(SS, CurClass))
+  DeclContext *DC = CurClass;
+  if (SS.isNotEmpty() && RequireCompleteDeclContext(SS, DC))
     return ParsedType();
 
   // Find the injected-class-name declaration. Note that we make no attempt to
diff --git a/lib/Sema/SemaLookup.cpp b/lib/Sema/SemaLookup.cpp
index 5e8c4de6..d8599c5f 100644
--- a/lib/Sema/SemaLookup.cpp
+++ b/lib/Sema/SemaLookup.cpp
@@ -2003,8 +2003,14 @@ bool Sema::LookupName(LookupResult &R, Scope *S, bool AllowBuiltinCreation) {
       }
   } else {
     // Perform C++ unqualified name lookup.
-    if (CppLookupName(R, S))
+    if (CppLookupName(R, S)) {
+      if (R.isSingleResult())
+        if (const TagDecl *TD = dyn_cast<TagDecl>(R.getFoundDecl())) {
+          if (!TD->getDefinition() && ExternalSource)
+            ExternalSource->LookupUnqualified(R, S);
+        }
       return true;
+    }
   }
 
   // If we didn't find a use of this identifier, and if the identifier
diff --git a/lib/Sema/SemaModule.cpp b/lib/Sema/SemaModule.cpp
index af95b1a9..8b2a8b1c 100644
--- a/lib/Sema/SemaModule.cpp
+++ b/lib/Sema/SemaModule.cpp
@@ -344,7 +344,7 @@ DeclResult Sema::ActOnModuleImport(SourceLocation StartLoc,
                                    Module *Mod, ModuleIdPath Path) {
   VisibleModules.setVisible(Mod, ImportLoc);
 
-  checkModuleImportContext(*this, Mod, ImportLoc, CurContext);
+  //checkModuleImportContext(*this, Mod, ImportLoc, CurContext);
 
   // FIXME: we should support importing a submodule within a different submodule
   // of the same top-level module. Until we do, make it an error rather than
diff --git a/lib/Sema/SemaTemplate.cpp b/lib/Sema/SemaTemplate.cpp
index 5d26f2d2..b75f39b1 100644
--- a/lib/Sema/SemaTemplate.cpp
+++ b/lib/Sema/SemaTemplate.cpp
@@ -39,6 +39,31 @@
 using namespace clang;
 using namespace sema;
 
+bool HackForDefaultTemplateArg::AllowNonCanonicalSubstEnabled = true;
+
+// Default constructor, record the current value
+// of HackForDefaultTemplateArg::AllowNonCanonicalSubst
+// and set it to true.
+HackForDefaultTemplateArg::HackForDefaultTemplateArg() :
+  OldValue(HackForDefaultTemplateArg::AllowNonCanonicalSubstEnabled)
+{
+  AllowNonCanonicalSubstEnabled = true;
+}
+
+// Destructor, restore the previous value of
+// HackForDefaultTemplateArg::AllowNonCanonicalSubst.
+HackForDefaultTemplateArg::~HackForDefaultTemplateArg()
+{
+  AllowNonCanonicalSubstEnabled = OldValue;
+}
+
+// Return the current value of
+// HackForDefaultTemplateArg::AllowNonCanonicalSubst.
+bool HackForDefaultTemplateArg::AllowNonCanonicalSubst()
+{
+  return AllowNonCanonicalSubstEnabled;
+}
+
 // Exported for use by Parser.
 SourceRange
 clang::getTemplateParamsRange(TemplateParameterList const * const *Ps,
@@ -425,6 +450,11 @@ bool Sema::LookupTemplateName(LookupResult &Found,
     // The declaration context must be complete.
     if (LookupCtx && RequireCompleteDeclContext(SS, LookupCtx))
       return true;
+
+    if (TagDecl* TD = dyn_cast_or_null<TagDecl>(LookupCtx)) {
+      // Update the DeclContext to point to the Tag definition.
+      LookupCtx = TD->getDefinition();
+    }
   }
 
   bool ObjectTypeSearchedInScope = false;
@@ -1709,6 +1739,12 @@ static void SetNestedNameSpecifier(Sema &S, TagDecl *T,
   if (SS.isSet())
     T->setQualifierInfo(SS.getWithLocInContext(S.Context));
 }
+static bool IsRootAutoloadDeclTemplate(ClassTemplateDecl *D) {
+  for (TagDecl *TD = D->getTemplatedDecl(); TD; TD = TD->getPreviousDecl())
+    if (auto AnnotAttr = TD->getAttr<AnnotateAttr>())
+      return AnnotAttr->getAnnotation().startswith("$clingAutoload$");
+  return false;
+}
 
 DeclResult Sema::CheckClassTemplate(
     Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,
@@ -1936,6 +1972,20 @@ DeclResult Sema::CheckClassTemplate(
     return true;
   }
 
+  // AXEL - do not check for redecls of template arg defaults when parsing
+  // dictionary forward decls.
+  bool fwdDeclFromROOT = false;
+  for (const auto &A : Attr) {
+    if (A.getKind() != ParsedAttr::AT_Annotate)
+      continue;
+    if (A.getNumArgs() > 0 && A.isArgExpr(0))
+      if (auto AnnotVal = dyn_cast<StringLiteral>(A.getArgAsExpr(0)))
+        if (AnnotVal->getString().startswith("$clingAutoload$"))
+          fwdDeclFromROOT = true;
+  }
+  if (!fwdDeclFromROOT && PrevClassTemplate)
+    fwdDeclFromROOT = IsRootAutoloadDeclTemplate(PrevClassTemplate);
+
   // Check the template parameter list of this declaration, possibly
   // merging in the template parameter list from the previous class
   // template declaration. Skip this check for a friend in a dependent
@@ -1950,7 +2000,7 @@ DeclResult Sema::CheckClassTemplate(
            SemanticContext->isDependentContext())
               ? TPC_ClassTemplateMember
               : TUK == TUK_Friend ? TPC_FriendClassTemplate : TPC_ClassTemplate,
-          SkipBody))
+          SkipBody, /*Complain*/!fwdDeclFromROOT))
     Invalid = true;
 
   if (SS.isSet()) {
@@ -2670,7 +2720,8 @@ static bool DiagnoseUnexpandedParameterPacks(Sema &S,
 bool Sema::CheckTemplateParameterList(TemplateParameterList *NewParams,
                                       TemplateParameterList *OldParams,
                                       TemplateParamListContext TPC,
-                                      SkipBodyInfo *SkipBody) {
+                                      SkipBodyInfo *SkipBody,
+                                      bool Complain /*true*/) {
   bool Invalid = false;
 
   // C++ [temp.param]p10:
@@ -2705,7 +2756,7 @@ bool Sema::CheckTemplateParameterList(TemplateParameterList *NewParams,
     if (TemplateTypeParmDecl *NewTypeParm
           = dyn_cast<TemplateTypeParmDecl>(*NewParam)) {
       // Check the presence of a default argument here.
-      if (NewTypeParm->hasDefaultArgument() &&
+      if (Complain && NewTypeParm->hasDefaultArgument() &&
           DiagnoseDefaultTemplateArgument(*this, TPC,
                                           NewTypeParm->getLocation(),
                NewTypeParm->getDefaultArgumentInfo()->getTypeLoc()
@@ -2749,7 +2800,7 @@ bool Sema::CheckTemplateParameterList(TemplateParameterList *NewParams,
       }
 
       // Check the presence of a default argument here.
-      if (NewNonTypeParm->hasDefaultArgument() &&
+      if (Complain && NewNonTypeParm->hasDefaultArgument() &&
           DiagnoseDefaultTemplateArgument(*this, TPC,
                                           NewNonTypeParm->getLocation(),
                     NewNonTypeParm->getDefaultArgument()->getSourceRange())) {
@@ -2793,7 +2844,7 @@ bool Sema::CheckTemplateParameterList(TemplateParameterList *NewParams,
       }
 
       // Check the presence of a default argument here.
-      if (NewTemplateParm->hasDefaultArgument() &&
+      if (Complain && NewTemplateParm->hasDefaultArgument() &&
           DiagnoseDefaultTemplateArgument(*this, TPC,
                                           NewTemplateParm->getLocation(),
                      NewTemplateParm->getDefaultArgument().getSourceRange()))
@@ -2841,14 +2892,24 @@ bool Sema::CheckTemplateParameterList(TemplateParameterList *NewParams,
       Invalid = true;
     }
 
-    if (RedundantDefaultArg) {
+    if (RedundantDefaultArg &&
+        (((*OldParam)->hasAttr<AnnotateAttr>() &&
+         (*OldParam)->getAttr<AnnotateAttr>()->getAnnotation() == "rootmap") ||
+        ((*NewParam)->hasAttr<AnnotateAttr>() &&
+         (*NewParam)->getAttr<AnnotateAttr>()->getAnnotation() == "rootmap"))) {
+      RedundantDefaultArg = false;
+    }
+    if (Complain && RedundantDefaultArg) {
       // C++ [temp.param]p12:
       //   A template-parameter shall not be given default arguments
       //   by two different declarations in the same scope.
+
+#if 0 // Disable until Diag is rewired
       Diag(NewDefaultLoc, diag::err_template_param_default_arg_redefinition);
       Diag(OldDefaultLoc, diag::note_template_param_prev_default_arg);
+#endif
       Invalid = true;
-    } else if (MissingDefaultArg && TPC != TPC_FunctionTemplate) {
+    } else if (Complain && MissingDefaultArg && TPC != TPC_FunctionTemplate) {
       // C++ [temp.param]p11:
       //   If a template-parameter of a class template has a default
       //   template-argument, each subsequent template-parameter shall either
@@ -5046,7 +5107,11 @@ bool Sema::CheckTemplateTypeArgument(TemplateTypeParmDecl *Param,
     return true;
 
   // Add the converted template type argument.
-  ArgType = Context.getCanonicalType(ArgType);
+  if (!HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+    ArgType = Context.getCanonicalType(ArgType);
+  } else {
+    ArgType = ArgType.getCanonicalType();
+  }
 
   // Objective-C ARC:
   //   If an explicitly-specified template argument type is a lifetime type
@@ -6215,8 +6280,15 @@ bool Sema::CheckTemplateArgument(TypeSourceInfo *ArgInfo) {
 
   if (Arg->isVariablyModifiedType()) {
     return Diag(SR.getBegin(), diag::err_variably_modified_template_arg) << Arg;
-  } else if (Context.hasSameUnqualifiedType(Arg, Context.OverloadTy)) {
-    return Diag(SR.getBegin(), diag::err_template_arg_overload_type) << SR;
+  } else if (!HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+    if (Context.hasSameUnqualifiedType(Arg, Context.OverloadTy)) {
+      return Diag(SR.getBegin(), diag::err_template_arg_overload_type) << SR;
+    }
+  } else {
+    if (Context.hasSameUnqualifiedType(Arg.getCanonicalType(),
+                                       Context.OverloadTy)) {
+      return Diag(SR.getBegin(), diag::err_template_arg_overload_type) << SR;
+    }
   }
 
   // C++03 [temp.arg.type]p2:
@@ -6228,7 +6300,11 @@ bool Sema::CheckTemplateArgument(TypeSourceInfo *ArgInfo) {
   // a warning.
   if (LangOpts.CPlusPlus11 || Arg->hasUnnamedOrLocalType()) {
     UnnamedLocalNoLinkageFinder Finder(*this, SR);
-    (void)Finder.Visit(Context.getCanonicalType(Arg));
+    if (!HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+      (void)Finder.Visit(Context.getCanonicalType(Arg));
+    } else {
+      (void)Finder.Visit(Arg.getCanonicalType());
+    }
   }
 
   return false;
diff --git a/lib/Sema/SemaTemplateInstantiate.cpp b/lib/Sema/SemaTemplateInstantiate.cpp
index 74889aa3..78b2b7e5 100644
--- a/lib/Sema/SemaTemplateInstantiate.cpp
+++ b/lib/Sema/SemaTemplateInstantiate.cpp
@@ -1826,7 +1826,8 @@ TemplateInstantiator::TransformTemplateTypeParmType(TypeLocBuilder &TLB,
 
     // TODO: only do this uniquing once, at the start of instantiation.
     QualType Result
-      = getSema().Context.getSubstTemplateTypeParmType(T, Replacement);
+      = getSema().Context.getSubstTemplateTypeParmType(T, Replacement,
+                          HackForDefaultTemplateArg::AllowNonCanonicalSubst());
     SubstTemplateTypeParmTypeLoc NewTL
       = TLB.push<SubstTemplateTypeParmTypeLoc>(Result);
     NewTL.setNameLoc(TL.getNameLoc());
@@ -1868,7 +1869,8 @@ TemplateInstantiator::TransformSubstTemplateTypeParmPackType(
 
   Result = getSema().Context.getSubstTemplateTypeParmType(
                                       TL.getTypePtr()->getReplacedParameter(),
-                                                          Result);
+                                                          Result,
+                           HackForDefaultTemplateArg::AllowNonCanonicalSubst());
   SubstTemplateTypeParmTypeLoc NewTL
     = TLB.push<SubstTemplateTypeParmTypeLoc>(Result);
   NewTL.setNameLoc(TL.getNameLoc());
@@ -3173,6 +3175,16 @@ getPatternForClassTemplateSpecialization(
     }
     Pattern = PartialSpec;
   } else {
+    //   -- If no matches are found, the instantiation is generated
+    //      from the primary template.
+
+    // Try first to get it externally:
+    if(S.getExternalSource()) {
+      S.getExternalSource()->CompleteType(ClassTemplateSpec);
+      if (ClassTemplateSpec->getDefinition())
+        return ClassTemplateSpec;
+    }
+
     ClassTemplateDecl *Template = ClassTemplateSpec->getSpecializedTemplate();
     while (Template->getInstantiatedFromMemberTemplate()) {
       // If we've found an explicit specialization of this class template,
diff --git a/lib/Sema/SemaType.cpp b/lib/Sema/SemaType.cpp
index bca21b35..6b99740a 100644
--- a/lib/Sema/SemaType.cpp
+++ b/lib/Sema/SemaType.cpp
@@ -8643,7 +8643,9 @@ bool Sema::RequireCompleteTypeImpl(SourceLocation Loc, QualType T,
 
     // Give the external AST source a chance to complete the type.
     if (auto *Source = Context.getExternalSource()) {
-      if (Tag && Tag->hasExternalLexicalStorage())
+      // AXEL: allows ROOT to autoload/-parse template specializations before
+      // trying to instantiate through the template definition. See ROOT-7462.
+      if (Tag /*&& Tag->hasExternalLexicalStorage()*/)
           Source->CompleteType(Tag);
       if (IFace && IFace->hasExternalLexicalStorage())
           Source->CompleteType(IFace);
diff --git a/lib/Sema/TreeTransform.h b/lib/Sema/TreeTransform.h
index d8a5b6ad..2b2cfbf4 100644
--- a/lib/Sema/TreeTransform.h
+++ b/lib/Sema/TreeTransform.h
@@ -41,6 +41,8 @@
 #include "llvm/Support/ErrorHandling.h"
 #include <algorithm>
 
+#include "HackForDefaultTemplateArg.h"
+
 using namespace llvm::omp;
 
 namespace clang {
@@ -4116,12 +4118,21 @@ NestedNameSpecifierLoc TreeTransform<Derived>::TransformNestedNameSpecifierLoc(
       if (!TL)
         return NestedNameSpecifierLoc();
 
-      if (TL.getType()->isDependentType() || TL.getType()->isRecordType() ||
+      // When using ROOT the type being passed can still be sugared
+      // so that we can construct template instance name with template
+      // default added that still uses the original spelling of the 
+      // arguments. [This is part of adding support for opaque typedef
+      // and 'shorter' names]
+      QualType tlType = TL.getType();
+      if (HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+        tlType = tlType->getCanonicalTypeInternal().getUnqualifiedType();
+      }
+      if (tlType->isDependentType() || tlType->isRecordType() ||
           (SemaRef.getLangOpts().CPlusPlus11 &&
-           TL.getType()->isEnumeralType())) {
-        assert(!TL.getType().hasLocalQualifiers() &&
+           tlType->isEnumeralType())) {
+        assert(!tlType.hasLocalQualifiers() &&
                "Can't get cv-qualifiers here");
-        if (TL.getType()->isEnumeralType())
+        if (tlType->isEnumeralType())
           SemaRef.Diag(TL.getBeginLoc(),
                        diag::warn_cxx98_compat_enum_nested_name_spec);
         SS.Extend(SemaRef.Context, /*FIXME:*/ SourceLocation(), TL,
@@ -6324,7 +6335,7 @@ QualType TreeTransform<Derived>::TransformSubstTemplateTypeParmType(
   Replacement = SemaRef.Context.getCanonicalType(Replacement);
   QualType Result
     = SemaRef.Context.getSubstTemplateTypeParmType(T->getReplacedParameter(),
-                                                   Replacement);
+                                                   Replacement,false);
 
   // Propagate type-source information.
   SubstTemplateTypeParmTypeLoc NewTL
diff --git a/lib/Serialization/ASTReader.cpp b/lib/Serialization/ASTReader.cpp
index 1722572f..2a925707 100644
--- a/lib/Serialization/ASTReader.cpp
+++ b/lib/Serialization/ASTReader.cpp
@@ -1680,6 +1680,12 @@ Token ASTReader::ReadToken(ModuleFile &F, const RecordDataImpl &Record,
     Tok.setIdentifierInfo(II);
   Tok.setKind((tok::TokenKind)Record[Idx++]);
   Tok.setFlag((Token::TokenFlags)Record[Idx++]);
+  if (Tok.isLiteral()) {
+     const RecordData& RD = reinterpret_cast<const RecordData&>(Record);
+     std::string* Lit = new std::string(ReadString(RD, Idx));
+     TokenLiteralDataLoaded.push_back(Lit);
+     Tok.setLiteralData(Lit->c_str());
+  }
   return Tok;
 }
 
@@ -2093,7 +2099,7 @@ void ASTReader::markIdentifierUpToDate(IdentifierInfo *II) {
 
   // Update the generation for this identifier.
   if (getContext().getLangOpts().Modules)
-    IdentifierGeneration[II] = getGeneration();
+    IdentifierGeneration[II] = getGenerationOrNull();
 }
 
 void ASTReader::resolvePendingMacro(IdentifierInfo *II,
@@ -2344,8 +2350,12 @@ InputFile ASTReader::getInputFile(ModuleFile &F, unsigned ID, bool Complain) {
 
   // For an overridden file, create a virtual file with the stored
   // size/timestamp.
-  if ((Overridden || Transient) && !File)
+  bool DisableValidation = bool(PP.getPreprocessorOpts().DisablePCHOrModuleValidation &
+                                DisableValidationForModuleKind::All);
+  if ((Overridden || Transient) && (!File || DisableValidation)) {
     File = FileMgr.getVirtualFileRef(Filename, StoredSize, StoredTime);
+    Overridden = true;
+  }
 
   if (!File) {
     if (Complain) {
@@ -2637,9 +2647,10 @@ ASTReader::ReadControlBlock(ModuleFile &F,
       // All user input files reside at the index range [0, NumUserInputs), and
       // system input files reside at [NumUserInputs, NumInputs). For explicitly
       // loaded module files, ignore missing inputs.
-      if (!DisableValidation && F.Kind != MK_ExplicitModule &&
-          F.Kind != MK_PrebuiltModule) {
+      bool Validate = !DisableValidation && F.Kind != MK_ExplicitModule &&
+        F.Kind != MK_PrebuiltModule;
         bool Complain = (ClientLoadCapabilities & ARR_OutOfDate) == 0;
+        Complain &= Validate;
 
         // If we are reading a module, we will create a verification timestamp,
         // so we verify all input files.  Otherwise, verify only user input
@@ -2652,12 +2663,13 @@ ASTReader::ReadControlBlock(ModuleFile &F,
              F.Kind == MK_ImplicitModule))
           N = NumInputs;
 
-        for (unsigned I = 0; I < N; ++I) {
+        for (unsigned I = 0; I < NumInputs; ++I) {
+          if (I == N)
+            Complain = false;
           InputFile IF = getInputFile(F, I+1, Complain);
-          if (!IF.getFile() || IF.isOutOfDate())
+          if (Validate && (!IF.getFile() || IF.isOutOfDate()))
             return OutOfDate;
         }
-      }
 
       if (Listener)
         Listener->visitModuleFile(F.FileName, F.Kind);
@@ -2702,7 +2714,7 @@ ASTReader::ReadControlBlock(ModuleFile &F,
           //
           // FIXME: Allow this for files explicitly specified with -include-pch.
           bool AllowCompatibleConfigurationMismatch =
-              F.Kind == MK_ExplicitModule || F.Kind == MK_PrebuiltModule;
+            F.Kind == MK_ExplicitModule || F.Kind == MK_PrebuiltModule;
 
           ASTReadResult Result =
               ReadOptionsBlock(Stream, ClientLoadCapabilities,
@@ -2838,6 +2850,26 @@ ASTReader::ReadControlBlock(ModuleFile &F,
         else
           SkipPath(Record, Idx);
 
+        // Check if ImportedFile exists on disk
+        if (!llvm::sys::fs::is_directory(ImportedFile)) {
+          StringRef ModuleName = llvm::sys::path::filename(ImportedFile.c_str());
+          ModuleName.consume_back(".pcm");
+          // Get clang::Module pointer by looking up the module name
+          HeaderSearch &HS = PP.getHeaderSearchInfo();
+          Module *M = HS.lookupModule(ModuleName, /*AllowSearch*/ true,
+                                      /*AllowExtraModuleMapSearch*/ true);
+          if (M) {
+            std::string Path = HS.getPrebuiltModuleFileName(M->Name);
+                           if (Path.empty())
+              Path = HS.getCachedModuleFileName(M->Name,
+                   HS.getModuleMap().getModuleMapFileForUniquing(M)->getName());
+            // FIXME: Add a hash comparison to check if ImportedFile's hash and the
+            // new Modules Path's hash matches or not.
+            if (!Path.empty())
+              ImportedFile = Path;
+          }
+        }
+
         // If our client can't cope with us being out of date, we can't cope with
         // our dependency being missing.
         unsigned Capabilities = ClientLoadCapabilities;
@@ -3866,11 +3898,30 @@ void ASTReader::ReadModuleOffsetMap(ModuleFile &F) const {
                           ? ModuleMgr.lookupByModuleName(Name)
                           : ModuleMgr.lookupByFileName(Name));
     if (!OM) {
-      std::string Msg =
-          "SourceLocation remap refers to unknown module, cannot find ";
-      Msg.append(std::string(Name));
-      Error(Msg);
-      return;
+      StringRef ModuleName = llvm::sys::path::filename(Name);
+      ModuleName.consume_back(".pcm");
+      HeaderSearch &HS = PP.getHeaderSearchInfo();
+      Module *M = HS.lookupModule(ModuleName, /*AllowSearch*/ true,
+                                  /*AllowExtraModuleMapSearch*/ true);
+      std::string Path;
+      // If module definition exists in modulemap, search the modulepath in HeaderSearchInfo
+      if (M) {
+        Path = HS.getPrebuiltModuleFileName(M->Name);
+        if (Path.empty())
+          Path = HS.getCachedModuleFileName(M->Name,
+                   HS.getModuleMap().getModuleMapFileForUniquing(M)->getName());
+
+      }
+
+      StringRef NewName = StringRef(Path);
+      OM = ModuleMgr.lookupByFileName(NewName);
+      if (!OM) {
+        std::string Msg =
+           "SourceLocation remap refers to unknown module, cannot find ";
+        Msg.append(std::string(NewName));
+        Error(Msg);
+        return;
+      }
     }
 
     SourceLocation::UIntTy SLocOffset =
@@ -3966,9 +4017,13 @@ ASTReader::ReadModuleMapFileBlock(RecordData &Record, ModuleFile &F,
 
     assert(M && M->Name == F.ModuleName && "found module with different name");
 
+    // Check any additional module map files (e.g. module.private.modulemap)
+    // that are not in the pcm.
+    bool DisableValidation = PP.getPreprocessorOpts().DisablePCHOrModuleValidation !=
+                                  DisableValidationForModuleKind::None;
     // Check the primary module map file.
     auto StoredModMap = FileMgr.getFile(F.ModuleMapPath);
-    if (!StoredModMap || *StoredModMap != ModMap) {
+    if (!DisableValidation && (!StoredModMap || *StoredModMap != ModMap)) {
       assert(ModMap && "found module is missing module map file");
       assert((ImportedBy || F.Kind == MK_ImplicitModule) &&
              "top-level import should be verified");
@@ -3993,8 +4048,7 @@ ASTReader::ReadModuleMapFileBlock(RecordData &Record, ModuleFile &F,
       AdditionalStoredMaps.insert(*SF);
     }
 
-    // Check any additional module map files (e.g. module.private.modulemap)
-    // that are not in the pcm.
+    if (!DisableValidation) {
     if (auto *AdditionalModuleMaps = Map.getAdditionalModuleMapFiles(M)) {
       for (const FileEntry *ModMap : *AdditionalModuleMaps) {
         // Remove files that match
@@ -4017,6 +4071,7 @@ ASTReader::ReadModuleMapFileBlock(RecordData &Record, ModuleFile &F,
       return OutOfDate;
     }
   }
+  }
 
   if (Listener)
     Listener->ReadModuleMapFile(F.ModuleMapPath);
@@ -4512,11 +4567,10 @@ ASTReader::ReadASTCore(StringRef FileName,
                        unsigned ClientLoadCapabilities) {
   ModuleFile *M;
   std::string ErrorStr;
-  ModuleManager::AddModuleResult AddResult
-    = ModuleMgr.addModule(FileName, Type, ImportLoc, ImportedBy,
-                          getGeneration(), ExpectedSize, ExpectedModTime,
-                          ExpectedSignature, readASTFileSignature,
-                          M, ErrorStr);
+  ModuleManager::AddModuleResult AddResult =
+      ModuleMgr.addModule(FileName, Type, ImportLoc, ImportedBy,
+                          getGenerationOrNull(), ExpectedSize, ExpectedModTime,
+                          ExpectedSignature, readASTFileSignature, M, ErrorStr);
 
   switch (AddResult) {
   case ModuleManager::AlreadyLoaded:
@@ -7233,14 +7287,23 @@ void ASTReader::CompleteRedeclChain(const Decl *D) {
     }
   }
 
-  if (auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(D))
-    CTSD->getSpecializedTemplate()->LoadLazySpecializations();
-  if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(D))
-    VTSD->getSpecializedTemplate()->LoadLazySpecializations();
-  if (auto *FD = dyn_cast<FunctionDecl>(D)) {
-    if (auto *Template = FD->getPrimaryTemplate())
-      Template->LoadLazySpecializations();
+  RedeclarableTemplateDecl *Template = nullptr;
+  ArrayRef<TemplateArgument> Args;
+  if (auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(D)) {
+    Template = CTSD->getSpecializedTemplate();
+    Args = CTSD->getTemplateArgs().asArray();
+  } else if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(D)) {
+    Template = VTSD->getSpecializedTemplate();
+    Args = VTSD->getTemplateArgs().asArray();
+  } else if (auto *FD = dyn_cast<FunctionDecl>(D)) {
+    if (auto *Tmplt = FD->getPrimaryTemplate()) {
+      Template = Tmplt;
+      Args = FD->getTemplateSpecializationArgs()->asArray();
+    }
   }
+
+  if (Template)
+    Template->loadLazySpecializationsImpl(Args);
 }
 
 CXXCtorInitializer **
@@ -8231,7 +8294,7 @@ void ASTReader::ReadMethodPool(Selector Sel) {
   // Get the selector generation and update it to the current generation.
   unsigned &Generation = SelectorGeneration[Sel];
   unsigned PriorGeneration = Generation;
-  Generation = getGeneration();
+  Generation = getGenerationOrNull();
   SelectorOutOfDate[Sel] = false;
 
   // Search for methods defined with this selector.
@@ -11685,6 +11748,9 @@ ASTReader::ASTReader(Preprocessor &PP, InMemoryModuleCache &ModuleCache,
 ASTReader::~ASTReader() {
   if (OwnsDeserializationListener)
     delete DeserializationListener;
+  for (auto PStr: TokenLiteralDataLoaded) {
+     delete PStr;
+  }
 }
 
 IdentifierResolver &ASTReader::getIdResolver() {
diff --git a/lib/Serialization/ASTReaderDecl.cpp b/lib/Serialization/ASTReaderDecl.cpp
index ff79f91e..c47a239e 100644
--- a/lib/Serialization/ASTReaderDecl.cpp
+++ b/lib/Serialization/ASTReaderDecl.cpp
@@ -83,9 +83,9 @@ namespace clang {
     ASTReader::RecordLocation Loc;
     const DeclID ThisDeclID;
     const SourceLocation ThisDeclLoc;
-
     using RecordData = ASTReader::RecordData;
-
+    using LazySpecializationInfo
+      = RedeclarableTemplateDecl::LazySpecializationInfo;
     TypeID DeferredTypeID = 0;
     unsigned AnonymousDeclNumber;
     GlobalDeclID NamedDeclForTagDecl = 0;
@@ -131,9 +131,16 @@ namespace clang {
       return Record.readString();
     }
 
-    void readDeclIDList(SmallVectorImpl<DeclID> &IDs) {
+    LazySpecializationInfo ReadLazySpecializationInfo() {
+      DeclID ID = readDeclID();
+      unsigned Hash = Record.readInt();
+      bool IsPartial = Record.readInt();
+      return LazySpecializationInfo(ID, Hash, IsPartial);
+    }
+
+    void readDeclIDList(SmallVectorImpl<LazySpecializationInfo> &IDs) {
       for (unsigned I = 0, Size = Record.readInt(); I != Size; ++I)
-        IDs.push_back(readDeclID());
+        IDs.push_back(ReadLazySpecializationInfo());
     }
 
     Decl *readDecl() {
@@ -254,7 +261,7 @@ namespace clang {
 
     template <typename T> static
     void AddLazySpecializations(T *D,
-                                SmallVectorImpl<serialization::DeclID>& IDs) {
+                                SmallVectorImpl<LazySpecializationInfo>& IDs) {
       if (IDs.empty())
         return;
 
@@ -264,12 +271,11 @@ namespace clang {
       auto *&LazySpecializations = D->getCommonPtr()->LazySpecializations;
 
       if (auto &Old = LazySpecializations) {
-        IDs.insert(IDs.end(), Old + 1, Old + 1 + Old[0]);
-        llvm::sort(IDs);
+        IDs.insert(IDs.end(), Old + 1, Old + 1 + Old[0].DeclID);
+        std::sort(IDs.begin(), IDs.end());
         IDs.erase(std::unique(IDs.begin(), IDs.end()), IDs.end());
       }
-
-      auto *Result = new (C) serialization::DeclID[1 + IDs.size()];
+      auto *Result = new (C) LazySpecializationInfo[1 + IDs.size()];
       *Result = IDs.size();
       std::copy(IDs.begin(), IDs.end(), Result + 1);
 
@@ -307,7 +313,7 @@ namespace clang {
     void ReadFunctionDefinition(FunctionDecl *FD);
     void Visit(Decl *D);
 
-    void UpdateDecl(Decl *D, SmallVectorImpl<serialization::DeclID> &);
+    void UpdateDecl(Decl *D, llvm::SmallVectorImpl<LazySpecializationInfo>&);
 
     static void setNextObjCCategory(ObjCCategoryDecl *Cat,
                                     ObjCCategoryDecl *Next) {
@@ -2135,7 +2141,7 @@ void ASTDeclReader::VisitClassTemplateDecl(ClassTemplateDecl *D) {
   if (ThisDeclID == Redecl.getFirstID()) {
     // This ClassTemplateDecl owns a CommonPtr; read it to keep track of all of
     // the specializations.
-    SmallVector<serialization::DeclID, 32> SpecIDs;
+    SmallVector<LazySpecializationInfo, 32> SpecIDs;
     readDeclIDList(SpecIDs);
     ASTDeclReader::AddLazySpecializations(D, SpecIDs);
   }
@@ -2162,7 +2168,7 @@ void ASTDeclReader::VisitVarTemplateDecl(VarTemplateDecl *D) {
   if (ThisDeclID == Redecl.getFirstID()) {
     // This VarTemplateDecl owns a CommonPtr; read it to keep track of all of
     // the specializations.
-    SmallVector<serialization::DeclID, 32> SpecIDs;
+    SmallVector<LazySpecializationInfo, 32> SpecIDs;
     readDeclIDList(SpecIDs);
     ASTDeclReader::AddLazySpecializations(D, SpecIDs);
   }
@@ -2272,7 +2278,7 @@ void ASTDeclReader::VisitFunctionTemplateDecl(FunctionTemplateDecl *D) {
 
   if (ThisDeclID == Redecl.getFirstID()) {
     // This FunctionTemplateDecl owns a CommonPtr; read it.
-    SmallVector<serialization::DeclID, 32> SpecIDs;
+    SmallVector<LazySpecializationInfo, 32> SpecIDs;
     readDeclIDList(SpecIDs);
     ASTDeclReader::AddLazySpecializations(D, SpecIDs);
   }
@@ -4182,7 +4188,9 @@ void ASTReader::loadDeclUpdateRecords(PendingUpdateRecord &Record) {
   ProcessingUpdatesRAIIObj ProcessingUpdates(*this);
   DeclUpdateOffsetsMap::iterator UpdI = DeclUpdateOffsets.find(ID);
 
-  SmallVector<serialization::DeclID, 8> PendingLazySpecializationIDs;
+  using LazySpecializationInfo
+    = RedeclarableTemplateDecl::LazySpecializationInfo;
+  llvm::SmallVector<LazySpecializationInfo, 8> PendingLazySpecializationIDs;
 
   if (UpdI != DeclUpdateOffsets.end()) {
     auto UpdateOffsets = std::move(UpdI->second);
@@ -4453,7 +4461,7 @@ static void forAllLaterRedecls(DeclT *D, Fn F) {
 }
 
 void ASTDeclReader::UpdateDecl(Decl *D,
-   llvm::SmallVectorImpl<serialization::DeclID> &PendingLazySpecializationIDs) {
+        SmallVectorImpl<LazySpecializationInfo> &PendingLazySpecializationIDs) {
   while (Record.getIdx() < Record.size()) {
     switch ((DeclUpdateKind)Record.readInt()) {
     case UPD_CXX_ADDED_IMPLICIT_MEMBER: {
@@ -4470,7 +4478,7 @@ void ASTDeclReader::UpdateDecl(Decl *D,
 
     case UPD_CXX_ADDED_TEMPLATE_SPECIALIZATION:
       // It will be added to the template's lazy specialization set.
-      PendingLazySpecializationIDs.push_back(readDeclID());
+      PendingLazySpecializationIDs.push_back(ReadLazySpecializationInfo());
       break;
 
     case UPD_CXX_ADDED_ANONYMOUS_NAMESPACE: {
diff --git a/lib/Serialization/ASTReaderInternals.h b/lib/Serialization/ASTReaderInternals.h
index 265a77fd..1016c9b8 100644
--- a/lib/Serialization/ASTReaderInternals.h
+++ b/lib/Serialization/ASTReaderInternals.h
@@ -47,7 +47,7 @@ class ASTDeclContextNameLookupTrait {
 
 public:
   // Maximum number of lookup tables we allow before condensing the tables.
-  static const int MaxTables = 4;
+  static const int MaxTables = 256;
 
   /// The lookup result is a list of global declaration IDs.
   using data_type = SmallVector<DeclID, 4>;
diff --git a/lib/Serialization/ASTWriter.cpp b/lib/Serialization/ASTWriter.cpp
index 66c207ad..d0895a76 100644
--- a/lib/Serialization/ASTWriter.cpp
+++ b/lib/Serialization/ASTWriter.cpp
@@ -4183,6 +4183,8 @@ void ASTWriter::AddToken(const Token &Tok, RecordDataImpl &Record) {
   Record.push_back(Tok.getKind());
   // FIXME: Should translate token flags to a stable encoding.
   Record.push_back(Tok.getFlags());
+  if (Tok.isLiteral())
+    AddString(StringRef(Tok.getLiteralData(), Tok.getLength()), Record);
 }
 
 void ASTWriter::AddString(StringRef Str, RecordDataImpl &Record) {
@@ -4875,12 +4877,29 @@ void ASTWriter::WriteDeclUpdatesBlocks(RecordDataImpl &OffsetsRecord) {
 
       switch (Kind) {
       case UPD_CXX_ADDED_IMPLICIT_MEMBER:
-      case UPD_CXX_ADDED_TEMPLATE_SPECIALIZATION:
       case UPD_CXX_ADDED_ANONYMOUS_NAMESPACE:
         assert(Update.getDecl() && "no decl to add?");
         Record.push_back(GetDeclRef(Update.getDecl()));
         break;
-
+      case UPD_CXX_ADDED_TEMPLATE_SPECIALIZATION: {
+        const Decl *Spec = Update.getDecl();
+        assert(Spec && "no decl to add?");
+        Record.push_back(GetDeclRef(Spec));
+        ArrayRef<TemplateArgument> Args;
+        if (auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(Spec))
+          Args = CTSD->getTemplateArgs().asArray();
+        else if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(Spec))
+          Args = VTSD->getTemplateArgs().asArray();
+        else if (auto *FD = dyn_cast<FunctionDecl>(Spec))
+          Args = FD->getTemplateSpecializationArgs()->asArray();
+        assert(Args.size());
+        Record.push_back(TemplateArgumentList::ComputeODRHash(Args));
+        bool IsPartialSpecialization
+          = isa<ClassTemplatePartialSpecializationDecl>(Spec) ||
+          isa<VarTemplatePartialSpecializationDecl>(Spec);
+        Record.push_back(IsPartialSpecialization);
+        break;
+      }
       case UPD_CXX_ADDED_FUNCTION_DEFINITION:
         break;
 
diff --git a/lib/Serialization/ASTWriterDecl.cpp b/lib/Serialization/ASTWriterDecl.cpp
index e9315f67..6446cd70 100644
--- a/lib/Serialization/ASTWriterDecl.cpp
+++ b/lib/Serialization/ASTWriterDecl.cpp
@@ -173,11 +173,11 @@ namespace clang {
       Record.AddSourceLocation(typeParams->getRAngleLoc());
     }
 
-    /// Add to the record the first declaration from each module file that
-    /// provides a declaration of D. The intent is to provide a sufficient
-    /// set such that reloading this set will load all current redeclarations.
-    void AddFirstDeclFromEachModule(const Decl *D, bool IncludeLocal) {
-      llvm::MapVector<ModuleFile*, const Decl*> Firsts;
+    /// Collect the first declaration from each module file that provides a
+    /// declaration of D.
+    void CollectFirstDeclFromEachModule(const Decl *D, bool IncludeLocal,
+                            llvm::MapVector<ModuleFile*, const Decl*> &Firsts) {
+
       // FIXME: We can skip entries that we know are implied by others.
       for (const Decl *R = D->getMostRecentDecl(); R; R = R->getPreviousDecl()) {
         if (R->isFromASTFile())
@@ -185,10 +185,49 @@ namespace clang {
         else if (IncludeLocal)
           Firsts[nullptr] = R;
       }
+    }
+
+    /// Add to the record the first declaration from each module file that
+    /// provides a declaration of D. The intent is to provide a sufficient
+    /// set such that reloading this set will load all current redeclarations.
+    void AddFirstDeclFromEachModule(const Decl *D, bool IncludeLocal) {
+      llvm::MapVector<ModuleFile*, const Decl*> Firsts;
+      CollectFirstDeclFromEachModule(D, IncludeLocal, Firsts);
+
       for (const auto &F : Firsts)
         Record.AddDeclRef(F.second);
     }
 
+    /// Add to the record the first template specialization from each module
+    /// file that provides a declaration of D. We store the DeclId and an
+    /// ODRHash of the template arguments of D which should provide enough
+    /// information to load D only if the template instantiator needs it.
+    void AddFirstSpecializationDeclFromEachModule(const Decl *D,
+                                                  bool IncludeLocal) {
+      assert(isa<ClassTemplateSpecializationDecl>(D) ||
+             isa<VarTemplateSpecializationDecl>(D) || isa<FunctionDecl>(D) &&
+             "Must not be called with other decls");
+      llvm::MapVector<ModuleFile*, const Decl*> Firsts;
+      CollectFirstDeclFromEachModule(D, IncludeLocal, Firsts);
+
+      for (const auto &F : Firsts) {
+        Record.AddDeclRef(F.second);
+        ArrayRef<TemplateArgument> Args;
+        if (auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(D))
+          Args = CTSD->getTemplateArgs().asArray();
+        else if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(D))
+          Args = VTSD->getTemplateArgs().asArray();
+        else if (auto *FD = dyn_cast<FunctionDecl>(D))
+          Args = FD->getTemplateSpecializationArgs()->asArray();
+        assert(Args.size());
+        Record.push_back(TemplateArgumentList::ComputeODRHash(Args));
+        bool IsPartialSpecialization
+          = isa<ClassTemplatePartialSpecializationDecl>(D) ||
+          isa<VarTemplatePartialSpecializationDecl>(D);
+        Record.push_back(IsPartialSpecialization);
+      }
+    }
+
     /// Get the specialization decl from an entry in the specialization list.
     template <typename EntryType>
     typename RedeclarableTemplateDecl::SpecEntryTraits<EntryType>::DeclType *
@@ -201,7 +240,8 @@ namespace clang {
     decltype(T::PartialSpecializations) &getPartialSpecializations(T *Common) {
       return Common->PartialSpecializations;
     }
-    ArrayRef<Decl> getPartialSpecializations(FunctionTemplateDecl::Common *) {
+    MutableArrayRef<FunctionTemplateSpecializationInfo>
+    getPartialSpecializations(FunctionTemplateDecl::Common *) {
       return None;
     }
 
@@ -218,9 +258,11 @@ namespace clang {
         assert(!Common->LazySpecializations);
       }
 
-      ArrayRef<DeclID> LazySpecializations;
+      using LazySpecializationInfo
+        = RedeclarableTemplateDecl::LazySpecializationInfo;
+      ArrayRef<LazySpecializationInfo> LazySpecializations;
       if (auto *LS = Common->LazySpecializations)
-        LazySpecializations = llvm::makeArrayRef(LS + 1, LS[0]);
+        LazySpecializations = llvm::makeArrayRef(LS + 1, LS[0].DeclID);
 
       // Add a slot to the record for the number of specializations.
       unsigned I = Record.size();
@@ -236,12 +278,20 @@ namespace clang {
 
       for (auto *D : Specs) {
         assert(D->isCanonicalDecl() && "non-canonical decl in set");
-        AddFirstDeclFromEachModule(D, /*IncludeLocal*/true);
+        AddFirstSpecializationDeclFromEachModule(D, /*IncludeLocal*/true);
+      }
+      for (auto &SpecInfo : LazySpecializations) {
+        Record.push_back(SpecInfo.DeclID);
+        Record.push_back(SpecInfo.ODRHash);
+        Record.push_back(SpecInfo.IsPartial);
       }
-      Record.append(LazySpecializations.begin(), LazySpecializations.end());
 
-      // Update the size entry we added earlier.
-      Record[I] = Record.size() - I - 1;
+      // Update the size entry we added earlier. We linerized the
+      // LazySpecializationInfo members and we need to adjust the size as we
+      // will read them always together.
+      assert ((Record.size() - I - 1) % 3 == 0
+              && "Must be divisible by LazySpecializationInfo count!");
+      Record[I] = (Record.size() - I - 1) / 3;
     }
 
     /// Ensure that this template specialization is associated with the specified
diff --git a/lib/Serialization/GlobalModuleIndex.cpp b/lib/Serialization/GlobalModuleIndex.cpp
index 52ce17d9..c784d6ab 100644
--- a/lib/Serialization/GlobalModuleIndex.cpp
+++ b/lib/Serialization/GlobalModuleIndex.cpp
@@ -290,6 +290,13 @@ GlobalModuleIndex::getKnownModules(SmallVectorImpl<ModuleFile *> &ModuleFiles) {
   }
 }
 
+void GlobalModuleIndex::getKnownModuleFileNames(StringSet<> &ModuleFiles) {
+  ModuleFiles.clear();
+  for (unsigned I = 0, N = Modules.size(); I != N; ++I) {
+    ModuleFiles.insert(Modules[I].FileName);
+  }
+}
+
 void GlobalModuleIndex::getModuleDependencies(
        ModuleFile *File,
        SmallVectorImpl<ModuleFile *> &Dependencies) {
@@ -334,6 +341,32 @@ bool GlobalModuleIndex::lookupIdentifier(StringRef Name, HitSet &Hits) {
   return true;
 }
 
+bool GlobalModuleIndex::lookupIdentifier(StringRef Name, FileNameHitSet &Hits) {
+  Hits.clear();
+
+  // If there's no identifier index, there is nothing we can do.
+  if (!IdentifierIndex)
+    return false;
+
+  // Look into the identifier index.
+  ++NumIdentifierLookups;
+  IdentifierIndexTable &Table =
+      *static_cast<IdentifierIndexTable *>(IdentifierIndex);
+  IdentifierIndexTable::iterator Known = Table.find(Name);
+  if (Known == Table.end()) {
+    return false;
+  }
+
+  SmallVector<unsigned, 2> ModuleIDs = *Known;
+  for (unsigned I = 0, N = ModuleIDs.size(); I != N; ++I) {
+    assert(!Modules[ModuleIDs[I]].FileName.empty());
+    Hits.insert(Modules[ModuleIDs[I]].FileName);
+  }
+
+  ++NumIdentifierLookupHits;
+  return true;
+}
+
 bool GlobalModuleIndex::loadedModuleFile(ModuleFile *File) {
   // Look for the module in the global module index based on the module name.
   StringRef Name = File->ModuleName;
@@ -410,9 +443,6 @@ namespace {
 
   /// Builder that generates the global module index file.
   class GlobalModuleIndexBuilder {
-    FileManager &FileMgr;
-    const PCHContainerReader &PCHContainerRdr;
-
     /// Mapping from files to module file information.
     typedef llvm::MapVector<const FileEntry *, ModuleFileInfo> ModuleFilesMap;
 
@@ -452,12 +482,19 @@ namespace {
     }
 
   public:
-    explicit GlobalModuleIndexBuilder(
-        FileManager &FileMgr, const PCHContainerReader &PCHContainerRdr)
-        : FileMgr(FileMgr), PCHContainerRdr(PCHContainerRdr) {}
+    explicit GlobalModuleIndexBuilder(GlobalModuleIndex::UserDefinedInterestingIDs* ExternalIDs) {
+      if (!ExternalIDs)
+        return;
+
+      for (const auto & I : *ExternalIDs)
+        for (const FileEntry * J : I.getValue())
+          InterestingIdentifiers[I.getKey()].push_back(getModuleFileInfo(J).ID);
+    }
 
     /// Load the contents of the given module file into the builder.
-    llvm::Error loadModuleFile(const FileEntry *File);
+    ///
+    llvm::Error loadModuleFile(const FileEntry *File, FileManager &FileMgr,
+                               const PCHContainerReader &PCHContainerRdr);
 
     /// Write the index to the given bitstream.
     /// \returns true if an error occurred, false otherwise.
@@ -528,7 +565,9 @@ namespace {
   };
 }
 
-llvm::Error GlobalModuleIndexBuilder::loadModuleFile(const FileEntry *File) {
+llvm::Error GlobalModuleIndexBuilder::loadModuleFile(const FileEntry *File,
+                                                     FileManager &FileMgr,
+                                    const PCHContainerReader &PCHContainerRdr) {
   // Open the module file.
 
   auto Buffer = FileMgr.getBufferForFile(File, /*isVolatile=*/true);
@@ -764,7 +803,8 @@ bool GlobalModuleIndexBuilder::writeIndex(llvm::BitstreamWriter &Stream) {
         // Verify Signature.
         return true;
     } else if (Info.StoredSize != File->getSize() ||
-               Info.StoredModTime != File->getModificationTime())
+               (Info.StoredModTime &&
+                Info.StoredModTime != File->getModificationTime()))
       // Verify Size and ModTime.
       return true;
   }
@@ -851,7 +891,9 @@ bool GlobalModuleIndexBuilder::writeIndex(llvm::BitstreamWriter &Stream) {
 llvm::Error
 GlobalModuleIndex::writeIndex(FileManager &FileMgr,
                               const PCHContainerReader &PCHContainerRdr,
-                              StringRef Path) {
+                              StringRef Path,
+                       UserDefinedInterestingIDs *ExternalIDs /* = nullptr */) {
+
   llvm::SmallString<128> IndexPath;
   IndexPath += Path;
   llvm::sys::path::append(IndexPath, IndexFileName);
@@ -875,33 +917,35 @@ GlobalModuleIndex::writeIndex(FileManager &FileMgr,
   }
 
   // The module index builder.
-  GlobalModuleIndexBuilder Builder(FileMgr, PCHContainerRdr);
-
-  // Load each of the module files.
-  std::error_code EC;
-  for (llvm::sys::fs::directory_iterator D(Path, EC), DEnd;
-       D != DEnd && !EC;
-       D.increment(EC)) {
-    // If this isn't a module file, we don't care.
-    if (llvm::sys::path::extension(D->path()) != ".pcm") {
-      // ... unless it's a .pcm.lock file, which indicates that someone is
-      // in the process of rebuilding a module. They'll rebuild the index
-      // at the end of that translation unit, so we don't have to.
-      if (llvm::sys::path::extension(D->path()) == ".pcm.lock")
-        return llvm::createStringError(std::errc::device_or_resource_busy,
-                                       "someone else is building the index");
+  GlobalModuleIndexBuilder Builder(ExternalIDs);
+
+  if (!ExternalIDs) {
+    // Load each of the module files.
+    std::error_code EC;
+    for (llvm::sys::fs::directory_iterator D(Path, EC), DEnd;
+         D != DEnd && !EC;
+         D.increment(EC)) {
+      // If this isn't a module file, we don't care.
+      if (llvm::sys::path::extension(D->path()) != ".pcm") {
+        // ... unless it's a .pcm.lock file, which indicates that someone is
+        // in the process of rebuilding a module. They'll rebuild the index
+        // at the end of that translation unit, so we don't have to.
+        if (llvm::sys::path::extension(D->path()) == ".pcm.lock")
+          return llvm::createStringError(std::errc::device_or_resource_busy,
+                                         "someone else is building the index");
 
-      continue;
-    }
+        continue;
+      }
 
-    // If we can't find the module file, skip it.
-    auto ModuleFile = FileMgr.getFile(D->path());
-    if (!ModuleFile)
-      continue;
+      // If we can't find the module file, skip it.
+      auto ModuleFile = FileMgr.getFile(D->path());
+      if (!ModuleFile)
+        continue;
 
-    // Load this module file.
-    if (llvm::Error Err = Builder.loadModuleFile(*ModuleFile))
-      return Err;
+      // Load this module file.
+      if (auto Err = Builder.loadModuleFile(*ModuleFile, FileMgr, PCHContainerRdr))
+        return Err;
+    }
   }
 
   // The output buffer, into which the global index will be written.
diff --git a/lib/Serialization/ModuleManager.cpp b/lib/Serialization/ModuleManager.cpp
index 40ffa6cf..869578f3 100644
--- a/lib/Serialization/ModuleManager.cpp
+++ b/lib/Serialization/ModuleManager.cpp
@@ -232,8 +232,15 @@ ModuleManager::addModule(StringRef FileName, ModuleKind Type,
   // Read the signature eagerly now so that we can check it.  Avoid calling
   // ReadSignature unless there's something to check though.
   if (ExpectedSignature && checkSignature(ReadSignature(NewModule->Data),
-                                          ExpectedSignature, ErrorStr))
+                                          ExpectedSignature, ErrorStr)) {
+    // Try to remove the buffer.  If it can't be removed, then it was already
+    // validated by this process.
+    if (!getModuleCache().tryToDropPCM(NewModule->FileName)) {
+      const FileEntry *FE = NewModule->File;
+      FileMgr.invalidateCache(const_cast<FileEntry*>(FE));
+    }
     return OutOfDate;
+  }
 
   // We're keeping this module.  Store it everywhere.
   Module = Modules[Entry] = NewModule.get();
@@ -285,6 +292,8 @@ void ModuleManager::removeModules(ModuleIterator First, ModuleMap *modMap) {
   for (ModuleIterator victim = First; victim != Last; ++victim) {
     Modules.erase(victim->File);
 
+    const FileEntry *FE = victim->File;
+    FileMgr.invalidateCache(const_cast<FileEntry*>(FE));
     if (modMap) {
       StringRef ModuleName = victim->ModuleName;
       if (Module *mod = modMap->findModule(ModuleName)) {
diff --git a/lib/Tooling/DumpTool/ClangSrcLocDump.cpp b/lib/Tooling/DumpTool/ClangSrcLocDump.cpp
index 8091a467..a41a5c3f 100644
--- a/lib/Tooling/DumpTool/ClangSrcLocDump.cpp
+++ b/lib/Tooling/DumpTool/ClangSrcLocDump.cpp
@@ -1,159 +1,159 @@
-//===- ClangSrcLocDump.cpp ------------------------------------*- C++ -*---===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "clang/Basic/Diagnostic.h"
-#include "clang/Driver/Compilation.h"
-#include "clang/Driver/Driver.h"
-#include "clang/Driver/Job.h"
-#include "clang/Driver/Options.h"
-#include "clang/Driver/Tool.h"
-#include "clang/Frontend/CompilerInstance.h"
-#include "clang/Frontend/TextDiagnosticPrinter.h"
-#include "clang/Lex/PreprocessorOptions.h"
-#include "clang/Tooling/Tooling.h"
-#include "llvm/Option/ArgList.h"
-#include "llvm/Support/CommandLine.h"
-#include "llvm/Support/Host.h"
-#include "llvm/Support/JSON.h"
-
-#include "ASTSrcLocProcessor.h"
-
-using namespace clang::tooling;
-using namespace clang;
-using namespace llvm;
-
-static cl::list<std::string> IncludeDirectories(
-    "I", cl::desc("Include directories to use while compiling"),
-    cl::value_desc("directory"), cl::Required, cl::OneOrMore, cl::Prefix);
-
-static cl::opt<bool>
-    SkipProcessing("skip-processing",
-                   cl::desc("Avoid processing the AST header file"),
-                   cl::Required, cl::value_desc("bool"));
-
-static cl::opt<std::string> JsonOutputPath("json-output-path",
-                                           cl::desc("json output path"),
-                                           cl::Required,
-                                           cl::value_desc("path"));
-
-class ASTSrcLocGenerationAction : public clang::ASTFrontendAction {
-public:
-  ASTSrcLocGenerationAction() : Processor(JsonOutputPath) {}
-
-  void ExecuteAction() override {
-    clang::ASTFrontendAction::ExecuteAction();
-    if (getCompilerInstance().getDiagnostics().getNumErrors() > 0)
-      Processor.generateEmpty();
-    else
-      Processor.generate();
-  }
-
-  std::unique_ptr<clang::ASTConsumer>
-  CreateASTConsumer(clang::CompilerInstance &Compiler,
-                    llvm::StringRef File) override {
-    return Processor.createASTConsumer(Compiler, File);
-  }
-
-private:
-  ASTSrcLocProcessor Processor;
-};
-
-static const char Filename[] = "ASTTU.cpp";
-
-int main(int argc, const char **argv) {
-
-  cl::ParseCommandLineOptions(argc, argv);
-
-  if (SkipProcessing) {
-    std::error_code EC;
-    llvm::raw_fd_ostream JsonOut(JsonOutputPath, EC, llvm::sys::fs::OF_Text);
-    if (EC)
-      return 1;
-    JsonOut << formatv("{0:2}", llvm::json::Value(llvm::json::Object()));
-    return 0;
-  }
-
-  std::vector<std::string> Args;
-  Args.push_back("-cc1");
-
-  llvm::transform(IncludeDirectories, std::back_inserter(Args),
-                  [](const std::string &IncDir) { return "-I" + IncDir; });
-
-  Args.push_back("-fsyntax-only");
-  Args.push_back(Filename);
-
-  std::vector<const char *> Argv(Args.size(), nullptr);
-  llvm::transform(Args, Argv.begin(),
-                  [](const std::string &Arg) { return Arg.c_str(); });
-
-  IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts = new DiagnosticOptions();
-  unsigned MissingArgIndex, MissingArgCount;
-  auto Opts = driver::getDriverOptTable();
-  auto ParsedArgs = Opts.ParseArgs(llvm::makeArrayRef(Argv).slice(1),
-                                   MissingArgIndex, MissingArgCount);
-  ParseDiagnosticArgs(*DiagOpts, ParsedArgs);
-
-  // Don't output diagnostics, because common scenarios such as
-  // cross-compiling fail with diagnostics.  This is not fatal, but
-  // just causes attempts to use the introspection API to return no data.
-  TextDiagnosticPrinter DiagnosticPrinter(llvm::nulls(), &*DiagOpts);
-  DiagnosticsEngine Diagnostics(
-      IntrusiveRefCntPtr<DiagnosticIDs>(new DiagnosticIDs()), &*DiagOpts,
-      &DiagnosticPrinter, false);
-
-  auto *OFS = new llvm::vfs::OverlayFileSystem(vfs::getRealFileSystem());
-
-  auto *MemFS = new llvm::vfs::InMemoryFileSystem();
-  OFS->pushOverlay(MemFS);
-  MemFS->addFile(Filename, 0,
-                 MemoryBuffer::getMemBuffer("#include \"clang/AST/AST.h\"\n"));
-
-  auto Files = llvm::makeIntrusiveRefCnt<FileManager>(FileSystemOptions(), OFS);
-
-  auto Driver = std::make_unique<driver::Driver>(
-      "clang", llvm::sys::getDefaultTargetTriple(), Diagnostics,
-      "ast-api-dump-tool", OFS);
-
-  std::unique_ptr<clang::driver::Compilation> Comp(
-      Driver->BuildCompilation(llvm::makeArrayRef(Argv)));
-  if (!Comp)
-    return 1;
-
-  const auto &Jobs = Comp->getJobs();
-  if (Jobs.size() != 1 || !isa<driver::Command>(*Jobs.begin())) {
-    SmallString<256> error_msg;
-    llvm::raw_svector_ostream error_stream(error_msg);
-    Jobs.Print(error_stream, "; ", true);
-    return 1;
-  }
-
-  const auto &Cmd = cast<driver::Command>(*Jobs.begin());
-  const llvm::opt::ArgStringList &CC1Args = Cmd.getArguments();
-
-  auto Invocation = std::make_unique<CompilerInvocation>();
-  CompilerInvocation::CreateFromArgs(*Invocation, CC1Args, Diagnostics);
-
-  CompilerInstance Compiler(std::make_shared<clang::PCHContainerOperations>());
-  Compiler.setInvocation(std::move(Invocation));
-
-  Compiler.createDiagnostics(&DiagnosticPrinter, false);
-  if (!Compiler.hasDiagnostics())
-    return 1;
-
-  // Suppress "2 errors generated" or similar messages
-  Compiler.getDiagnosticOpts().ShowCarets = false;
-  Compiler.createSourceManager(*Files);
-  Compiler.setFileManager(Files.get());
-
-  ASTSrcLocGenerationAction ScopedToolAction;
-  Compiler.ExecuteAction(ScopedToolAction);
-
-  Files->clearStatCache();
-
-  return 0;
-}
+//===- ClangSrcLocDump.cpp ------------------------------------*- C++ -*---===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Basic/Diagnostic.h"
+#include "clang/Driver/Compilation.h"
+#include "clang/Driver/Driver.h"
+#include "clang/Driver/Job.h"
+#include "clang/Driver/Options.h"
+#include "clang/Driver/Tool.h"
+#include "clang/Frontend/CompilerInstance.h"
+#include "clang/Frontend/TextDiagnosticPrinter.h"
+#include "clang/Lex/PreprocessorOptions.h"
+#include "clang/Tooling/Tooling.h"
+#include "llvm/Option/ArgList.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Host.h"
+#include "llvm/Support/JSON.h"
+
+#include "ASTSrcLocProcessor.h"
+
+using namespace clang::tooling;
+using namespace clang;
+using namespace llvm;
+
+static cl::list<std::string> IncludeDirectories(
+    "I", cl::desc("Include directories to use while compiling"),
+    cl::value_desc("directory"), cl::Required, cl::OneOrMore, cl::Prefix);
+
+static cl::opt<bool>
+    SkipProcessing("skip-processing",
+                   cl::desc("Avoid processing the AST header file"),
+                   cl::Required, cl::value_desc("bool"));
+
+static cl::opt<std::string> JsonOutputPath("json-output-path",
+                                           cl::desc("json output path"),
+                                           cl::Required,
+                                           cl::value_desc("path"));
+
+class ASTSrcLocGenerationAction : public clang::ASTFrontendAction {
+public:
+  ASTSrcLocGenerationAction() : Processor(JsonOutputPath) {}
+
+  void ExecuteAction() override {
+    clang::ASTFrontendAction::ExecuteAction();
+    if (getCompilerInstance().getDiagnostics().getNumErrors() > 0)
+      Processor.generateEmpty();
+    else
+      Processor.generate();
+  }
+
+  std::unique_ptr<clang::ASTConsumer>
+  CreateASTConsumer(clang::CompilerInstance &Compiler,
+                    llvm::StringRef File) override {
+    return Processor.createASTConsumer(Compiler, File);
+  }
+
+private:
+  ASTSrcLocProcessor Processor;
+};
+
+static const char Filename[] = "ASTTU.cpp";
+
+int main(int argc, const char **argv) {
+
+  cl::ParseCommandLineOptions(argc, argv);
+
+  if (SkipProcessing) {
+    std::error_code EC;
+    llvm::raw_fd_ostream JsonOut(JsonOutputPath, EC, llvm::sys::fs::OF_Text);
+    if (EC)
+      return 1;
+    JsonOut << formatv("{0:2}", llvm::json::Value(llvm::json::Object()));
+    return 0;
+  }
+
+  std::vector<std::string> Args;
+  Args.push_back("-cc1");
+
+  llvm::transform(IncludeDirectories, std::back_inserter(Args),
+                  [](const std::string &IncDir) { return "-I" + IncDir; });
+
+  Args.push_back("-fsyntax-only");
+  Args.push_back(Filename);
+
+  std::vector<const char *> Argv(Args.size(), nullptr);
+  llvm::transform(Args, Argv.begin(),
+                  [](const std::string &Arg) { return Arg.c_str(); });
+
+  IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts = new DiagnosticOptions();
+  unsigned MissingArgIndex, MissingArgCount;
+  auto Opts = driver::getDriverOptTable();
+  auto ParsedArgs = Opts.ParseArgs(llvm::makeArrayRef(Argv).slice(1),
+                                   MissingArgIndex, MissingArgCount);
+  ParseDiagnosticArgs(*DiagOpts, ParsedArgs);
+
+  // Don't output diagnostics, because common scenarios such as
+  // cross-compiling fail with diagnostics.  This is not fatal, but
+  // just causes attempts to use the introspection API to return no data.
+  TextDiagnosticPrinter DiagnosticPrinter(llvm::nulls(), &*DiagOpts);
+  DiagnosticsEngine Diagnostics(
+      IntrusiveRefCntPtr<DiagnosticIDs>(new DiagnosticIDs()), &*DiagOpts,
+      &DiagnosticPrinter, false);
+
+  auto *OFS = new llvm::vfs::OverlayFileSystem(vfs::getRealFileSystem());
+
+  auto *MemFS = new llvm::vfs::InMemoryFileSystem();
+  OFS->pushOverlay(MemFS);
+  MemFS->addFile(Filename, 0,
+                 MemoryBuffer::getMemBuffer("#include \"clang/AST/AST.h\"\n"));
+
+  auto Files = llvm::makeIntrusiveRefCnt<FileManager>(FileSystemOptions(), OFS);
+
+  auto Driver = std::make_unique<driver::Driver>(
+      "clang", llvm::sys::getDefaultTargetTriple(), Diagnostics,
+      "ast-api-dump-tool", OFS);
+
+  std::unique_ptr<clang::driver::Compilation> Comp(
+      Driver->BuildCompilation(llvm::makeArrayRef(Argv)));
+  if (!Comp)
+    return 1;
+
+  const auto &Jobs = Comp->getJobs();
+  if (Jobs.size() != 1 || !isa<driver::Command>(*Jobs.begin())) {
+    SmallString<256> error_msg;
+    llvm::raw_svector_ostream error_stream(error_msg);
+    Jobs.Print(error_stream, "; ", true);
+    return 1;
+  }
+
+  const auto &Cmd = cast<driver::Command>(*Jobs.begin());
+  const llvm::opt::ArgStringList &CC1Args = Cmd.getArguments();
+
+  auto Invocation = std::make_unique<CompilerInvocation>();
+  CompilerInvocation::CreateFromArgs(*Invocation, CC1Args, Diagnostics);
+
+  CompilerInstance Compiler(std::make_shared<clang::PCHContainerOperations>());
+  Compiler.setInvocation(std::move(Invocation));
+
+  Compiler.createDiagnostics(&DiagnosticPrinter, false);
+  if (!Compiler.hasDiagnostics())
+    return 1;
+
+  // Suppress "2 errors generated" or similar messages
+  Compiler.getDiagnosticOpts().ShowCarets = false;
+  Compiler.createSourceManager(*Files);
+  Compiler.setFileManager(Files.get());
+
+  ASTSrcLocGenerationAction ScopedToolAction;
+  Compiler.ExecuteAction(ScopedToolAction);
+
+  Files->clearStatCache();
+
+  return 0;
+}
-- 
2.33.1

