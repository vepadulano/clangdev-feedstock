From f2fc67287925b10287188107a05415da657a7732 Mon Sep 17 00:00:00 2001
From: Chris Burr <christopher.burr@cern.ch>
Date: Tue, 13 Dec 2022 13:54:42 +0100
Subject: [PATCH 4/4] ROOT: libs 3

---
 lib/Basic/Diagnostic.cpp                   |  28 +-
 lib/Basic/FileManager.cpp                  |  45 ++-
 lib/Basic/SourceManager.cpp                |  33 ++-
 lib/Basic/Targets/OSTargets.h              |   4 +-
 lib/Basic/Targets/PPC.cpp                  |   5 +-
 lib/Basic/Targets/Sparc.h                  |   3 +
 lib/CodeGen/CGCUDANV.cpp                   |   4 +-
 lib/CodeGen/CGDeclCXX.cpp                  |  12 +-
 lib/CodeGen/CGExprCXX.cpp                  |   5 +-
 lib/CodeGen/CodeGenModule.cpp              |  31 +-
 lib/CodeGen/CodeGenModule.h                |  26 +-
 lib/CodeGen/ModuleBuilder.cpp              | 204 ++++++++++++-
 lib/Driver/ToolChains/Arch/AArch64.cpp     |  15 +-
 lib/Format/TokenAnnotator.cpp              |  42 +--
 lib/Format/UnwrappedLineParser.cpp         |   5 +-
 lib/Format/WhitespaceManager.cpp           |  16 +-
 lib/Frontend/CompilerInvocation.cpp        |   7 +-
 lib/Frontend/VerifyDiagnosticConsumer.cpp  |   5 +
 lib/Headers/__clang_cuda_runtime_wrapper.h |   6 +-
 lib/Lex/HeaderSearch.cpp                   |  36 ++-
 lib/Lex/Lexer.cpp                          |   4 +
 lib/Lex/PPDirectives.cpp                   |   7 +-
 lib/Lex/PPMacroExpansion.cpp               |  14 +
 lib/Lex/Preprocessor.cpp                   |  37 +++
 lib/Parse/ParsePragma.cpp                  |   8 +
 lib/Parse/Parser.cpp                       |  23 +-
 lib/Tooling/DumpTool/ClangSrcLocDump.cpp   | 318 ++++++++++-----------
 27 files changed, 666 insertions(+), 277 deletions(-)

diff --git a/lib/Basic/Diagnostic.cpp b/lib/Basic/Diagnostic.cpp
index d3b2122e..2152e5bb 100644
--- a/lib/Basic/Diagnostic.cpp
+++ b/lib/Basic/Diagnostic.cpp
@@ -130,7 +130,7 @@ bool DiagnosticsEngine::popMappings(SourceLocation Loc) {
   return true;
 }
 
-void DiagnosticsEngine::Reset() {
+void DiagnosticsEngine::Reset(bool soft /*=false*/) {
   ErrorOccurred = false;
   UncompilableErrorOccurred = false;
   FatalErrorOccurred = false;
@@ -145,6 +145,7 @@ void DiagnosticsEngine::Reset() {
   LastDiagLevel = DiagnosticIDs::Ignored;
   DelayedDiagID = 0;
 
+  if (!soft) {
   // Clear state related to #pragma diagnostic.
   DiagStates.clear();
   DiagStatesByLoc.clear();
@@ -154,6 +155,7 @@ void DiagnosticsEngine::Reset() {
   // through command-line.
   DiagStates.emplace_back();
   DiagStatesByLoc.appendFirst(&DiagStates.back());
+  }
 }
 
 void DiagnosticsEngine::SetDelayedDiagnostic(unsigned DiagID, StringRef Arg1,
@@ -191,7 +193,29 @@ void DiagnosticsEngine::DiagStateMap::append(SourceManager &SrcMgr,
        Offset = F->ParentOffset, F = F->Parent) {
     F->HasLocalTransitions = true;
     auto &Last = F->StateTransitions.back();
-    assert(Last.Offset <= Offset && "state transitions added out of order");
+    if (Last.Offset > Offset) {
+      // Deal with a state change induce by recursive parsing.  The first parsing is
+      // suspended and a (recursive) parsing is started between associated (in the upper/outer
+      // file) with a newer line (hence greater offset).  After the end of the recursive
+      // parsing, we go back to the first parsing and any state change will done 'earlier'
+      // and trigger:
+      //   assert(Last.Offset <= Offset && "state transitions added out of order");
+      auto OnePastIt = std::upper_bound(
+        F->StateTransitions.begin(), F->StateTransitions.end(), Offset,
+        [](unsigned Offset, const DiagStatePoint &P) {
+          return Offset < P.Offset;
+        });
+      if (OnePastIt == F->StateTransitions.begin() || (OnePastIt[-1].Offset != Offset)) {
+        F->StateTransitions.insert( OnePastIt, {State, Offset});
+      } else {
+        auto &Prev = OnePastIt[-1];
+        if (Prev.State == State)
+          break;
+        Prev.State = State;
+        continue;
+      }
+      continue;
+    }
 
     if (Last.Offset == Offset) {
       if (Last.State == State)
diff --git a/lib/Basic/FileManager.cpp b/lib/Basic/FileManager.cpp
index 74cd2f29..ef36e51d 100644
--- a/lib/Basic/FileManager.cpp
+++ b/lib/Basic/FileManager.cpp
@@ -207,7 +207,25 @@ FileManager::getFileRef(StringRef Filename, bool openFile, bool CacheFailure) {
   // See if there is already an entry in the map.
   auto SeenFileInsertResult =
       SeenFileEntries.insert({Filename, std::errc::no_such_file_or_directory});
-  if (!SeenFileInsertResult.second) {
+
+  auto *NamedFileEnt = &*SeenFileInsertResult.first;
+
+  const FileEntry *StaleFileEntry = 0;
+  bool needsRereading = false;
+  if (NamedFileEnt && NamedFileEnt->getValue()) {
+    FileEntryRef::MapValue Value = *NamedFileEnt->getValue();
+    if (Value.V.is<FileEntry *>()) {
+      auto found = FileEntriesToReread.find(Value.V.get<FileEntry*>());
+      if (found != FileEntriesToReread.end()) {
+        needsRereading = true;
+        StaleFileEntry = *found;
+        FileEntriesToReread.erase(found);
+      }
+    }
+  }
+
+  // See if there is already an entry in the map.
+  if (!SeenFileInsertResult.second && !needsRereading) {
     if (!SeenFileInsertResult.first->second)
       return llvm::errorCodeToError(
           SeenFileInsertResult.first->second.getError());
@@ -222,8 +240,6 @@ FileManager::getFileRef(StringRef Filename, bool openFile, bool CacheFailure) {
 
   // We've not seen this before. Fill it in.
   ++NumFileCacheMisses;
-  auto *NamedFileEnt = &*SeenFileInsertResult.first;
-  assert(!NamedFileEnt->second && "should be newly-created");
 
   // Get the null-terminated file name as stored as the key of the
   // SeenFileEntries map.
@@ -304,6 +320,9 @@ FileManager::getFileRef(StringRef Filename, bool openFile, bool CacheFailure) {
     // multiple names.
     if (&DirInfo.getDirEntry() != UFE.Dir && Status.IsVFSMapped)
       UFE.Dir = &DirInfo.getDirEntry();
+  }
+  if (UFE.isValid() &&
+      llvm::sys::toTimeT(Status.getLastModificationTime()) == UFE.ModTime) {
 
     // Always update LastRef to the last name by which a file was accessed.
     // FIXME: Neither this nor always using the first reference is correct; we
@@ -335,6 +354,20 @@ FileManager::getFileRef(StringRef Filename, bool openFile, bool CacheFailure) {
     // We should still fill the path even if we aren't opening the file.
     fillRealPathName(&UFE, InterndFileName);
   }
+
+  if (StaleFileEntry) {
+    // Find occurrences of old FileEntry; update with new one:
+    for (auto& fe: SeenFileEntries) {
+      if (fe.getValue()) {
+        FileEntryRef::MapValue Value = *fe.getValue();
+        if (Value.V.is<FileEntry *>()
+            && Value.V.get<FileEntry*>() == StaleFileEntry) {
+          fe.setValue(FileEntryRef::MapValue(UFE, DirInfo));
+        }
+      }
+    }
+  }
+
   return ReturnedRef;
 }
 
@@ -580,6 +613,12 @@ FileManager::getNoncachedStatValue(StringRef Path,
   return std::error_code();
 }
 
+void FileManager::invalidateCache(FileEntry *Entry) {
+  assert(Entry && "Cannot invalidate a NULL FileEntry");
+  FileEntriesToReread.insert(Entry->getLastRef());
+  Entry->IsValid = false;
+}
+
 void FileManager::GetUniqueIDMapping(
                    SmallVectorImpl<const FileEntry *> &UIDToFiles) const {
   UIDToFiles.clear();
diff --git a/lib/Basic/SourceManager.cpp b/lib/Basic/SourceManager.cpp
index 8cba379a..42abc296 100644
--- a/lib/Basic/SourceManager.cpp
+++ b/lib/Basic/SourceManager.cpp
@@ -358,6 +358,25 @@ bool SourceManager::isMainFile(const FileEntry &SourceFile) {
   return false;
 }
 
+void SourceManager::invalidateCache(FileID FID) {
+  const FileEntry* Entry = getFileEntryForID(FID);
+  if (!Entry)
+    return;
+  if (ContentCache *&E = FileInfos[Entry]) {
+    E->setBuffer(nullptr);
+    E = 0;
+  }
+  if (!FID.isInvalid()) {
+    const SrcMgr::SLocEntry& SLocE = getSLocEntry(FID);
+    if (SLocE.isFile()) {
+      SrcMgr::ContentCache& CC =
+        const_cast<SrcMgr::ContentCache&>(SLocE.getFile().getContentCache());
+      CC.setBuffer(nullptr);
+    }
+  }
+  getFileManager().invalidateCache(const_cast<FileEntry*>(Entry));
+}
+
 void SourceManager::initializeForReplay(const SourceManager &Old) {
   assert(MainFileID.isInvalid() && "expected uninitialized SourceManager");
 
@@ -1505,6 +1524,15 @@ StringRef SourceManager::getBufferName(SourceLocation Loc,
   auto B = getBufferOrNone(getFileID(Loc));
   if (Invalid)
     *Invalid = !B;
+
+  // Try to get the name without reading the buffer.
+  FileID FID = getFileID(Loc);
+  const SrcMgr::SLocEntry &Entry = getSLocEntry(FID, Invalid);
+  if (!Invalid && Entry.isFile()) {
+    if (const FileEntry* FE = Entry.getFile().getContentCache().ContentsEntry)
+      return FE->getName();
+  }
+
   return B ? B->getBufferIdentifier() : "<invalid buffer>";
 }
 
@@ -2067,7 +2095,10 @@ bool SourceManager::isBeforeInTranslationUnit(SourceLocation LHS,
       return LIsScratch;
     return LOffs.second < ROffs.second;
   }
-  llvm_unreachable("Unsortable locations found");
+  //AXEL: Work around diags from include chains not rooted in main file.
+  //AXEL: llvm_unreachable("Unsortable locations found");
+  assert(0 && "Unsortable locations found");
+  return LOffs.first < ROffs.first;
 }
 
 std::pair<bool, bool> SourceManager::isInTheSameTranslationUnit(
diff --git a/lib/Basic/Targets/OSTargets.h b/lib/Basic/Targets/OSTargets.h
index 12df95c1..3fe39ed6 100644
--- a/lib/Basic/Targets/OSTargets.h
+++ b/lib/Basic/Targets/OSTargets.h
@@ -461,8 +461,10 @@ protected:
     if (this->HasFloat128)
       Builder.defineMacro("__FLOAT128__");
 
-    if (Opts.C11)
+    if (Opts.C11) {
+      Builder.defineMacro("__STDC_NO_ATOMICS__");
       Builder.defineMacro("__STDC_NO_THREADS__");
+    }
   }
 
 public:
diff --git a/lib/Basic/Targets/PPC.cpp b/lib/Basic/Targets/PPC.cpp
index ecfbe284..59656888 100644
--- a/lib/Basic/Targets/PPC.cpp
+++ b/lib/Basic/Targets/PPC.cpp
@@ -243,10 +243,7 @@ static void defineXLCompatMacros(MacroBuilder &Builder) {
 void PPCTargetInfo::getTargetDefines(const LangOptions &Opts,
                                      MacroBuilder &Builder) const {
 
-  // We define the XLC compatibility macros only on AIX and Linux since XLC
-  // was never available on any other platforms.
-  if (getTriple().isOSAIX() || getTriple().isOSLinux())
-    defineXLCompatMacros(Builder);
+  defineXLCompatMacros(Builder);
 
   // Target identification.
   Builder.defineMacro("__ppc__");
diff --git a/lib/Basic/Targets/Sparc.h b/lib/Basic/Targets/Sparc.h
index e9f8c10d..07844aba 100644
--- a/lib/Basic/Targets/Sparc.h
+++ b/lib/Basic/Targets/Sparc.h
@@ -50,6 +50,8 @@ public:
 
   bool hasFeature(StringRef Feature) const override;
 
+  bool hasSjLjLowering() const override { return true; }
+
   ArrayRef<Builtin::Info> getTargetBuiltins() const override {
     // FIXME: Implement!
     return None;
@@ -178,6 +180,7 @@ public:
   void getTargetDefines(const LangOptions &Opts,
                         MacroBuilder &Builder) const override;
 
+  bool hasSjLjLowering() const override { return true; }
   bool hasExtIntType() const override { return true; }
 };
 
diff --git a/lib/CodeGen/CGCUDANV.cpp b/lib/CodeGen/CGCUDANV.cpp
index 88030fee..5905d57e 100644
--- a/lib/CodeGen/CGCUDANV.cpp
+++ b/lib/CodeGen/CGCUDANV.cpp
@@ -711,7 +711,7 @@ llvm::Function *CGNVCUDARuntime::makeModuleCtorFunction() {
   }
 
   llvm::Function *ModuleCtorFunc = llvm::Function::Create(
-      llvm::FunctionType::get(VoidTy, VoidPtrTy, false),
+      llvm::FunctionType::get(VoidTy, false),
       llvm::GlobalValue::InternalLinkage,
       addUnderscoredPrefixToName("_module_ctor"), &TheModule);
   llvm::BasicBlock *CtorEntryBB =
@@ -947,7 +947,7 @@ llvm::Function *CGNVCUDARuntime::makeModuleDtorFunction() {
       addUnderscoredPrefixToName("UnregisterFatBinary"));
 
   llvm::Function *ModuleDtorFunc = llvm::Function::Create(
-      llvm::FunctionType::get(VoidTy, VoidPtrTy, false),
+      llvm::FunctionType::get(VoidTy, false),
       llvm::GlobalValue::InternalLinkage,
       addUnderscoredPrefixToName("_module_dtor"), &TheModule);
 
diff --git a/lib/CodeGen/CGDeclCXX.cpp b/lib/CodeGen/CGDeclCXX.cpp
index 553fedeb..f6f4e380 100644
--- a/lib/CodeGen/CGDeclCXX.cpp
+++ b/lib/CodeGen/CGDeclCXX.cpp
@@ -531,9 +531,19 @@ CodeGenModule::EmitCXXGlobalVarDeclInitFunc(const VarDecl *D,
     getCXXABI().getMangleContext().mangleDynamicInitializer(D, Out);
   }
 
+  // Use the module name to make the initializer unique accross modules.
+  SmallString<128> moduleName(TheModule.getName());
+  for (size_t i = 0; i < moduleName.size(); ++i) {
+    // Replace everything that's not [a-zA-Z0-9._] with a _. This set happens
+    // to be the set of C preprocessing numbers.
+    if (!isPreprocessingNumberBody(moduleName[i]))
+      moduleName[i] = '_';
+  }
+
   // Create a variable initialization function.
   llvm::Function *Fn = CreateGlobalInitOrCleanUpFunction(
-      FTy, FnName.str(), getTypes().arrangeNullaryFunction(), D->getLocation());
+      FTy, llvm::Twine(FnName)+moduleName.str() + "_",
+      getTypes().arrangeNullaryFunction(), D->getLocation());
 
   auto *ISA = D->getAttr<InitSegAttr>();
   CodeGenFunction(*this).GenerateCXXGlobalVarDeclInitFunc(Fn, D, Addr,
diff --git a/lib/CodeGen/CGExprCXX.cpp b/lib/CodeGen/CGExprCXX.cpp
index f42759e9..dbbf9b79 100644
--- a/lib/CodeGen/CGExprCXX.cpp
+++ b/lib/CodeGen/CGExprCXX.cpp
@@ -97,8 +97,9 @@ RValue CodeGenFunction::EmitCXXDestructorCall(
   const CXXMethodDecl *DtorDecl = cast<CXXMethodDecl>(Dtor.getDecl());
 
   assert(!ThisTy.isNull());
-  assert(ThisTy->getAsCXXRecordDecl() == DtorDecl->getParent() &&
-         "Pointer/Object mixup");
+  assert(
+      declaresSameEntity(ThisTy->getAsCXXRecordDecl(), DtorDecl->getParent()) &&
+      "Pointer/Object mixup");
 
   LangAS SrcAS = ThisTy.getAddressSpace();
   LangAS DstAS = DtorDecl->getMethodQualifiers().getAddressSpace();
diff --git a/lib/CodeGen/CodeGenModule.cpp b/lib/CodeGen/CodeGenModule.cpp
index 49a1396b..35503322 100644
--- a/lib/CodeGen/CodeGenModule.cpp
+++ b/lib/CodeGen/CodeGenModule.cpp
@@ -410,6 +410,7 @@ void CodeGenModule::checkAliases() {
 
 void CodeGenModule::clear() {
   DeferredDeclsToEmit.clear();
+  EmittedDeferredDecls.clear();
   if (OpenMPRuntime)
     OpenMPRuntime->clear();
 }
@@ -475,6 +476,9 @@ static void setVisibilityFromDLLStorageClass(const clang::LangOptions &LO,
 
 void CodeGenModule::Release() {
   EmitDeferred();
+  DeferredDecls.insert(EmittedDeferredDecls.begin(),
+                       EmittedDeferredDecls.end());
+  EmittedDeferredDecls.clear();
   EmitVTablesOpportunistically();
   applyGlobalValReplacements();
   applyReplacements();
@@ -1456,6 +1460,7 @@ void CodeGenModule::EmitCtorList(CtorList &Fns, const char *GlobalName) {
   // Construct the constructor and destructor arrays.
   ConstantInitBuilder builder(*this);
   auto ctors = builder.beginArray(CtorStructTy);
+
   for (const auto &I : Fns) {
     auto ctor = ctors.beginStruct(CtorStructTy);
     ctor.addInt(Int32Ty, I.Priority);
@@ -2239,7 +2244,9 @@ static void emitUsed(CodeGenModule &CGM, StringRef Name,
 
 void CodeGenModule::emitLLVMUsed() {
   emitUsed(*this, "llvm.used", LLVMUsed);
+  LLVMUsed.clear();
   emitUsed(*this, "llvm.compiler.used", LLVMCompilerUsed);
+  LLVMCompilerUsed.clear();
 }
 
 void CodeGenModule::AppendLinkerOptions(StringRef Opts) {
@@ -2411,7 +2418,7 @@ void CodeGenModule::EmitDeferred() {
   // needed for further handling.
   if (getLangOpts().CUDA && getLangOpts().CUDAIsDevice)
     for (const auto *V : getContext().CUDADeviceVarODRUsedByHost)
-      DeferredDeclsToEmit.push_back(V);
+      addDeferredDeclToEmit(V, "");
 
   // Stop if we're out of both deferred vtables and deferred declarations.
   if (DeferredDeclsToEmit.empty())
@@ -2514,18 +2521,21 @@ llvm::Constant *CodeGenModule::EmitAnnotationString(StringRef Str) {
 
 llvm::Constant *CodeGenModule::EmitAnnotationUnit(SourceLocation Loc) {
   SourceManager &SM = getContext().getSourceManager();
-  PresumedLoc PLoc = SM.getPresumedLoc(Loc);
-  if (PLoc.isValid())
-    return EmitAnnotationString(PLoc.getFilename());
+  //PresumedLoc PLoc = SM.getPresumedLoc(Loc);
+  //if (PLoc.isValid())
+  //  return EmitAnnotationString(PLoc.getFilename());
   return EmitAnnotationString(SM.getBufferName(Loc));
 }
 
 llvm::Constant *CodeGenModule::EmitAnnotationLineNo(SourceLocation L) {
+  return llvm::ConstantInt::get(Int32Ty, 1);
+#if 0
   SourceManager &SM = getContext().getSourceManager();
   PresumedLoc PLoc = SM.getPresumedLoc(L);
   unsigned LineNo = PLoc.isValid() ? PLoc.getLine() :
     SM.getExpansionLineNumber(L);
   return llvm::ConstantInt::get(Int32Ty, LineNo);
+#endif
 }
 
 llvm::Constant *CodeGenModule::EmitAnnotationArgs(const AnnotateAttr *Attr) {
@@ -2980,6 +2990,7 @@ void CodeGenModule::EmitGlobal(GlobalDecl GD) {
   if (MustBeEmitted(Global) && MayBeEmittedEagerly(Global)) {
     // Emit the definition if it can't be deferred.
     EmitGlobalDefinition(GD);
+    addEmittedDeferredDecl(GD, StringRef());
     return;
   }
 
@@ -2994,11 +3005,11 @@ void CodeGenModule::EmitGlobal(GlobalDecl GD) {
   StringRef MangledName = getMangledName(GD);
   if (GetGlobalValue(MangledName) != nullptr) {
     // The value has already been used and should therefore be emitted.
-    addDeferredDeclToEmit(GD);
+    addDeferredDeclToEmit(GD, MangledName);
   } else if (MustBeEmitted(Global)) {
     // The value must be emitted, but cannot be emitted eagerly.
     assert(!MayBeEmittedEagerly(Global));
-    addDeferredDeclToEmit(GD);
+    addDeferredDeclToEmit(GD, MangledName);
   } else {
     // Otherwise, remember that we saw a deferred decl with this name.  The
     // first use of the mangled name will cause it to move into
@@ -3625,7 +3636,7 @@ llvm::Constant *CodeGenModule::GetOrCreateLLVMFunction(
     if (D && isa<CXXDestructorDecl>(D) &&
         getCXXABI().useThunkForDtorVariant(cast<CXXDestructorDecl>(D),
                                            GD.getDtorType()))
-      addDeferredDeclToEmit(GD);
+      addDeferredDeclToEmit(GD, MangledName);
 
     // This is the first use or definition of a mangled name.  If there is a
     // deferred decl with this name, remember that we need to emit it at the end
@@ -3635,7 +3646,7 @@ llvm::Constant *CodeGenModule::GetOrCreateLLVMFunction(
       // Move the potentially referenced deferred decl to the
       // DeferredDeclsToEmit list, and remove it from DeferredDecls (since we
       // don't need it anymore).
-      addDeferredDeclToEmit(DDI->second);
+      addDeferredDeclToEmit(DDI->second, MangledName);
       DeferredDecls.erase(DDI);
 
       // Otherwise, there are cases we have to worry about where we're
@@ -3655,7 +3666,7 @@ llvm::Constant *CodeGenModule::GetOrCreateLLVMFunction(
            FD = FD->getPreviousDecl()) {
         if (isa<CXXRecordDecl>(FD->getLexicalDeclContext())) {
           if (FD->doesThisDeclarationHaveABody()) {
-            addDeferredDeclToEmit(GD.getWithDecl(FD));
+            addDeferredDeclToEmit(GD.getWithDecl(FD), MangledName);
             break;
           }
         }
@@ -3908,7 +3919,7 @@ CodeGenModule::GetOrCreateLLVMGlobal(StringRef MangledName, llvm::Type *Ty,
   if (DDI != DeferredDecls.end()) {
     // Move the potentially referenced deferred decl to the DeferredDeclsToEmit
     // list, and remove it from DeferredDecls (since we don't need it anymore).
-    addDeferredDeclToEmit(DDI->second);
+    addDeferredDeclToEmit(DDI->second, MangledName);
     DeferredDecls.erase(DDI);
   }
 
diff --git a/lib/CodeGen/CodeGenModule.h b/lib/CodeGen/CodeGenModule.h
index 47dc6f41..6395c81a 100644
--- a/lib/CodeGen/CodeGenModule.h
+++ b/lib/CodeGen/CodeGenModule.h
@@ -37,6 +37,8 @@
 #include "llvm/IR/ValueHandle.h"
 #include "llvm/Transforms/Utils/SanitizerStats.h"
 
+#include <unordered_map>
+
 namespace llvm {
 class Module;
 class Constant;
@@ -53,6 +55,7 @@ class IndexedInstrProfReader;
 namespace clang {
 class ASTContext;
 class AtomicType;
+class CodeGeneratorImpl; // hack needed by cling
 class FunctionDecl;
 class IdentifierInfo;
 class ObjCMethodDecl;
@@ -347,11 +350,31 @@ private:
   /// yet.
   std::map<StringRef, GlobalDecl> DeferredDecls;
 
+  /// Decls that were DeferredDecls and have now been emitted.
+  std::map<StringRef, GlobalDecl> EmittedDeferredDecls;
+  void addEmittedDeferredDecl(GlobalDecl GD, StringRef MangledName) {
+    bool IsAFunction = isa<FunctionDecl>(GD.getDecl());
+    const VarDecl* VD = IsAFunction ? nullptr : dyn_cast<VarDecl>(GD.getDecl());
+    assert((IsAFunction || VD) && "Unexpected Decl type!");
+    bool ExcludeCtor = false; // FIXME: this is too simple!
+    llvm::GlobalValue::LinkageTypes L
+      = IsAFunction ? getFunctionLinkage(GD) :
+      getLLVMLinkageVarDefinition(VD, isTypeConstant(VD->getType(),
+                                                     ExcludeCtor));
+    if (llvm::GlobalValue::isWeakForLinker(L)
+        || llvm::GlobalValue::isInternalLinkage(L)) {
+      if (MangledName.empty())
+        MangledName = getMangledName(GD);
+      EmittedDeferredDecls[MangledName] = GD;
+    }
+  }
+
   /// This is a list of deferred decls which we have seen that *are* actually
   /// referenced. These get code generated when the module is done.
   std::vector<GlobalDecl> DeferredDeclsToEmit;
-  void addDeferredDeclToEmit(GlobalDecl GD) {
+  void addDeferredDeclToEmit(GlobalDecl GD, StringRef MangledName) {
     DeferredDeclsToEmit.emplace_back(GD);
+    addEmittedDeferredDecl(GD, MangledName);
   }
 
   /// List of alias we have emitted. Used to make sure that what they point to
@@ -1626,6 +1649,7 @@ private:
 
   llvm::Metadata *CreateMetadataIdentifierImpl(QualType T, MetadataTypeMap &Map,
                                                StringRef Suffix);
+  friend class clang::CodeGeneratorImpl; // hack needed by cling
 };
 
 }  // end namespace CodeGen
diff --git a/lib/CodeGen/ModuleBuilder.cpp b/lib/CodeGen/ModuleBuilder.cpp
index b63f756c..5c1bbf79 100644
--- a/lib/CodeGen/ModuleBuilder.cpp
+++ b/lib/CodeGen/ModuleBuilder.cpp
@@ -12,6 +12,7 @@
 
 #include "clang/CodeGen/ModuleBuilder.h"
 #include "CGDebugInfo.h"
+#include "CGCXXABI.h"
 #include "CodeGenModule.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/DeclObjC.h"
@@ -29,12 +30,20 @@ using namespace clang;
 using namespace CodeGen;
 
 namespace {
+  struct CXXABICtxSwapper: clang::CodeGen::CGCXXABI {
+    void SwapCtx(clang::CodeGen::CGCXXABI &other) {
+      std::swap(MangleCtx, ((CXXABICtxSwapper&)other).MangleCtx);
+    }
+  };
+}
+
+namespace clang {
   class CodeGeneratorImpl : public CodeGenerator {
     DiagnosticsEngine &Diags;
     ASTContext *Ctx;
     const HeaderSearchOptions &HeaderSearchOpts; // Only used for debug info.
     const PreprocessorOptions &PreprocessorOpts; // Only used for debug info.
-    const CodeGenOptions CodeGenOpts;  // Intentionally copied in.
+    CodeGenOptions CodeGenOpts;  // Intentionally copied in.
 
     unsigned HandlingTopLevelDecls;
 
@@ -104,6 +113,11 @@ namespace {
     }
 
     llvm::Module *ReleaseModule() {
+      // Remove pending etc decls in case of error; the asserts in StartModule()
+      // will rightfully be confused otherwise, as none of the decls were
+      // emitted.
+      if (Diags.hasErrorOccurred())
+        Builder->clear();
       return M.release();
     }
 
@@ -126,6 +140,159 @@ namespace {
       return Builder->GetAddrOfGlobal(global, ForDefinition_t(isForDefinition));
     }
 
+    llvm::Module *StartModule(llvm::StringRef ModuleName,
+                              llvm::LLVMContext& C,
+                              const CodeGenOptions& CGO) {
+      assert(!M && "Replacing existing Module?");
+
+      std::unique_ptr<CodeGen::CodeGenModule> OldBuilder;
+      OldBuilder.swap(Builder);
+      CodeGenOpts = CGO;
+      M.reset(new llvm::Module(ModuleName, C));
+      Initialize(*Ctx);
+
+      assert(OldBuilder->DeferredDeclsToEmit.empty()
+             && "Should have emitted all decls deferred to emit.");
+      assert(Builder->DeferredDecls.empty()
+             && "Newly created module should not have deferred decls");
+      Builder->DeferredDecls.swap(OldBuilder->DeferredDecls);
+
+      assert(OldBuilder->EmittedDeferredDecls.empty()
+             && "Still have (unmerged) EmittedDeferredDecls deferred decls");
+
+      assert(Builder->DeferredVTables.empty()
+             && "Newly created module should not have deferred vtables");
+      Builder->DeferredVTables.swap(OldBuilder->DeferredVTables);
+
+      assert(Builder->Manglings.empty()
+             && "Newly created module should not have manglings");
+      // Calls swap() internally, *also* swapping the Allocator object which is
+      // essential to keep the storage!
+      Builder->Manglings = std::move(OldBuilder->Manglings);
+
+      assert(Builder->WeakRefReferences.empty()
+             && "Newly created module should not have weakRefRefs");
+      Builder->WeakRefReferences.swap(OldBuilder->WeakRefReferences);
+
+      ((CXXABICtxSwapper&)*Builder->ABI).SwapCtx(*OldBuilder->ABI);
+      Builder->TBAA.swap(OldBuilder->TBAA);
+
+      return M.get();
+    }
+
+    void print(llvm::raw_ostream& out) {
+      out << "\n\nCodeGen:\n";
+      //llvm::SmallPtrSet<llvm::GlobalValue*, 10> WeakRefReferences;
+      out << " WeakRefReferences (llvm::SmallPtrSet<llvm::GlobalValue*, 10>)\n";
+      for(auto I = Builder->WeakRefReferences.begin(),
+            E = Builder->WeakRefReferences.end(); I != E; ++I) {
+        (*I)->print(out);
+        out << "\n";
+      }
+
+      //llvm::StringMap<GlobalDecl> DeferredDecls;
+      out << " DeferredDecls (llvm::StringMap<GlobalDecl>)\n";
+      for(auto I = Builder->DeferredDecls.begin(),
+            E = Builder->DeferredDecls.end(); I != E; ++I) {
+        out << I->first.str().c_str();
+        I->second.getDecl()->print(out);
+        out << "\n";
+      }
+
+      //std::vector<DeferredGlobal> DeferredDeclsToEmit;
+      out << " DeferredDeclsToEmit (std::vector<DeferredGlobal>)\n";
+      for(auto I = Builder->DeferredDeclsToEmit.begin(),
+            E = Builder->DeferredDeclsToEmit.end(); I != E; ++I) {
+        I->getDecl()->print(out);
+        out << "\n";
+      }
+
+      //std::vector<GlobalDecl> Aliases;
+      out << " Aliases (std::vector<GlobalDecl>)\n";
+      for(auto I = Builder->Aliases.begin(),
+            E = Builder->Aliases.end(); I != E; ++I) {
+        I->getDecl()->print(out);
+        out << "\n";
+      }
+      //typedef llvm::StringMap<llvm::TrackingVH<llvm::Constant> >
+      // ReplacementsTy;
+      //ReplacementsTy Replacements;
+      out
+        << " Replacements (llvm::StringMap<llvm::TrackingVH<llvm::Constant>>\n";
+      for(auto I = Builder->Replacements.begin(),
+            E = Builder->Replacements.end(); I != E; ++I) {
+        out << I->getKey().str().c_str();
+        (*I->getValue()).print(out);
+        out << "\n";
+      }
+
+      //std::vector<const CXXRecordDecl*> DeferredVTables;
+      out << " DeferredVTables (std::vector<const CXXRecordDecl*>\n";
+      for(auto I = Builder->DeferredVTables.begin(),
+            E = Builder->DeferredVTables.end(); I != E; ++I) {
+        (*I)->print(out);
+        out << "\n";
+      }
+
+      //std::vector<llvm::WeakVH> LLVMUsed;
+      out << " LLVMUsed (std::vector<llvm::WeakVH> >\n";
+      for(auto I = Builder->LLVMUsed.begin(),
+            E = Builder->LLVMUsed.end(); I != E; ++I) {
+        (*I)->print(out);
+        out << "\n";
+      }
+
+      // typedef std::vector<std::pair<llvm::Constant*, int> > CtorList;
+      //CtorList GlobalCtors;
+      out << " GlobalCtors (std::vector<std::pair<llvm::Constant*, int> >\n";
+      for(auto I = Builder->GlobalCtors.begin(),
+            E = Builder->GlobalCtors.end(); I != E; ++I) {
+        out << I->Initializer << " : " << I->AssociatedData;
+        out << "\n";
+      }
+
+      //CtorList GlobalDtors;
+      out << " GlobalDtors (std::vector<std::pair<llvm::Constant*, int> >\n";
+      for(auto I = Builder->GlobalDtors.begin(),
+            E = Builder->GlobalDtors.end(); I != E; ++I) {
+        out << I->Initializer << " : " << I->AssociatedData;
+        out << "\n";
+      }
+
+      //llvm::DenseMap<GlobalDecl, StringRef> MangledDeclNames;
+      //std::vector<llvm::Constant*> Annotations;
+      //llvm::StringMap<llvm::Constant*> AnnotationStrings;
+      //llvm::StringMap<llvm::Constant*> CFConstantStringMap;
+      //llvm::StringMap<llvm::GlobalVariable*> ConstantStringMap;
+      out << " ConstantStringMap (llvm::DenseMap<llvm::Constant *, "
+             "llvm::GlobalVariable *>)\n";
+      for(auto I = Builder->ConstantStringMap.begin(),
+            E = Builder->ConstantStringMap.end(); I != E; ++I) {
+        I->first->print(out);
+        I->second->print(out);
+        out << "\n";
+      }
+
+      //llvm::DenseMap<const Decl*, llvm::Constant *> StaticLocalDeclMap;
+      //llvm::DenseMap<const Decl*, llvm::GlobalVariable*> StaticLocalDeclGuardMap;
+      //llvm::DenseMap<const Expr*, llvm::Constant *> MaterializedGlobalTemporaryMap;
+      //llvm::DenseMap<QualType, llvm::Constant *> AtomicSetterHelperFnMap;
+      //llvm::DenseMap<QualType, llvm::Constant *> AtomicGetterHelperFnMap;
+      //llvm::DenseMap<QualType, llvm::Constant *> TypeDescriptorMap;
+      //StaticExternCMap StaticExternCValues;
+      //std::vector<std::pair<const VarDecl *, llvm::GlobalVariable *> >
+      // CXXThreadLocals;
+      //std::vector<llvm::Constant*> CXXThreadLocalInits;
+      //std::vector<llvm::Constant*> CXXGlobalInits;
+      //llvm::DenseMap<const Decl*, unsigned> DelayedCXXInitPosition;
+      //SmallVector<GlobalInitData, 8> PrioritizedCXXGlobalInits;
+      //std::vector<std::pair<llvm::WeakVH,llvm::Constant*> > CXXGlobalDtors;
+      //llvm::SetVector<clang::Module *> ImportedModules;
+      //SmallVector<llvm::Value *, 16> LinkerOptionsMetadata;
+      //
+      out.flush();
+    }
+
     llvm::Module *StartModule(llvm::StringRef ModuleName,
                               llvm::LLVMContext &C) {
       assert(!M && "Replacing existing Module?");
@@ -134,6 +301,21 @@ namespace {
       return M.get();
     }
 
+    void forgetGlobal(llvm::GlobalValue* GV) {
+      for (auto I = Builder->ConstantStringMap.begin(),
+            E = Builder->ConstantStringMap.end(); I != E; ++I) {
+        if (I->second == GV) {
+          Builder->ConstantStringMap.erase(I);
+          break;
+        }
+      }
+    }
+
+    void forgetDecl(const GlobalDecl& GD, llvm::StringRef MangledName) {
+      Builder->DeferredDecls.erase(MangledName);
+      Builder->Manglings.erase(MangledName);
+    }
+
     void Initialize(ASTContext &Context) override {
       Ctx = &Context;
 
@@ -331,11 +513,31 @@ llvm::Constant *CodeGenerator::GetAddrOfGlobal(GlobalDecl global,
            ->GetAddrOfGlobal(global, isForDefinition);
 }
 
+void CodeGenerator::print(llvm::raw_ostream& out) {
+  static_cast<CodeGeneratorImpl*>(this)->print(out);
+}
+
 llvm::Module *CodeGenerator::StartModule(llvm::StringRef ModuleName,
                                          llvm::LLVMContext &C) {
   return static_cast<CodeGeneratorImpl*>(this)->StartModule(ModuleName, C);
 }
 
+void CodeGenerator::forgetGlobal(llvm::GlobalValue* GV) {
+  static_cast<CodeGeneratorImpl*>(this)->forgetGlobal(GV);
+}
+
+void CodeGenerator::forgetDecl(const GlobalDecl& GD,
+                               llvm::StringRef MangledName) {
+  static_cast<CodeGeneratorImpl*>(this)->forgetDecl(GD, MangledName);
+}
+
+
+llvm::Module *CodeGenerator::StartModule(llvm::StringRef ModuleName,
+                                         llvm::LLVMContext& C,
+                                         const CodeGenOptions& CGO) {
+  return static_cast<CodeGeneratorImpl*>(this)->StartModule(ModuleName, C, CGO);
+}
+
 CodeGenerator *clang::CreateLLVMCodeGen(
     DiagnosticsEngine &Diags, llvm::StringRef ModuleName,
     const HeaderSearchOptions &HeaderSearchOpts,
diff --git a/lib/Driver/ToolChains/Arch/AArch64.cpp b/lib/Driver/ToolChains/Arch/AArch64.cpp
index 0e354a49..ed8c7e94 100644
--- a/lib/Driver/ToolChains/Arch/AArch64.cpp
+++ b/lib/Driver/ToolChains/Arch/AArch64.cpp
@@ -191,7 +191,7 @@ void aarch64::getAArch64TargetFeatures(const Driver &D,
   bool success = true;
   // Enable NEON by default.
   Features.push_back("+neon");
-  llvm::StringRef WaMArch;
+  llvm::StringRef WaMArch = "";
   if (ForAS)
     for (const auto *A :
          Args.filtered(options::OPT_Wa_COMMA, options::OPT_Xassembler))
@@ -201,7 +201,7 @@ void aarch64::getAArch64TargetFeatures(const Driver &D,
   // Call getAArch64ArchFeaturesFromMarch only if "-Wa,-march=" or
   // "-Xassembler -march" is detected. Otherwise it may return false
   // and causes Clang to error out.
-  if (!WaMArch.empty())
+  if (WaMArch.size())
     success = getAArch64ArchFeaturesFromMarch(D, WaMArch, Args, Features);
   else if ((A = Args.getLastArg(options::OPT_march_EQ)))
     success = getAArch64ArchFeaturesFromMarch(D, A->getValue(), Args, Features);
@@ -222,15 +222,8 @@ void aarch64::getAArch64TargetFeatures(const Driver &D,
     success = getAArch64MicroArchFeaturesFromMcpu(
         D, getAArch64TargetCPU(Args, Triple, A), Args, Features);
 
-  if (!success) {
-    auto Diag = D.Diag(diag::err_drv_clang_unsupported);
-    // If "-Wa,-march=" is used, 'WaMArch' will contain the argument's value,
-    // while 'A' is uninitialized. Only dereference 'A' in the other case.
-    if (!WaMArch.empty())
-      Diag << "-march=" + WaMArch.str();
-    else
-      Diag << A->getAsString(Args);
-  }
+  if (!success)
+    D.Diag(diag::err_drv_clang_unsupported) << A->getAsString(Args);
 
   if (Args.getLastArg(options::OPT_mgeneral_regs_only)) {
     Features.push_back("-fp-armv8");
diff --git a/lib/Format/TokenAnnotator.cpp b/lib/Format/TokenAnnotator.cpp
index 86c9ac4a..11dc661a 100644
--- a/lib/Format/TokenAnnotator.cpp
+++ b/lib/Format/TokenAnnotator.cpp
@@ -3604,16 +3604,6 @@ static bool isAllmanLambdaBrace(const FormatToken &Tok) {
           !Tok.isOneOf(TT_ObjCBlockLBrace, TT_DictLiteral));
 }
 
-// Returns the first token on the line that is not a comment.
-static const FormatToken *getFirstNonComment(const AnnotatedLine &Line) {
-  const FormatToken *Next = Line.First;
-  if (!Next)
-    return Next;
-  if (Next->is(tok::comment))
-    Next = Next->getNextNonComment();
-  return Next;
-}
-
 bool TokenAnnotator::mustBreakBefore(const AnnotatedLine &Line,
                                      const FormatToken &Right) {
   const FormatToken &Left = *Right.Previous;
@@ -3795,34 +3785,12 @@ bool TokenAnnotator::mustBreakBefore(const AnnotatedLine &Line,
   if (Right.is(TT_InlineASMBrace))
     return Right.HasUnescapedNewline;
 
-  if (isAllmanBrace(Left) || isAllmanBrace(Right)) {
-    auto FirstNonComment = getFirstNonComment(Line);
-    bool AccessSpecifier =
-        FirstNonComment &&
-        FirstNonComment->isOneOf(Keywords.kw_internal, tok::kw_public,
-                                 tok::kw_private, tok::kw_protected);
-
-    if (Style.BraceWrapping.AfterEnum) {
-      if (Line.startsWith(tok::kw_enum) ||
-          Line.startsWith(tok::kw_typedef, tok::kw_enum))
-        return true;
-      // Ensure BraceWrapping for `public enum A {`.
-      if (AccessSpecifier && FirstNonComment->Next &&
-          FirstNonComment->Next->is(tok::kw_enum))
-        return true;
-    }
-
-    // Ensure BraceWrapping for `public interface A {`.
-    if (Style.BraceWrapping.AfterClass &&
-        ((AccessSpecifier && FirstNonComment->Next &&
-          FirstNonComment->Next->is(Keywords.kw_interface)) ||
-         Line.startsWith(Keywords.kw_interface)))
-      return true;
-
-    return (Line.startsWith(tok::kw_class) && Style.BraceWrapping.AfterClass) ||
+  if (isAllmanBrace(Left) || isAllmanBrace(Right))
+    return (Line.startsWith(tok::kw_enum) && Style.BraceWrapping.AfterEnum) ||
+           (Line.startsWith(tok::kw_typedef, tok::kw_enum) &&
+            Style.BraceWrapping.AfterEnum) ||
+           (Line.startsWith(tok::kw_class) && Style.BraceWrapping.AfterClass) ||
            (Line.startsWith(tok::kw_struct) && Style.BraceWrapping.AfterStruct);
-  }
-
   if (Left.is(TT_ObjCBlockLBrace) &&
       Style.AllowShortBlocksOnASingleLine == FormatStyle::SBS_Never)
     return true;
diff --git a/lib/Format/UnwrappedLineParser.cpp b/lib/Format/UnwrappedLineParser.cpp
index 84878750..673986d1 100644
--- a/lib/Format/UnwrappedLineParser.cpp
+++ b/lib/Format/UnwrappedLineParser.cpp
@@ -2532,8 +2532,6 @@ bool UnwrappedLineParser::parseEnum() {
   if (FormatTok->Tok.is(tok::kw_enum))
     nextToken();
 
-  const FormatToken &InitialToken = *FormatTok;
-
   // In TypeScript, "enum" can also be used as property name, e.g. in interface
   // declarations. An "enum" keyword followed by a colon would be a syntax
   // error and thus assume it is just an identifier.
@@ -2580,8 +2578,7 @@ bool UnwrappedLineParser::parseEnum() {
     return true;
   }
 
-  if (!Style.AllowShortEnumsOnASingleLine &&
-      ShouldBreakBeforeBrace(Style, InitialToken))
+  if (!Style.AllowShortEnumsOnASingleLine)
     addUnwrappedLine();
   // Parse enum body.
   nextToken();
diff --git a/lib/Format/WhitespaceManager.cpp b/lib/Format/WhitespaceManager.cpp
index 74136d2f..a822e0aa 100644
--- a/lib/Format/WhitespaceManager.cpp
+++ b/lib/Format/WhitespaceManager.cpp
@@ -1146,15 +1146,14 @@ WhitespaceManager::CellDescriptions WhitespaceManager::getCells(unsigned Start,
       } else if (C.Tok->is(tok::comma)) {
         if (!Cells.empty())
           Cells.back().EndIndex = i;
-        if (C.Tok->getNextNonComment()->isNot(tok::r_brace)) // dangling comma
-          ++Cell;
+        Cell++;
       }
     } else if (Depth == 1) {
       if (C.Tok == MatchingParen) {
         if (!Cells.empty())
           Cells.back().EndIndex = i;
         Cells.push_back(CellDescription{i, ++Cell, i + 1, false, nullptr});
-        CellCount = C.Tok->Previous->isNot(tok::comma) ? Cell + 1 : Cell;
+        CellCount = Cell + 1;
         // Go to the next non-comment and ensure there is a break in front
         const auto *NextNonComment = C.Tok->getNextNonComment();
         while (NextNonComment->is(tok::comma))
@@ -1191,17 +1190,6 @@ WhitespaceManager::CellDescriptions WhitespaceManager::getCells(unsigned Start,
         // So if we split a line previously and the tail line + this token is
         // less then the column limit we remove the split here and just put
         // the column start at a space past the comma
-        //
-        // FIXME This if branch covers the cases where the column is not
-        // the first column. This leads to weird pathologies like the formatting
-        // auto foo = Items{
-        //     Section{
-        //             0, bar(),
-        //     }
-        // };
-        // Well if it doesn't lead to that it's indicative that the line
-        // breaking should be revisited. Unfortunately alot of other options
-        // interact with this
         auto j = i - 1;
         if ((j - 1) > Start && Changes[j].Tok->is(tok::comma) &&
             Changes[j - 1].NewlinesBefore > 0) {
diff --git a/lib/Frontend/CompilerInvocation.cpp b/lib/Frontend/CompilerInvocation.cpp
index 7025028b..e1998cbb 100644
--- a/lib/Frontend/CompilerInvocation.cpp
+++ b/lib/Frontend/CompilerInvocation.cpp
@@ -4605,9 +4605,10 @@ clang::createVFSFromCompilerInvocation(
     const CompilerInvocation &CI, DiagnosticsEngine &Diags,
     IntrusiveRefCntPtr<llvm::vfs::FileSystem> BaseFS) {
   if (CI.getHeaderSearchOpts().VFSOverlayFiles.empty())
-    return BaseFS;
+    return CI.getOverlay();
 
   IntrusiveRefCntPtr<llvm::vfs::FileSystem> Result = BaseFS;
+
   // earlier vfs files are on the bottom
   for (const auto &File : CI.getHeaderSearchOpts().VFSOverlayFiles) {
     llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>> Buffer =
@@ -4625,7 +4626,7 @@ clang::createVFSFromCompilerInvocation(
       continue;
     }
 
-    Result = FS;
+    CI.getOverlay()->pushOverlay(FS);
   }
-  return Result;
+  return CI.getOverlay();
 }
diff --git a/lib/Frontend/VerifyDiagnosticConsumer.cpp b/lib/Frontend/VerifyDiagnosticConsumer.cpp
index 0503ae46..c59da6db 100644
--- a/lib/Frontend/VerifyDiagnosticConsumer.cpp
+++ b/lib/Frontend/VerifyDiagnosticConsumer.cpp
@@ -547,6 +547,11 @@ static bool ParseDirective(StringRef S, ExpectedData *ED, SourceManager &SM,
           Optional<FileEntryRef> File =
               PP->LookupFile(Pos, Filename, false, nullptr, nullptr, CurDir,
                              nullptr, nullptr, nullptr, nullptr, nullptr);
+
+          // Check if the file was virtual
+          if (!File)
+            File = SM.getFileManager().getOptionalFileRef(Filename);
+
           if (!File) {
             Diags.Report(Pos.getLocWithOffset(PH.C - PH.Begin),
                          diag::err_verify_missing_file)
diff --git a/lib/Headers/__clang_cuda_runtime_wrapper.h b/lib/Headers/__clang_cuda_runtime_wrapper.h
index 31126292..f401964b 100644
--- a/lib/Headers/__clang_cuda_runtime_wrapper.h
+++ b/lib/Headers/__clang_cuda_runtime_wrapper.h
@@ -41,7 +41,6 @@
 #include <cmath>
 #include <cstdlib>
 #include <stdlib.h>
-#include <string.h>
 #undef __CUDACC__
 
 // Preserve common macros that will be changed below by us or by CUDA
@@ -206,6 +205,11 @@ inline __host__ double __signbitd(double x) {
 #endif
 
 #if CUDA_VERSION >= 9000
+// CUDA-9.2 needs host-side memcpy for some host functions in
+// device_functions.hpp
+#if CUDA_VERSION >= 9020
+#include <string.h>
+#endif
 #include "crt/math_functions.hpp"
 #else
 #include "math_functions.hpp"
diff --git a/lib/Lex/HeaderSearch.cpp b/lib/Lex/HeaderSearch.cpp
index d5adbcf6..3fb5c61d 100644
--- a/lib/Lex/HeaderSearch.cpp
+++ b/lib/Lex/HeaderSearch.cpp
@@ -152,13 +152,23 @@ std::string HeaderSearch::getPrebuiltModuleFileName(StringRef ModuleName,
   if (FileMapOnly || HSOpts->PrebuiltModulePaths.empty())
     return {};
 
+
+  llvm::StringRef ModuleCachePath = getModuleCachePath();
+  bool CacheFailure = true;
+
   // Then go through each prebuilt module directory and try to find the pcm
   // file.
   for (const std::string &Dir : HSOpts->PrebuiltModulePaths) {
     SmallString<256> Result(Dir);
     llvm::sys::fs::make_absolute(Result);
     llvm::sys::path::append(Result, ModuleName + ".pcm");
-    if (getFileMgr().getFile(Result.str()))
+    // If we have the same ModuleCachePath and PrebuiltModulePath pointing
+    // to the same folder we should not cache the file lookup failure as it
+    // may be currently building an implicit module.
+    if (!ModuleCachePath.empty() && ModuleCachePath == Dir)
+      CacheFailure = false;
+
+    if (getFileMgr().getFile(Result.str(), /*Open=*/false, CacheFailure))
       return std::string(Result);
   }
   return {};
@@ -182,6 +192,7 @@ std::string HeaderSearch::getPrebuiltImplicitModuleFileName(Module *Module) {
   return {};
 }
 
+
 std::string HeaderSearch::getCachedModuleFileName(StringRef ModuleName,
                                                   StringRef ModuleMapPath) {
   return getCachedModuleFileNameImpl(ModuleName, ModuleMapPath,
@@ -345,10 +356,11 @@ StringRef DirectoryLookup::getName() const {
 Optional<FileEntryRef> HeaderSearch::getFileAndSuggestModule(
     StringRef FileName, SourceLocation IncludeLoc, const DirectoryEntry *Dir,
     bool IsSystemHeaderDir, Module *RequestingModule,
-    ModuleMap::KnownHeader *SuggestedModule) {
+    ModuleMap::KnownHeader *SuggestedModule,
+    bool OpenFile /*= true*/, bool CacheFailures /*= true*/) {
   // If we have a module map that might map this header, load it and
   // check whether we'll have a suggestion for a module.
-  auto File = getFileMgr().getFileRef(FileName, /*OpenFile=*/true);
+  auto File = getFileMgr().getFileRef(FileName, OpenFile, CacheFailures);
   if (!File) {
     // For rare, surprising errors (e.g. "out of file handles"), diag the EC
     // message.
@@ -378,7 +390,8 @@ Optional<FileEntryRef> DirectoryLookup::LookupFile(
     SmallVectorImpl<char> *SearchPath, SmallVectorImpl<char> *RelativePath,
     Module *RequestingModule, ModuleMap::KnownHeader *SuggestedModule,
     bool &InUserSpecifiedSystemFramework, bool &IsFrameworkFound,
-    bool &IsInHeaderMap, SmallVectorImpl<char> &MappedName) const {
+    bool &IsInHeaderMap, SmallVectorImpl<char> &MappedName,
+    bool OpenFile) const {
   InUserSpecifiedSystemFramework = false;
   IsInHeaderMap = false;
   MappedName.clear();
@@ -400,7 +413,8 @@ Optional<FileEntryRef> DirectoryLookup::LookupFile(
 
     return HS.getFileAndSuggestModule(TmpDir, IncludeLoc, getDir(),
                                       isSystemHeaderDirectory(),
-                                      RequestingModule, SuggestedModule);
+                                      RequestingModule, SuggestedModule,
+                                      OpenFile);
   }
 
   if (isFramework())
@@ -440,7 +454,7 @@ Optional<FileEntryRef> DirectoryLookup::LookupFile(
       FixupSearchPath();
       return *Result;
     }
-  } else if (auto Res = HS.getFileMgr().getOptionalFileRef(Dest)) {
+  } else if (auto Res = HS.getFileMgr().getOptionalFileRef(Dest, OpenFile)) {
     FixupSearchPath();
     return *Res;
   }
@@ -758,7 +772,7 @@ Optional<FileEntryRef> HeaderSearch::LookupFile(
     SmallVectorImpl<char> *SearchPath, SmallVectorImpl<char> *RelativePath,
     Module *RequestingModule, ModuleMap::KnownHeader *SuggestedModule,
     bool *IsMapped, bool *IsFrameworkFound, bool SkipCache,
-    bool BuildSystemModule) {
+    bool BuildSystemModule, bool OpenFile, bool CacheFailures) {
   if (IsMapped)
     *IsMapped = false;
 
@@ -785,7 +799,8 @@ Optional<FileEntryRef> HeaderSearch::LookupFile(
     // Otherwise, just return the file.
     return getFileAndSuggestModule(Filename, IncludeLoc, nullptr,
                                    /*IsSystemHeaderDir*/false,
-                                   RequestingModule, SuggestedModule);
+                                   RequestingModule, SuggestedModule,
+                                   OpenFile, CacheFailures);
   }
 
   // This is the header that MSVC's header search would have found.
@@ -821,7 +836,8 @@ Optional<FileEntryRef> HeaderSearch::LookupFile(
           BuildSystemModule;
       if (Optional<FileEntryRef> FE = getFileAndSuggestModule(
               TmpDir, IncludeLoc, IncluderAndDir.second, IncluderIsSystemHeader,
-              RequestingModule, SuggestedModule)) {
+              RequestingModule, SuggestedModule,
+              OpenFile, CacheFailures)) {
         if (!Includer) {
           assert(First && "only first includer can have no file");
           return FE;
@@ -921,7 +937,7 @@ Optional<FileEntryRef> HeaderSearch::LookupFile(
     Optional<FileEntryRef> File = SearchDirs[i].LookupFile(
         Filename, *this, IncludeLoc, SearchPath, RelativePath, RequestingModule,
         SuggestedModule, InUserSpecifiedSystemFramework, IsFrameworkFoundInDir,
-        IsInHeaderMap, MappedName);
+        IsInHeaderMap, MappedName, OpenFile);
     if (!MappedName.empty()) {
       assert(IsInHeaderMap && "MappedName should come from a header map");
       CacheLookup.MappedName =
diff --git a/lib/Lex/Lexer.cpp b/lib/Lex/Lexer.cpp
index 64944492..94d9f1a5 100644
--- a/lib/Lex/Lexer.cpp
+++ b/lib/Lex/Lexer.cpp
@@ -791,6 +791,10 @@ SourceLocation Lexer::getLocForEndOfToken(SourceLocation Loc, unsigned Offset,
       return {}; // Points inside the macro expansion.
   }
 
+  // Don't hit the file system for ASTReader tokens.
+  if (SM.isLoadedSourceLocation(Loc))
+    return Loc;
+
   unsigned Len = Lexer::MeasureTokenLength(Loc, SM, LangOpts);
   if (Len > Offset)
     Len = Len - Offset;
diff --git a/lib/Lex/PPDirectives.cpp b/lib/Lex/PPDirectives.cpp
index 3fa87466..72f2aa09 100644
--- a/lib/Lex/PPDirectives.cpp
+++ b/lib/Lex/PPDirectives.cpp
@@ -811,7 +811,8 @@ Optional<FileEntryRef> Preprocessor::LookupFile(
     const DirectoryLookup *&CurDir, SmallVectorImpl<char> *SearchPath,
     SmallVectorImpl<char> *RelativePath,
     ModuleMap::KnownHeader *SuggestedModule, bool *IsMapped,
-    bool *IsFrameworkFound, bool SkipCache) {
+    bool *IsFrameworkFound, bool SkipCache, bool OpenFile,
+    bool CacheFailures) {
   Module *RequestingModule = getModuleForLocation(FilenameLoc);
   bool RequestingModuleIsModuleInterface = !SourceMgr.isInMainFile(FilenameLoc);
 
@@ -820,7 +821,7 @@ Optional<FileEntryRef> Preprocessor::LookupFile(
   SmallVector<std::pair<const FileEntry *, const DirectoryEntry *>, 16>
       Includers;
   bool BuildSystemModule = false;
-  if (!FromDir && !FromFile) {
+  if (!FromDir && !FromFile && getCurrentFileLexer()) {
     FileID FID = getCurrentFileLexer()->getFileID();
     const FileEntry *FileEnt = SourceMgr.getFileEntryForID(FID);
 
@@ -887,7 +888,7 @@ Optional<FileEntryRef> Preprocessor::LookupFile(
   Optional<FileEntryRef> FE = HeaderInfo.LookupFile(
       Filename, FilenameLoc, isAngled, FromDir, CurDir, Includers, SearchPath,
       RelativePath, RequestingModule, SuggestedModule, IsMapped,
-      IsFrameworkFound, SkipCache, BuildSystemModule);
+      IsFrameworkFound, SkipCache, BuildSystemModule, OpenFile, CacheFailures);
   if (FE) {
     if (SuggestedModule && !LangOpts.AsmPreprocessor)
       HeaderInfo.getModuleMap().diagnoseHeaderInclusion(
diff --git a/lib/Lex/PPMacroExpansion.cpp b/lib/Lex/PPMacroExpansion.cpp
index d8ad9d84..7db0481f 100644
--- a/lib/Lex/PPMacroExpansion.cpp
+++ b/lib/Lex/PPMacroExpansion.cpp
@@ -93,6 +93,20 @@ void Preprocessor::appendMacroDirective(IdentifierInfo *II, MacroDirective *MD){
     II->setChangedSinceDeserialization();
 }
 
+void Preprocessor::removeMacro(IdentifierInfo *II, MacroDirective *MD) {
+  assert(II && MD);
+  II->setHasMacroDefinition(false);
+  CurSubmoduleState->Macros.erase(II);
+  if (MacroDirective* prevMD = MD->getPrevious()) {
+    // Avoid assertion in appendMacroDirective.
+    MacroDirective* prevPrevMD = prevMD->getPrevious();
+    prevMD->setPrevious(0);
+    appendMacroDirective(II, prevMD);
+    prevMD->setPrevious(prevPrevMD);
+  }
+}
+
+
 void Preprocessor::setLoadedMacroDirective(IdentifierInfo *II,
                                            MacroDirective *ED,
                                            MacroDirective *MD) {
diff --git a/lib/Lex/Preprocessor.cpp b/lib/Lex/Preprocessor.cpp
index e376fff9..fca2983b 100644
--- a/lib/Lex/Preprocessor.cpp
+++ b/lib/Lex/Preprocessor.cpp
@@ -265,6 +265,43 @@ void Preprocessor::DumpMacro(const MacroInfo &MI) const {
   llvm::errs() << "\n";
 }
 
+void Preprocessor::printMacros(raw_ostream &OS) const {
+  for (macro_iterator I = macro_begin(), E = macro_end(); I != E; ++I) {
+    Preprocessor::printMacro(I->first, I->second.getLatest(), OS);
+  }
+}
+
+void Preprocessor::printMacro(const IdentifierInfo* II,const MacroDirective *MD,
+                              llvm::raw_ostream &OS) const {
+  OS << "<MD: " << MD << ">";
+  OS << II->getName() << " ";
+  OS << "(Tokens:)";
+  const MacroInfo* MI = MD->getMacroInfo();
+  for (unsigned i = 0, e = MI->getNumTokens(); i != e; ++i) {
+    const Token &Tok = MI->getReplacementToken(i);
+    OS << tok::getTokenName(Tok.getKind()) << " '"
+       << getSpelling(Tok) << "'";
+    OS << "\t";
+    if (Tok.isAtStartOfLine())
+      OS << " [StartOfLine]";
+    if (Tok.hasLeadingSpace())
+      OS << " [LeadingSpace]";
+    if (Tok.isExpandDisabled())
+      OS << " [ExpandDisabled]";
+    if (Tok.needsCleaning()) {
+      const char *Start = SourceMgr.getCharacterData(Tok.getLocation());
+      OS << " [UnClean='" << StringRef(Start, Tok.getLength())
+         << "']";
+    }
+    //Do not print location it uses the SourceManager dump to llvm::errs.
+    OS << "\tLoc=<";
+    Tok.getLocation().print(OS, SourceMgr);
+    OS << ">";
+    OS << "  ";
+  }
+  OS << "\n";
+}
+
 void Preprocessor::PrintStats() {
   llvm::errs() << "\n*** Preprocessor Stats:\n";
   llvm::errs() << NumDirectives << " directives found:\n";
diff --git a/lib/Parse/ParsePragma.cpp b/lib/Parse/ParsePragma.cpp
index 42072fe6..3fc3068c 100644
--- a/lib/Parse/ParsePragma.cpp
+++ b/lib/Parse/ParsePragma.cpp
@@ -301,6 +301,10 @@ void markAsReinjectedForRelexing(llvm::MutableArrayRef<clang::Token> Toks) {
 }  // end namespace
 
 void Parser::initializePragmaHandlers() {
+  // No pragma parsing for temporary parsers.
+  if (IsTemporary)
+     return;
+
   AlignHandler = std::make_unique<PragmaAlignHandler>();
   PP.AddPragmaHandler(AlignHandler.get());
 
@@ -434,6 +438,10 @@ void Parser::initializePragmaHandlers() {
 }
 
 void Parser::resetPragmaHandlers() {
+  // No pragma parsing for temporary parsers.
+  if (IsTemporary)
+     return;
+
   // Remove the pragma handlers we installed.
   PP.RemovePragmaHandler(AlignHandler.get());
   AlignHandler.reset();
diff --git a/lib/Parse/Parser.cpp b/lib/Parse/Parser.cpp
index c81dd03f..ed9aae49 100644
--- a/lib/Parse/Parser.cpp
+++ b/lib/Parse/Parser.cpp
@@ -48,15 +48,18 @@ IdentifierInfo *Parser::getSEHExceptKeyword() {
   return Ident__except;
 }
 
-Parser::Parser(Preprocessor &pp, Sema &actions, bool skipFunctionBodies)
+Parser::Parser(Preprocessor &pp, Sema &actions, bool skipFunctionBodies,
+               bool isTemporary /*=false*/)
     : PP(pp), PreferredType(pp.isCodeCompletionEnabled()), Actions(actions),
       Diags(PP.getDiagnostics()), GreaterThanIsOperator(true),
       ColonIsSacred(false), InMessageExpression(false),
-      TemplateParameterDepth(0), ParsingInObjCContainer(false) {
+      TemplateParameterDepth(0), ParsingInObjCContainer(false),
+      IsTemporary(isTemporary) {
   SkipFunctionBodies = pp.isCodeCompletionEnabled() || skipFunctionBodies;
   Tok.startToken();
   Tok.setKind(tok::eof);
-  Actions.CurScope = nullptr;
+  if (!IsTemporary)
+    Actions.CurScope = nullptr;
   NumCachedScopes = 0;
   CurParsedObjCImpl = nullptr;
 
@@ -65,9 +68,11 @@ Parser::Parser(Preprocessor &pp, Sema &actions, bool skipFunctionBodies)
   initializePragmaHandlers();
 
   CommentSemaHandler.reset(new ActionCommentHandler(actions));
-  PP.addCommentHandler(CommentSemaHandler.get());
+  if (!IsTemporary)
+    PP.addCommentHandler(CommentSemaHandler.get());
 
-  PP.setCodeCompletionHandler(*this);
+  if (!IsTemporary)
+    PP.setCodeCompletionHandler(*this);
 }
 
 DiagnosticBuilder Parser::Diag(SourceLocation Loc, unsigned DiagID) {
@@ -453,8 +458,10 @@ Parser::ParseScopeFlags::~ParseScopeFlags() {
 
 Parser::~Parser() {
   // If we still have scopes active, delete the scope tree.
+  if (!IsTemporary) {
   delete getCurScope();
   Actions.CurScope = nullptr;
+  }
 
   // Free the scope cache.
   for (unsigned i = 0, e = NumCachedScopes; i != e; ++i)
@@ -462,9 +469,11 @@ Parser::~Parser() {
 
   resetPragmaHandlers();
 
-  PP.removeCommentHandler(CommentSemaHandler.get());
+  if (!IsTemporary)
+    PP.removeCommentHandler(CommentSemaHandler.get());
 
-  PP.clearCodeCompletionHandler();
+  if (!IsTemporary)
+    PP.clearCodeCompletionHandler();
 
   DestroyTemplateIds();
 }
diff --git a/lib/Tooling/DumpTool/ClangSrcLocDump.cpp b/lib/Tooling/DumpTool/ClangSrcLocDump.cpp
index 8091a467..a41a5c3f 100644
--- a/lib/Tooling/DumpTool/ClangSrcLocDump.cpp
+++ b/lib/Tooling/DumpTool/ClangSrcLocDump.cpp
@@ -1,159 +1,159 @@
-//===- ClangSrcLocDump.cpp ------------------------------------*- C++ -*---===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-
-#include "clang/Basic/Diagnostic.h"
-#include "clang/Driver/Compilation.h"
-#include "clang/Driver/Driver.h"
-#include "clang/Driver/Job.h"
-#include "clang/Driver/Options.h"
-#include "clang/Driver/Tool.h"
-#include "clang/Frontend/CompilerInstance.h"
-#include "clang/Frontend/TextDiagnosticPrinter.h"
-#include "clang/Lex/PreprocessorOptions.h"
-#include "clang/Tooling/Tooling.h"
-#include "llvm/Option/ArgList.h"
-#include "llvm/Support/CommandLine.h"
-#include "llvm/Support/Host.h"
-#include "llvm/Support/JSON.h"
-
-#include "ASTSrcLocProcessor.h"
-
-using namespace clang::tooling;
-using namespace clang;
-using namespace llvm;
-
-static cl::list<std::string> IncludeDirectories(
-    "I", cl::desc("Include directories to use while compiling"),
-    cl::value_desc("directory"), cl::Required, cl::OneOrMore, cl::Prefix);
-
-static cl::opt<bool>
-    SkipProcessing("skip-processing",
-                   cl::desc("Avoid processing the AST header file"),
-                   cl::Required, cl::value_desc("bool"));
-
-static cl::opt<std::string> JsonOutputPath("json-output-path",
-                                           cl::desc("json output path"),
-                                           cl::Required,
-                                           cl::value_desc("path"));
-
-class ASTSrcLocGenerationAction : public clang::ASTFrontendAction {
-public:
-  ASTSrcLocGenerationAction() : Processor(JsonOutputPath) {}
-
-  void ExecuteAction() override {
-    clang::ASTFrontendAction::ExecuteAction();
-    if (getCompilerInstance().getDiagnostics().getNumErrors() > 0)
-      Processor.generateEmpty();
-    else
-      Processor.generate();
-  }
-
-  std::unique_ptr<clang::ASTConsumer>
-  CreateASTConsumer(clang::CompilerInstance &Compiler,
-                    llvm::StringRef File) override {
-    return Processor.createASTConsumer(Compiler, File);
-  }
-
-private:
-  ASTSrcLocProcessor Processor;
-};
-
-static const char Filename[] = "ASTTU.cpp";
-
-int main(int argc, const char **argv) {
-
-  cl::ParseCommandLineOptions(argc, argv);
-
-  if (SkipProcessing) {
-    std::error_code EC;
-    llvm::raw_fd_ostream JsonOut(JsonOutputPath, EC, llvm::sys::fs::OF_Text);
-    if (EC)
-      return 1;
-    JsonOut << formatv("{0:2}", llvm::json::Value(llvm::json::Object()));
-    return 0;
-  }
-
-  std::vector<std::string> Args;
-  Args.push_back("-cc1");
-
-  llvm::transform(IncludeDirectories, std::back_inserter(Args),
-                  [](const std::string &IncDir) { return "-I" + IncDir; });
-
-  Args.push_back("-fsyntax-only");
-  Args.push_back(Filename);
-
-  std::vector<const char *> Argv(Args.size(), nullptr);
-  llvm::transform(Args, Argv.begin(),
-                  [](const std::string &Arg) { return Arg.c_str(); });
-
-  IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts = new DiagnosticOptions();
-  unsigned MissingArgIndex, MissingArgCount;
-  auto Opts = driver::getDriverOptTable();
-  auto ParsedArgs = Opts.ParseArgs(llvm::makeArrayRef(Argv).slice(1),
-                                   MissingArgIndex, MissingArgCount);
-  ParseDiagnosticArgs(*DiagOpts, ParsedArgs);
-
-  // Don't output diagnostics, because common scenarios such as
-  // cross-compiling fail with diagnostics.  This is not fatal, but
-  // just causes attempts to use the introspection API to return no data.
-  TextDiagnosticPrinter DiagnosticPrinter(llvm::nulls(), &*DiagOpts);
-  DiagnosticsEngine Diagnostics(
-      IntrusiveRefCntPtr<DiagnosticIDs>(new DiagnosticIDs()), &*DiagOpts,
-      &DiagnosticPrinter, false);
-
-  auto *OFS = new llvm::vfs::OverlayFileSystem(vfs::getRealFileSystem());
-
-  auto *MemFS = new llvm::vfs::InMemoryFileSystem();
-  OFS->pushOverlay(MemFS);
-  MemFS->addFile(Filename, 0,
-                 MemoryBuffer::getMemBuffer("#include \"clang/AST/AST.h\"\n"));
-
-  auto Files = llvm::makeIntrusiveRefCnt<FileManager>(FileSystemOptions(), OFS);
-
-  auto Driver = std::make_unique<driver::Driver>(
-      "clang", llvm::sys::getDefaultTargetTriple(), Diagnostics,
-      "ast-api-dump-tool", OFS);
-
-  std::unique_ptr<clang::driver::Compilation> Comp(
-      Driver->BuildCompilation(llvm::makeArrayRef(Argv)));
-  if (!Comp)
-    return 1;
-
-  const auto &Jobs = Comp->getJobs();
-  if (Jobs.size() != 1 || !isa<driver::Command>(*Jobs.begin())) {
-    SmallString<256> error_msg;
-    llvm::raw_svector_ostream error_stream(error_msg);
-    Jobs.Print(error_stream, "; ", true);
-    return 1;
-  }
-
-  const auto &Cmd = cast<driver::Command>(*Jobs.begin());
-  const llvm::opt::ArgStringList &CC1Args = Cmd.getArguments();
-
-  auto Invocation = std::make_unique<CompilerInvocation>();
-  CompilerInvocation::CreateFromArgs(*Invocation, CC1Args, Diagnostics);
-
-  CompilerInstance Compiler(std::make_shared<clang::PCHContainerOperations>());
-  Compiler.setInvocation(std::move(Invocation));
-
-  Compiler.createDiagnostics(&DiagnosticPrinter, false);
-  if (!Compiler.hasDiagnostics())
-    return 1;
-
-  // Suppress "2 errors generated" or similar messages
-  Compiler.getDiagnosticOpts().ShowCarets = false;
-  Compiler.createSourceManager(*Files);
-  Compiler.setFileManager(Files.get());
-
-  ASTSrcLocGenerationAction ScopedToolAction;
-  Compiler.ExecuteAction(ScopedToolAction);
-
-  Files->clearStatCache();
-
-  return 0;
-}
+//===- ClangSrcLocDump.cpp ------------------------------------*- C++ -*---===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/Basic/Diagnostic.h"
+#include "clang/Driver/Compilation.h"
+#include "clang/Driver/Driver.h"
+#include "clang/Driver/Job.h"
+#include "clang/Driver/Options.h"
+#include "clang/Driver/Tool.h"
+#include "clang/Frontend/CompilerInstance.h"
+#include "clang/Frontend/TextDiagnosticPrinter.h"
+#include "clang/Lex/PreprocessorOptions.h"
+#include "clang/Tooling/Tooling.h"
+#include "llvm/Option/ArgList.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Host.h"
+#include "llvm/Support/JSON.h"
+
+#include "ASTSrcLocProcessor.h"
+
+using namespace clang::tooling;
+using namespace clang;
+using namespace llvm;
+
+static cl::list<std::string> IncludeDirectories(
+    "I", cl::desc("Include directories to use while compiling"),
+    cl::value_desc("directory"), cl::Required, cl::OneOrMore, cl::Prefix);
+
+static cl::opt<bool>
+    SkipProcessing("skip-processing",
+                   cl::desc("Avoid processing the AST header file"),
+                   cl::Required, cl::value_desc("bool"));
+
+static cl::opt<std::string> JsonOutputPath("json-output-path",
+                                           cl::desc("json output path"),
+                                           cl::Required,
+                                           cl::value_desc("path"));
+
+class ASTSrcLocGenerationAction : public clang::ASTFrontendAction {
+public:
+  ASTSrcLocGenerationAction() : Processor(JsonOutputPath) {}
+
+  void ExecuteAction() override {
+    clang::ASTFrontendAction::ExecuteAction();
+    if (getCompilerInstance().getDiagnostics().getNumErrors() > 0)
+      Processor.generateEmpty();
+    else
+      Processor.generate();
+  }
+
+  std::unique_ptr<clang::ASTConsumer>
+  CreateASTConsumer(clang::CompilerInstance &Compiler,
+                    llvm::StringRef File) override {
+    return Processor.createASTConsumer(Compiler, File);
+  }
+
+private:
+  ASTSrcLocProcessor Processor;
+};
+
+static const char Filename[] = "ASTTU.cpp";
+
+int main(int argc, const char **argv) {
+
+  cl::ParseCommandLineOptions(argc, argv);
+
+  if (SkipProcessing) {
+    std::error_code EC;
+    llvm::raw_fd_ostream JsonOut(JsonOutputPath, EC, llvm::sys::fs::OF_Text);
+    if (EC)
+      return 1;
+    JsonOut << formatv("{0:2}", llvm::json::Value(llvm::json::Object()));
+    return 0;
+  }
+
+  std::vector<std::string> Args;
+  Args.push_back("-cc1");
+
+  llvm::transform(IncludeDirectories, std::back_inserter(Args),
+                  [](const std::string &IncDir) { return "-I" + IncDir; });
+
+  Args.push_back("-fsyntax-only");
+  Args.push_back(Filename);
+
+  std::vector<const char *> Argv(Args.size(), nullptr);
+  llvm::transform(Args, Argv.begin(),
+                  [](const std::string &Arg) { return Arg.c_str(); });
+
+  IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts = new DiagnosticOptions();
+  unsigned MissingArgIndex, MissingArgCount;
+  auto Opts = driver::getDriverOptTable();
+  auto ParsedArgs = Opts.ParseArgs(llvm::makeArrayRef(Argv).slice(1),
+                                   MissingArgIndex, MissingArgCount);
+  ParseDiagnosticArgs(*DiagOpts, ParsedArgs);
+
+  // Don't output diagnostics, because common scenarios such as
+  // cross-compiling fail with diagnostics.  This is not fatal, but
+  // just causes attempts to use the introspection API to return no data.
+  TextDiagnosticPrinter DiagnosticPrinter(llvm::nulls(), &*DiagOpts);
+  DiagnosticsEngine Diagnostics(
+      IntrusiveRefCntPtr<DiagnosticIDs>(new DiagnosticIDs()), &*DiagOpts,
+      &DiagnosticPrinter, false);
+
+  auto *OFS = new llvm::vfs::OverlayFileSystem(vfs::getRealFileSystem());
+
+  auto *MemFS = new llvm::vfs::InMemoryFileSystem();
+  OFS->pushOverlay(MemFS);
+  MemFS->addFile(Filename, 0,
+                 MemoryBuffer::getMemBuffer("#include \"clang/AST/AST.h\"\n"));
+
+  auto Files = llvm::makeIntrusiveRefCnt<FileManager>(FileSystemOptions(), OFS);
+
+  auto Driver = std::make_unique<driver::Driver>(
+      "clang", llvm::sys::getDefaultTargetTriple(), Diagnostics,
+      "ast-api-dump-tool", OFS);
+
+  std::unique_ptr<clang::driver::Compilation> Comp(
+      Driver->BuildCompilation(llvm::makeArrayRef(Argv)));
+  if (!Comp)
+    return 1;
+
+  const auto &Jobs = Comp->getJobs();
+  if (Jobs.size() != 1 || !isa<driver::Command>(*Jobs.begin())) {
+    SmallString<256> error_msg;
+    llvm::raw_svector_ostream error_stream(error_msg);
+    Jobs.Print(error_stream, "; ", true);
+    return 1;
+  }
+
+  const auto &Cmd = cast<driver::Command>(*Jobs.begin());
+  const llvm::opt::ArgStringList &CC1Args = Cmd.getArguments();
+
+  auto Invocation = std::make_unique<CompilerInvocation>();
+  CompilerInvocation::CreateFromArgs(*Invocation, CC1Args, Diagnostics);
+
+  CompilerInstance Compiler(std::make_shared<clang::PCHContainerOperations>());
+  Compiler.setInvocation(std::move(Invocation));
+
+  Compiler.createDiagnostics(&DiagnosticPrinter, false);
+  if (!Compiler.hasDiagnostics())
+    return 1;
+
+  // Suppress "2 errors generated" or similar messages
+  Compiler.getDiagnosticOpts().ShowCarets = false;
+  Compiler.createSourceManager(*Files);
+  Compiler.setFileManager(Files.get());
+
+  ASTSrcLocGenerationAction ScopedToolAction;
+  Compiler.ExecuteAction(ScopedToolAction);
+
+  Files->clearStatCache();
+
+  return 0;
+}
-- 
2.34.1

