From cc711a7db0c37c1f231559de76539e65130de13d Mon Sep 17 00:00:00 2001
From: Chris Burr <christopher.burr@cern.ch>
Date: Tue, 13 Dec 2022 13:54:21 +0100
Subject: [PATCH 2/4] ROOT: libs 1

---
 lib/Sema/HackForDefaultTemplateArg.h    |  52 ++++++++++
 lib/Sema/Sema.cpp                       |  18 ++--
 lib/Sema/SemaCXXScopeSpec.cpp           |  33 ++++++-
 lib/Sema/SemaDecl.cpp                   |  34 ++++++-
 lib/Sema/SemaDeclCXX.cpp                |   5 +-
 lib/Sema/SemaExpr.cpp                   |  35 ++++++-
 lib/Sema/SemaExprCXX.cpp                |   3 +-
 lib/Sema/SemaLookup.cpp                 |   8 +-
 lib/Sema/SemaModule.cpp                 |   2 +-
 lib/Sema/SemaTemplate.cpp               |  98 ++++++++++++++++---
 lib/Sema/SemaTemplateInstantiate.cpp    |  16 ++-
 lib/Sema/SemaType.cpp                   |   4 +-
 lib/Sema/TreeTransform.h                |  21 +++-
 lib/Serialization/ASTReader.cpp         | 124 ++++++++++++++++++------
 lib/Serialization/ASTReaderDecl.cpp     |  40 +++++---
 lib/Serialization/ASTReaderInternals.h  |   2 +-
 lib/Serialization/ASTWriter.cpp         |  23 ++++-
 lib/Serialization/ASTWriterDecl.cpp     |  74 +++++++++++---
 lib/Serialization/GlobalModuleIndex.cpp | 112 ++++++++++++++-------
 lib/Serialization/ModuleManager.cpp     |  11 ++-
 20 files changed, 578 insertions(+), 137 deletions(-)
 create mode 100644 lib/Sema/HackForDefaultTemplateArg.h

diff --git a/lib/Sema/HackForDefaultTemplateArg.h b/lib/Sema/HackForDefaultTemplateArg.h
new file mode 100644
index 00000000..e6af62c4
--- /dev/null
+++ b/lib/Sema/HackForDefaultTemplateArg.h
@@ -0,0 +1,52 @@
+//===------- HackForDefaultTemplateArg.h - Make template argument substitution mroe permissive -----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//===----------------------------------------------------------------------===//
+//
+//  Enabling this hack, make the template substitution more permissive and
+//  allows for replacement with non-canonical types.  This is usefull in the
+//  case of client code emulating opaque typedefs and/or wanting to recover
+//  the template instance name as the user would have written if (s)he 
+//  expanded the default paramater explicitly.   For example the user might
+//  have type: vector<int32_t> and the client wants to see:
+//  std::vector<int32_t,std::allocator<int32_t> >
+//
+//  For convenience purposes the implementation is located in
+//  SemaTemplate.cpp
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_SEMA_HACKFORDEFAULTTEMPLATEARG_H
+#define LLVM_CLANG_SEMA_HACKFORDEFAULTTEMPLATEARG_H
+
+namespace clang {
+namespace sema {
+
+///  \brief Enabling this hack makes the template substitution more permissive
+///  and allows for replacement with non-canonical types.  This is usefull in
+///  the case of client code emulating opaque typedefs and/or wanting to recover
+///  the template instance name as the user would have written if (s)he
+///  expanded the default paramater explicitly.   For example the user might
+///  have type: \c vector<int32_t> and the client wants to see:
+///  \c std::vector<int32_t,std::allocator<int32_t> >
+   
+class HackForDefaultTemplateArg {
+  /// \brief Private RAII object that set and reset the hack state.
+
+  static bool AllowNonCanonicalSubstEnabled;
+  bool OldValue;
+public:
+
+  HackForDefaultTemplateArg();
+  ~HackForDefaultTemplateArg();
+  
+  static bool AllowNonCanonicalSubst();
+};
+  
+} // sema
+} // clang
+
+#endif // LLVM_CLANG_SEMA_HACKFORDEFAULTTEMPLATEARG_H
diff --git a/lib/Sema/Sema.cpp b/lib/Sema/Sema.cpp
index 191d89ea..e595fb21 100644
--- a/lib/Sema/Sema.cpp
+++ b/lib/Sema/Sema.cpp
@@ -173,7 +173,7 @@ const unsigned Sema::MaximumAlignment;
 
 Sema::Sema(Preprocessor &pp, ASTContext &ctxt, ASTConsumer &consumer,
            TranslationUnitKind TUKind, CodeCompleteConsumer *CodeCompleter)
-    : ExternalSource(nullptr), isMultiplexExternalSource(false),
+    : ExternalSource(nullptr),
       CurFPFeatures(pp.getLangOpts()), LangOpts(pp.getLangOpts()), PP(pp),
       Context(ctxt), Consumer(consumer), Diags(PP.getDiagnostics()),
       SourceMgr(PP.getSourceManager()), CollectStats(false),
@@ -451,10 +451,6 @@ Sema::~Sema() {
         = dyn_cast_or_null<ExternalSemaSource>(Context.getExternalSource()))
     ExternalSema->ForgetSema();
 
-  // If Sema's ExternalSource is the multiplexer - we own it.
-  if (isMultiplexExternalSource)
-    delete ExternalSource;
-
   // Delete cached satisfactions.
   std::vector<ConstraintSatisfaction *> Satisfactions;
   Satisfactions.reserve(Satisfactions.size());
@@ -528,11 +524,12 @@ void Sema::addExternalSource(ExternalSemaSource *E) {
     return;
   }
 
-  if (isMultiplexExternalSource)
-    static_cast<MultiplexExternalSemaSource*>(ExternalSource)->addSource(*E);
+  if (MultiplexExternalSource.get())
+    MultiplexExternalSource->addSource(*E);
   else {
-    ExternalSource = new MultiplexExternalSemaSource(*ExternalSource, *E);
-    isMultiplexExternalSource = true;
+    MultiplexExternalSource
+      = new MultiplexExternalSemaSource(*ExternalSource, *E);
+    ExternalSource = MultiplexExternalSource.get();
   }
 }
 
@@ -1363,7 +1360,7 @@ void Sema::ActOnEndOfTranslationUnit() {
   }
 
   if (!Diags.isIgnored(diag::warn_mismatched_delete_new, SourceLocation())) {
-    if (ExternalSource)
+    if (ExternalSource && !PP.isIncrementalProcessingEnabled())
       ExternalSource->ReadMismatchingDeleteExpressions(DeleteExprs);
     for (const auto &DeletedFieldInfo : DeleteExprs) {
       for (const auto &DeleteExprLoc : DeletedFieldInfo.second) {
@@ -1371,6 +1368,7 @@ void Sema::ActOnEndOfTranslationUnit() {
                                   DeleteExprLoc.second);
       }
     }
+    DeleteExprs.clear();
   }
 
   // Check we've noticed that we're no longer parsing the initializer for every
diff --git a/lib/Sema/SemaCXXScopeSpec.cpp b/lib/Sema/SemaCXXScopeSpec.cpp
index 1c8f6329..2f70f6ae 100644
--- a/lib/Sema/SemaCXXScopeSpec.cpp
+++ b/lib/Sema/SemaCXXScopeSpec.cpp
@@ -23,7 +23,8 @@
 #include "llvm/ADT/STLExtras.h"
 using namespace clang;
 
-/// Find the current instantiation that associated with the given type.
+#include "HackForDefaultTemplateArg.h"
+
 static CXXRecordDecl *getCurrentInstantiationOf(QualType T,
                                                 DeclContext *CurContext) {
   if (T.isNull())
@@ -107,6 +108,10 @@ DeclContext *Sema::computeDeclContext(const CXXScopeSpec &SS,
           // into that class template definition.
           QualType Injected
             = ClassTemplate->getInjectedClassNameSpecialization();
+
+          // Injected might not be canonical
+          Injected = Injected.getCanonicalType();
+
           if (Context.hasSameType(Injected, ContextType))
             return ClassTemplate->getTemplatedDecl();
 
@@ -150,6 +155,12 @@ DeclContext *Sema::computeDeclContext(const CXXScopeSpec &SS,
   case NestedNameSpecifier::TypeSpec:
   case NestedNameSpecifier::TypeSpecWithTemplate: {
     const TagType *Tag = NNS->getAsType()->getAs<TagType>();
+    if (!Tag 
+	&& sema::HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+      // In case we are in the middle of a template name creation
+      // that tries to keep some of the typedef
+      Tag = NNS->getAsType()->getCanonicalTypeInternal()->getAs<TagType>();
+    }
     assert(Tag && "Non-tag type in nested-name-specifier");
     return Tag->getDecl();
   }
@@ -197,7 +208,7 @@ CXXRecordDecl *Sema::getCurrentInstantiationOf(NestedNameSpecifier *NNS) {
 /// a class template specialization that is not a complete type, we
 /// will attempt to instantiate that class template.
 bool Sema::RequireCompleteDeclContext(CXXScopeSpec &SS,
-                                      DeclContext *DC) {
+                                      DeclContext *&DC) {
   assert(DC && "given null context");
 
   TagDecl *tag = dyn_cast<TagDecl>(DC);
@@ -223,6 +234,12 @@ bool Sema::RequireCompleteDeclContext(CXXScopeSpec &SS,
   // The type must be complete.
   if (RequireCompleteType(loc, type, diag::err_incomplete_nested_name_spec,
                           SS.getRange())) {
+    // The actual information about the decl may have been loaded via an
+    // external source that created a new AST node/decl for the definition
+    // rather than reusing the one we had (DC) like the ASTReader does.
+    // To avoid the caller to continue using the still incomplete decl, let's
+    // set it to the definition.
+    DC = tag->getDefinition();
     SS.SetInvalid(SS.getRange());
     return true;
   }
@@ -534,9 +551,15 @@ bool Sema::BuildCXXNestedNameSpecifier(Scope *S, NestedNameSpecInfo &IdInfo,
     // nested-name-specifier.
 
     // The declaration context must be complete.
-    if (!LookupCtx->isDependentContext() &&
-        RequireCompleteDeclContext(SS, LookupCtx))
-      return true;
+    if (!LookupCtx->isDependentContext()) {
+      if (RequireCompleteDeclContext(SS, LookupCtx)) {
+        return true;
+      } else if (TagDecl* TD = dyn_cast<TagDecl>(LookupCtx)) {
+        // Update the DeclContext to point to the Tag definition.
+        LookupCtx = TD->getDefinition();
+      }
+    }
+
 
     LookupQualifiedName(Found, LookupCtx);
 
diff --git a/lib/Sema/SemaDecl.cpp b/lib/Sema/SemaDecl.cpp
index 205f5800..74268e59 100644
--- a/lib/Sema/SemaDecl.cpp
+++ b/lib/Sema/SemaDecl.cpp
@@ -331,9 +331,14 @@ ParsedType Sema::getTypeName(const IdentifierInfo &II, SourceLocation NameLoc,
       return nullptr;
     }
 
-    if (!LookupCtx->isDependentContext() &&
-        RequireCompleteDeclContext(*SS, LookupCtx))
-      return nullptr;
+    if (!LookupCtx->isDependentContext()) {
+      if (RequireCompleteDeclContext(*SS, LookupCtx)) {
+        return nullptr;
+      } else if (TagDecl* TD = dyn_cast<TagDecl>(LookupCtx)) {
+        // Update the DeclContext to point to the Tag definition.
+        LookupCtx = TD->getDefinition();
+      }
+    }
   }
 
   // FIXME: LookupNestedNameSpecifierName isn't the right kind of
@@ -15279,6 +15284,29 @@ bool Sema::CheckEnumRedeclaration(SourceLocation EnumLoc, bool IsScoped,
       return true;
     }
   } else if (IsFixed != Prev->isFixed()) {
+    // Determine whether this is a cling fwd decl.
+    auto hasFwdDeclAnnotation = [](const Decl *Prev) -> bool {
+      for(auto attr = Prev->specific_attr_begin<AnnotateAttr>(),
+               end = Prev->specific_attr_end<AnnotateAttr> ();
+          attr != end;
+          ++attr)
+      {
+        if (!attr->isInherited()) {
+          llvm::StringRef annotation = attr->getAnnotation();
+          assert(!annotation.empty() && "Empty annotation!");
+          static const char annoTag[] = "$clingAutoload$";
+          if (annotation.startswith(llvm::StringRef(annoTag, strlen(annoTag)))) {
+            // autoload annotation.
+            return true;
+          }
+        }
+      }
+      return false;
+    };
+
+    if (hasFwdDeclAnnotation(Prev))
+      return false;
+
     Diag(EnumLoc, diag::err_enum_redeclare_fixed_mismatch)
       << Prev->isFixed();
     Diag(Prev->getLocation(), diag::note_previous_declaration);
diff --git a/lib/Sema/SemaDeclCXX.cpp b/lib/Sema/SemaDeclCXX.cpp
index ac01beb1..5b3c407a 100644
--- a/lib/Sema/SemaDeclCXX.cpp
+++ b/lib/Sema/SemaDeclCXX.cpp
@@ -537,6 +537,8 @@ bool Sema::MergeCXXFunctionDecl(FunctionDecl *New, FunctionDecl *Old,
         }
       }
 
+      (void)DiagDefaultParamID;
+#if 0 // Disable until Diag is rewired
       // FIXME: If we knew where the '=' was, we could easily provide a fix-it
       // hint here. Alternatively, we could walk the type-source information
       // for NewParam to find the last source location in the type... but it
@@ -558,6 +560,7 @@ bool Sema::MergeCXXFunctionDecl(FunctionDecl *New, FunctionDecl *Old,
 
       Diag(OldParam->getLocation(), diag::note_previous_definition)
         << OldParam->getDefaultArgRange();
+#endif
     } else if (OldParamHasDfl) {
       // Merge the old default argument into the new parameter unless the new
       // function is a friend declaration in a template class. In the latter
@@ -12577,7 +12580,7 @@ bool Sema::CheckUsingDeclQualifier(SourceLocation UsingLoc, bool HasTypename,
     if (Cxx20Enumerator)
       return false; // OK
 
-    auto *RD = NamedContext
+    DeclContext *RD = NamedContext
                    ? cast<CXXRecordDecl>(NamedContext->getRedeclContext())
                    : nullptr;
     if (RD && !RequireCompleteDeclContext(const_cast<CXXScopeSpec &>(SS), RD)) {
diff --git a/lib/Sema/SemaExpr.cpp b/lib/Sema/SemaExpr.cpp
index 4179249e..ca41bc61 100644
--- a/lib/Sema/SemaExpr.cpp
+++ b/lib/Sema/SemaExpr.cpp
@@ -14134,6 +14134,39 @@ ExprResult Sema::CreateBuiltinBinOp(SourceLocation OpLoc,
 
   switch (Opc) {
   case BO_Assign:
+    // ROOT hack: we want to support constructs like n = new TNamed() and if n
+    // wasn't declared we should declare it.
+    if (DeclRefExpr* DRE = dyn_cast<DeclRefExpr>(LHSExpr)) {
+      if (VarDecl* VD = dyn_cast<VarDecl>(DRE->getDecl()))
+        if (const AutoType* aTy = dyn_cast<AutoType>(VD->getType().getTypePtr()))
+          if (const AnnotateAttr* A = VD->getAttr<AnnotateAttr>())
+            // If the deduction didn't take place and it is our special 
+            // annotation
+            if (!aTy->isDeduced() && A->getAnnotation().equals("__Auto")) {
+            QualType ResTy;
+            ASTContext& C = getASTContext();
+            TypeSourceInfo* TrivialTSI
+              = C.getTrivialTypeSourceInfo(VD->getType());
+            if (DeduceAutoType(TrivialTSI, RHSExpr, ResTy) != DAR_Succeeded) {
+               Diag(VD->getLocation(), diag::err_auto_var_requires_init)
+                  << VD->getDeclName() << VD->getType();
+               VD->setInvalidDecl();
+
+               return ExprError();
+            }
+            VD->setTypeSourceInfo(C.getTrivialTypeSourceInfo(ResTy));
+            VD->setType(ResTy);
+            VD->setInit(DefaultLvalueConversion(RHSExpr).get());
+            PushOnScopeChains(VD, getCurScope(), /*Add to ctx*/true);
+
+
+            // Here we need to return 'something' to make the parser happy. 
+            // A reference to the decl is semantically closest to what we want.
+            return BuildDeclRefExpr(VD, VD->getType(), VK_LValue, 
+                                    SourceLocation());
+          }
+    }
+
     ResultTy = CheckAssignmentOperands(LHS.get(), RHS, OpLoc, QualType());
     if (getLangOpts().CPlusPlus &&
         LHS.get()->getObjectKind() != OK_ObjCProperty) {
@@ -15868,7 +15901,7 @@ ExprResult Sema::BuildVAArgExpr(SourceLocation BuiltinLoc,
       // promoted type and the underlying type are the same except for
       // signedness. Ask the AST for the correctly corresponding type and see
       // if that's compatible.
-      if (!PromoteType.isNull() && !UnderlyingType->isBooleanType() &&
+      if (!PromoteType.isNull() &&
           PromoteType->isUnsignedIntegerType() !=
               UnderlyingType->isUnsignedIntegerType()) {
         UnderlyingType =
diff --git a/lib/Sema/SemaExprCXX.cpp b/lib/Sema/SemaExprCXX.cpp
index 7961e794..4d417cb9 100644
--- a/lib/Sema/SemaExprCXX.cpp
+++ b/lib/Sema/SemaExprCXX.cpp
@@ -96,7 +96,8 @@ ParsedType Sema::getConstructorName(IdentifierInfo &II,
     return ParsedType::make(T);
   }
 
-  if (SS.isNotEmpty() && RequireCompleteDeclContext(SS, CurClass))
+  DeclContext *DC = CurClass;
+  if (SS.isNotEmpty() && RequireCompleteDeclContext(SS, DC))
     return ParsedType();
 
   // Find the injected-class-name declaration. Note that we make no attempt to
diff --git a/lib/Sema/SemaLookup.cpp b/lib/Sema/SemaLookup.cpp
index 5e8c4de6..d8599c5f 100644
--- a/lib/Sema/SemaLookup.cpp
+++ b/lib/Sema/SemaLookup.cpp
@@ -2003,8 +2003,14 @@ bool Sema::LookupName(LookupResult &R, Scope *S, bool AllowBuiltinCreation) {
       }
   } else {
     // Perform C++ unqualified name lookup.
-    if (CppLookupName(R, S))
+    if (CppLookupName(R, S)) {
+      if (R.isSingleResult())
+        if (const TagDecl *TD = dyn_cast<TagDecl>(R.getFoundDecl())) {
+          if (!TD->getDefinition() && ExternalSource)
+            ExternalSource->LookupUnqualified(R, S);
+        }
       return true;
+    }
   }
 
   // If we didn't find a use of this identifier, and if the identifier
diff --git a/lib/Sema/SemaModule.cpp b/lib/Sema/SemaModule.cpp
index af95b1a9..8b2a8b1c 100644
--- a/lib/Sema/SemaModule.cpp
+++ b/lib/Sema/SemaModule.cpp
@@ -344,7 +344,7 @@ DeclResult Sema::ActOnModuleImport(SourceLocation StartLoc,
                                    Module *Mod, ModuleIdPath Path) {
   VisibleModules.setVisible(Mod, ImportLoc);
 
-  checkModuleImportContext(*this, Mod, ImportLoc, CurContext);
+  //checkModuleImportContext(*this, Mod, ImportLoc, CurContext);
 
   // FIXME: we should support importing a submodule within a different submodule
   // of the same top-level module. Until we do, make it an error rather than
diff --git a/lib/Sema/SemaTemplate.cpp b/lib/Sema/SemaTemplate.cpp
index 5d26f2d2..b75f39b1 100644
--- a/lib/Sema/SemaTemplate.cpp
+++ b/lib/Sema/SemaTemplate.cpp
@@ -39,6 +39,31 @@
 using namespace clang;
 using namespace sema;
 
+bool HackForDefaultTemplateArg::AllowNonCanonicalSubstEnabled = true;
+
+// Default constructor, record the current value
+// of HackForDefaultTemplateArg::AllowNonCanonicalSubst
+// and set it to true.
+HackForDefaultTemplateArg::HackForDefaultTemplateArg() :
+  OldValue(HackForDefaultTemplateArg::AllowNonCanonicalSubstEnabled)
+{
+  AllowNonCanonicalSubstEnabled = true;
+}
+
+// Destructor, restore the previous value of
+// HackForDefaultTemplateArg::AllowNonCanonicalSubst.
+HackForDefaultTemplateArg::~HackForDefaultTemplateArg()
+{
+  AllowNonCanonicalSubstEnabled = OldValue;
+}
+
+// Return the current value of
+// HackForDefaultTemplateArg::AllowNonCanonicalSubst.
+bool HackForDefaultTemplateArg::AllowNonCanonicalSubst()
+{
+  return AllowNonCanonicalSubstEnabled;
+}
+
 // Exported for use by Parser.
 SourceRange
 clang::getTemplateParamsRange(TemplateParameterList const * const *Ps,
@@ -425,6 +450,11 @@ bool Sema::LookupTemplateName(LookupResult &Found,
     // The declaration context must be complete.
     if (LookupCtx && RequireCompleteDeclContext(SS, LookupCtx))
       return true;
+
+    if (TagDecl* TD = dyn_cast_or_null<TagDecl>(LookupCtx)) {
+      // Update the DeclContext to point to the Tag definition.
+      LookupCtx = TD->getDefinition();
+    }
   }
 
   bool ObjectTypeSearchedInScope = false;
@@ -1709,6 +1739,12 @@ static void SetNestedNameSpecifier(Sema &S, TagDecl *T,
   if (SS.isSet())
     T->setQualifierInfo(SS.getWithLocInContext(S.Context));
 }
+static bool IsRootAutoloadDeclTemplate(ClassTemplateDecl *D) {
+  for (TagDecl *TD = D->getTemplatedDecl(); TD; TD = TD->getPreviousDecl())
+    if (auto AnnotAttr = TD->getAttr<AnnotateAttr>())
+      return AnnotAttr->getAnnotation().startswith("$clingAutoload$");
+  return false;
+}
 
 DeclResult Sema::CheckClassTemplate(
     Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,
@@ -1936,6 +1972,20 @@ DeclResult Sema::CheckClassTemplate(
     return true;
   }
 
+  // AXEL - do not check for redecls of template arg defaults when parsing
+  // dictionary forward decls.
+  bool fwdDeclFromROOT = false;
+  for (const auto &A : Attr) {
+    if (A.getKind() != ParsedAttr::AT_Annotate)
+      continue;
+    if (A.getNumArgs() > 0 && A.isArgExpr(0))
+      if (auto AnnotVal = dyn_cast<StringLiteral>(A.getArgAsExpr(0)))
+        if (AnnotVal->getString().startswith("$clingAutoload$"))
+          fwdDeclFromROOT = true;
+  }
+  if (!fwdDeclFromROOT && PrevClassTemplate)
+    fwdDeclFromROOT = IsRootAutoloadDeclTemplate(PrevClassTemplate);
+
   // Check the template parameter list of this declaration, possibly
   // merging in the template parameter list from the previous class
   // template declaration. Skip this check for a friend in a dependent
@@ -1950,7 +2000,7 @@ DeclResult Sema::CheckClassTemplate(
            SemanticContext->isDependentContext())
               ? TPC_ClassTemplateMember
               : TUK == TUK_Friend ? TPC_FriendClassTemplate : TPC_ClassTemplate,
-          SkipBody))
+          SkipBody, /*Complain*/!fwdDeclFromROOT))
     Invalid = true;
 
   if (SS.isSet()) {
@@ -2670,7 +2720,8 @@ static bool DiagnoseUnexpandedParameterPacks(Sema &S,
 bool Sema::CheckTemplateParameterList(TemplateParameterList *NewParams,
                                       TemplateParameterList *OldParams,
                                       TemplateParamListContext TPC,
-                                      SkipBodyInfo *SkipBody) {
+                                      SkipBodyInfo *SkipBody,
+                                      bool Complain /*true*/) {
   bool Invalid = false;
 
   // C++ [temp.param]p10:
@@ -2705,7 +2756,7 @@ bool Sema::CheckTemplateParameterList(TemplateParameterList *NewParams,
     if (TemplateTypeParmDecl *NewTypeParm
           = dyn_cast<TemplateTypeParmDecl>(*NewParam)) {
       // Check the presence of a default argument here.
-      if (NewTypeParm->hasDefaultArgument() &&
+      if (Complain && NewTypeParm->hasDefaultArgument() &&
           DiagnoseDefaultTemplateArgument(*this, TPC,
                                           NewTypeParm->getLocation(),
                NewTypeParm->getDefaultArgumentInfo()->getTypeLoc()
@@ -2749,7 +2800,7 @@ bool Sema::CheckTemplateParameterList(TemplateParameterList *NewParams,
       }
 
       // Check the presence of a default argument here.
-      if (NewNonTypeParm->hasDefaultArgument() &&
+      if (Complain && NewNonTypeParm->hasDefaultArgument() &&
           DiagnoseDefaultTemplateArgument(*this, TPC,
                                           NewNonTypeParm->getLocation(),
                     NewNonTypeParm->getDefaultArgument()->getSourceRange())) {
@@ -2793,7 +2844,7 @@ bool Sema::CheckTemplateParameterList(TemplateParameterList *NewParams,
       }
 
       // Check the presence of a default argument here.
-      if (NewTemplateParm->hasDefaultArgument() &&
+      if (Complain && NewTemplateParm->hasDefaultArgument() &&
           DiagnoseDefaultTemplateArgument(*this, TPC,
                                           NewTemplateParm->getLocation(),
                      NewTemplateParm->getDefaultArgument().getSourceRange()))
@@ -2841,14 +2892,24 @@ bool Sema::CheckTemplateParameterList(TemplateParameterList *NewParams,
       Invalid = true;
     }
 
-    if (RedundantDefaultArg) {
+    if (RedundantDefaultArg &&
+        (((*OldParam)->hasAttr<AnnotateAttr>() &&
+         (*OldParam)->getAttr<AnnotateAttr>()->getAnnotation() == "rootmap") ||
+        ((*NewParam)->hasAttr<AnnotateAttr>() &&
+         (*NewParam)->getAttr<AnnotateAttr>()->getAnnotation() == "rootmap"))) {
+      RedundantDefaultArg = false;
+    }
+    if (Complain && RedundantDefaultArg) {
       // C++ [temp.param]p12:
       //   A template-parameter shall not be given default arguments
       //   by two different declarations in the same scope.
+
+#if 0 // Disable until Diag is rewired
       Diag(NewDefaultLoc, diag::err_template_param_default_arg_redefinition);
       Diag(OldDefaultLoc, diag::note_template_param_prev_default_arg);
+#endif
       Invalid = true;
-    } else if (MissingDefaultArg && TPC != TPC_FunctionTemplate) {
+    } else if (Complain && MissingDefaultArg && TPC != TPC_FunctionTemplate) {
       // C++ [temp.param]p11:
       //   If a template-parameter of a class template has a default
       //   template-argument, each subsequent template-parameter shall either
@@ -5046,7 +5107,11 @@ bool Sema::CheckTemplateTypeArgument(TemplateTypeParmDecl *Param,
     return true;
 
   // Add the converted template type argument.
-  ArgType = Context.getCanonicalType(ArgType);
+  if (!HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+    ArgType = Context.getCanonicalType(ArgType);
+  } else {
+    ArgType = ArgType.getCanonicalType();
+  }
 
   // Objective-C ARC:
   //   If an explicitly-specified template argument type is a lifetime type
@@ -6215,8 +6280,15 @@ bool Sema::CheckTemplateArgument(TypeSourceInfo *ArgInfo) {
 
   if (Arg->isVariablyModifiedType()) {
     return Diag(SR.getBegin(), diag::err_variably_modified_template_arg) << Arg;
-  } else if (Context.hasSameUnqualifiedType(Arg, Context.OverloadTy)) {
-    return Diag(SR.getBegin(), diag::err_template_arg_overload_type) << SR;
+  } else if (!HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+    if (Context.hasSameUnqualifiedType(Arg, Context.OverloadTy)) {
+      return Diag(SR.getBegin(), diag::err_template_arg_overload_type) << SR;
+    }
+  } else {
+    if (Context.hasSameUnqualifiedType(Arg.getCanonicalType(),
+                                       Context.OverloadTy)) {
+      return Diag(SR.getBegin(), diag::err_template_arg_overload_type) << SR;
+    }
   }
 
   // C++03 [temp.arg.type]p2:
@@ -6228,7 +6300,11 @@ bool Sema::CheckTemplateArgument(TypeSourceInfo *ArgInfo) {
   // a warning.
   if (LangOpts.CPlusPlus11 || Arg->hasUnnamedOrLocalType()) {
     UnnamedLocalNoLinkageFinder Finder(*this, SR);
-    (void)Finder.Visit(Context.getCanonicalType(Arg));
+    if (!HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+      (void)Finder.Visit(Context.getCanonicalType(Arg));
+    } else {
+      (void)Finder.Visit(Arg.getCanonicalType());
+    }
   }
 
   return false;
diff --git a/lib/Sema/SemaTemplateInstantiate.cpp b/lib/Sema/SemaTemplateInstantiate.cpp
index 74889aa3..78b2b7e5 100644
--- a/lib/Sema/SemaTemplateInstantiate.cpp
+++ b/lib/Sema/SemaTemplateInstantiate.cpp
@@ -1826,7 +1826,8 @@ TemplateInstantiator::TransformTemplateTypeParmType(TypeLocBuilder &TLB,
 
     // TODO: only do this uniquing once, at the start of instantiation.
     QualType Result
-      = getSema().Context.getSubstTemplateTypeParmType(T, Replacement);
+      = getSema().Context.getSubstTemplateTypeParmType(T, Replacement,
+                          HackForDefaultTemplateArg::AllowNonCanonicalSubst());
     SubstTemplateTypeParmTypeLoc NewTL
       = TLB.push<SubstTemplateTypeParmTypeLoc>(Result);
     NewTL.setNameLoc(TL.getNameLoc());
@@ -1868,7 +1869,8 @@ TemplateInstantiator::TransformSubstTemplateTypeParmPackType(
 
   Result = getSema().Context.getSubstTemplateTypeParmType(
                                       TL.getTypePtr()->getReplacedParameter(),
-                                                          Result);
+                                                          Result,
+                           HackForDefaultTemplateArg::AllowNonCanonicalSubst());
   SubstTemplateTypeParmTypeLoc NewTL
     = TLB.push<SubstTemplateTypeParmTypeLoc>(Result);
   NewTL.setNameLoc(TL.getNameLoc());
@@ -3173,6 +3175,16 @@ getPatternForClassTemplateSpecialization(
     }
     Pattern = PartialSpec;
   } else {
+    //   -- If no matches are found, the instantiation is generated
+    //      from the primary template.
+
+    // Try first to get it externally:
+    if(S.getExternalSource()) {
+      S.getExternalSource()->CompleteType(ClassTemplateSpec);
+      if (ClassTemplateSpec->getDefinition())
+        return ClassTemplateSpec;
+    }
+
     ClassTemplateDecl *Template = ClassTemplateSpec->getSpecializedTemplate();
     while (Template->getInstantiatedFromMemberTemplate()) {
       // If we've found an explicit specialization of this class template,
diff --git a/lib/Sema/SemaType.cpp b/lib/Sema/SemaType.cpp
index bca21b35..6b99740a 100644
--- a/lib/Sema/SemaType.cpp
+++ b/lib/Sema/SemaType.cpp
@@ -8643,7 +8643,9 @@ bool Sema::RequireCompleteTypeImpl(SourceLocation Loc, QualType T,
 
     // Give the external AST source a chance to complete the type.
     if (auto *Source = Context.getExternalSource()) {
-      if (Tag && Tag->hasExternalLexicalStorage())
+      // AXEL: allows ROOT to autoload/-parse template specializations before
+      // trying to instantiate through the template definition. See ROOT-7462.
+      if (Tag /*&& Tag->hasExternalLexicalStorage()*/)
           Source->CompleteType(Tag);
       if (IFace && IFace->hasExternalLexicalStorage())
           Source->CompleteType(IFace);
diff --git a/lib/Sema/TreeTransform.h b/lib/Sema/TreeTransform.h
index d8a5b6ad..2b2cfbf4 100644
--- a/lib/Sema/TreeTransform.h
+++ b/lib/Sema/TreeTransform.h
@@ -41,6 +41,8 @@
 #include "llvm/Support/ErrorHandling.h"
 #include <algorithm>
 
+#include "HackForDefaultTemplateArg.h"
+
 using namespace llvm::omp;
 
 namespace clang {
@@ -4116,12 +4118,21 @@ NestedNameSpecifierLoc TreeTransform<Derived>::TransformNestedNameSpecifierLoc(
       if (!TL)
         return NestedNameSpecifierLoc();
 
-      if (TL.getType()->isDependentType() || TL.getType()->isRecordType() ||
+      // When using ROOT the type being passed can still be sugared
+      // so that we can construct template instance name with template
+      // default added that still uses the original spelling of the 
+      // arguments. [This is part of adding support for opaque typedef
+      // and 'shorter' names]
+      QualType tlType = TL.getType();
+      if (HackForDefaultTemplateArg::AllowNonCanonicalSubst()) {
+        tlType = tlType->getCanonicalTypeInternal().getUnqualifiedType();
+      }
+      if (tlType->isDependentType() || tlType->isRecordType() ||
           (SemaRef.getLangOpts().CPlusPlus11 &&
-           TL.getType()->isEnumeralType())) {
-        assert(!TL.getType().hasLocalQualifiers() &&
+           tlType->isEnumeralType())) {
+        assert(!tlType.hasLocalQualifiers() &&
                "Can't get cv-qualifiers here");
-        if (TL.getType()->isEnumeralType())
+        if (tlType->isEnumeralType())
           SemaRef.Diag(TL.getBeginLoc(),
                        diag::warn_cxx98_compat_enum_nested_name_spec);
         SS.Extend(SemaRef.Context, /*FIXME:*/ SourceLocation(), TL,
@@ -6324,7 +6335,7 @@ QualType TreeTransform<Derived>::TransformSubstTemplateTypeParmType(
   Replacement = SemaRef.Context.getCanonicalType(Replacement);
   QualType Result
     = SemaRef.Context.getSubstTemplateTypeParmType(T->getReplacedParameter(),
-                                                   Replacement);
+                                                   Replacement,false);
 
   // Propagate type-source information.
   SubstTemplateTypeParmTypeLoc NewTL
diff --git a/lib/Serialization/ASTReader.cpp b/lib/Serialization/ASTReader.cpp
index 1722572f..2a925707 100644
--- a/lib/Serialization/ASTReader.cpp
+++ b/lib/Serialization/ASTReader.cpp
@@ -1680,6 +1680,12 @@ Token ASTReader::ReadToken(ModuleFile &F, const RecordDataImpl &Record,
     Tok.setIdentifierInfo(II);
   Tok.setKind((tok::TokenKind)Record[Idx++]);
   Tok.setFlag((Token::TokenFlags)Record[Idx++]);
+  if (Tok.isLiteral()) {
+     const RecordData& RD = reinterpret_cast<const RecordData&>(Record);
+     std::string* Lit = new std::string(ReadString(RD, Idx));
+     TokenLiteralDataLoaded.push_back(Lit);
+     Tok.setLiteralData(Lit->c_str());
+  }
   return Tok;
 }
 
@@ -2093,7 +2099,7 @@ void ASTReader::markIdentifierUpToDate(IdentifierInfo *II) {
 
   // Update the generation for this identifier.
   if (getContext().getLangOpts().Modules)
-    IdentifierGeneration[II] = getGeneration();
+    IdentifierGeneration[II] = getGenerationOrNull();
 }
 
 void ASTReader::resolvePendingMacro(IdentifierInfo *II,
@@ -2344,8 +2350,12 @@ InputFile ASTReader::getInputFile(ModuleFile &F, unsigned ID, bool Complain) {
 
   // For an overridden file, create a virtual file with the stored
   // size/timestamp.
-  if ((Overridden || Transient) && !File)
+  bool DisableValidation = bool(PP.getPreprocessorOpts().DisablePCHOrModuleValidation &
+                                DisableValidationForModuleKind::All);
+  if ((Overridden || Transient) && (!File || DisableValidation)) {
     File = FileMgr.getVirtualFileRef(Filename, StoredSize, StoredTime);
+    Overridden = true;
+  }
 
   if (!File) {
     if (Complain) {
@@ -2637,9 +2647,10 @@ ASTReader::ReadControlBlock(ModuleFile &F,
       // All user input files reside at the index range [0, NumUserInputs), and
       // system input files reside at [NumUserInputs, NumInputs). For explicitly
       // loaded module files, ignore missing inputs.
-      if (!DisableValidation && F.Kind != MK_ExplicitModule &&
-          F.Kind != MK_PrebuiltModule) {
+      bool Validate = !DisableValidation && F.Kind != MK_ExplicitModule &&
+        F.Kind != MK_PrebuiltModule;
         bool Complain = (ClientLoadCapabilities & ARR_OutOfDate) == 0;
+        Complain &= Validate;
 
         // If we are reading a module, we will create a verification timestamp,
         // so we verify all input files.  Otherwise, verify only user input
@@ -2652,12 +2663,13 @@ ASTReader::ReadControlBlock(ModuleFile &F,
              F.Kind == MK_ImplicitModule))
           N = NumInputs;
 
-        for (unsigned I = 0; I < N; ++I) {
+        for (unsigned I = 0; I < NumInputs; ++I) {
+          if (I == N)
+            Complain = false;
           InputFile IF = getInputFile(F, I+1, Complain);
-          if (!IF.getFile() || IF.isOutOfDate())
+          if (Validate && (!IF.getFile() || IF.isOutOfDate()))
             return OutOfDate;
         }
-      }
 
       if (Listener)
         Listener->visitModuleFile(F.FileName, F.Kind);
@@ -2702,7 +2714,7 @@ ASTReader::ReadControlBlock(ModuleFile &F,
           //
           // FIXME: Allow this for files explicitly specified with -include-pch.
           bool AllowCompatibleConfigurationMismatch =
-              F.Kind == MK_ExplicitModule || F.Kind == MK_PrebuiltModule;
+            F.Kind == MK_ExplicitModule || F.Kind == MK_PrebuiltModule;
 
           ASTReadResult Result =
               ReadOptionsBlock(Stream, ClientLoadCapabilities,
@@ -2838,6 +2850,26 @@ ASTReader::ReadControlBlock(ModuleFile &F,
         else
           SkipPath(Record, Idx);
 
+        // Check if ImportedFile exists on disk
+        if (!llvm::sys::fs::is_directory(ImportedFile)) {
+          StringRef ModuleName = llvm::sys::path::filename(ImportedFile.c_str());
+          ModuleName.consume_back(".pcm");
+          // Get clang::Module pointer by looking up the module name
+          HeaderSearch &HS = PP.getHeaderSearchInfo();
+          Module *M = HS.lookupModule(ModuleName, /*AllowSearch*/ true,
+                                      /*AllowExtraModuleMapSearch*/ true);
+          if (M) {
+            std::string Path = HS.getPrebuiltModuleFileName(M->Name);
+                           if (Path.empty())
+              Path = HS.getCachedModuleFileName(M->Name,
+                   HS.getModuleMap().getModuleMapFileForUniquing(M)->getName());
+            // FIXME: Add a hash comparison to check if ImportedFile's hash and the
+            // new Modules Path's hash matches or not.
+            if (!Path.empty())
+              ImportedFile = Path;
+          }
+        }
+
         // If our client can't cope with us being out of date, we can't cope with
         // our dependency being missing.
         unsigned Capabilities = ClientLoadCapabilities;
@@ -3866,11 +3898,30 @@ void ASTReader::ReadModuleOffsetMap(ModuleFile &F) const {
                           ? ModuleMgr.lookupByModuleName(Name)
                           : ModuleMgr.lookupByFileName(Name));
     if (!OM) {
-      std::string Msg =
-          "SourceLocation remap refers to unknown module, cannot find ";
-      Msg.append(std::string(Name));
-      Error(Msg);
-      return;
+      StringRef ModuleName = llvm::sys::path::filename(Name);
+      ModuleName.consume_back(".pcm");
+      HeaderSearch &HS = PP.getHeaderSearchInfo();
+      Module *M = HS.lookupModule(ModuleName, /*AllowSearch*/ true,
+                                  /*AllowExtraModuleMapSearch*/ true);
+      std::string Path;
+      // If module definition exists in modulemap, search the modulepath in HeaderSearchInfo
+      if (M) {
+        Path = HS.getPrebuiltModuleFileName(M->Name);
+        if (Path.empty())
+          Path = HS.getCachedModuleFileName(M->Name,
+                   HS.getModuleMap().getModuleMapFileForUniquing(M)->getName());
+
+      }
+
+      StringRef NewName = StringRef(Path);
+      OM = ModuleMgr.lookupByFileName(NewName);
+      if (!OM) {
+        std::string Msg =
+           "SourceLocation remap refers to unknown module, cannot find ";
+        Msg.append(std::string(NewName));
+        Error(Msg);
+        return;
+      }
     }
 
     SourceLocation::UIntTy SLocOffset =
@@ -3966,9 +4017,13 @@ ASTReader::ReadModuleMapFileBlock(RecordData &Record, ModuleFile &F,
 
     assert(M && M->Name == F.ModuleName && "found module with different name");
 
+    // Check any additional module map files (e.g. module.private.modulemap)
+    // that are not in the pcm.
+    bool DisableValidation = PP.getPreprocessorOpts().DisablePCHOrModuleValidation !=
+                                  DisableValidationForModuleKind::None;
     // Check the primary module map file.
     auto StoredModMap = FileMgr.getFile(F.ModuleMapPath);
-    if (!StoredModMap || *StoredModMap != ModMap) {
+    if (!DisableValidation && (!StoredModMap || *StoredModMap != ModMap)) {
       assert(ModMap && "found module is missing module map file");
       assert((ImportedBy || F.Kind == MK_ImplicitModule) &&
              "top-level import should be verified");
@@ -3993,8 +4048,7 @@ ASTReader::ReadModuleMapFileBlock(RecordData &Record, ModuleFile &F,
       AdditionalStoredMaps.insert(*SF);
     }
 
-    // Check any additional module map files (e.g. module.private.modulemap)
-    // that are not in the pcm.
+    if (!DisableValidation) {
     if (auto *AdditionalModuleMaps = Map.getAdditionalModuleMapFiles(M)) {
       for (const FileEntry *ModMap : *AdditionalModuleMaps) {
         // Remove files that match
@@ -4017,6 +4071,7 @@ ASTReader::ReadModuleMapFileBlock(RecordData &Record, ModuleFile &F,
       return OutOfDate;
     }
   }
+  }
 
   if (Listener)
     Listener->ReadModuleMapFile(F.ModuleMapPath);
@@ -4512,11 +4567,10 @@ ASTReader::ReadASTCore(StringRef FileName,
                        unsigned ClientLoadCapabilities) {
   ModuleFile *M;
   std::string ErrorStr;
-  ModuleManager::AddModuleResult AddResult
-    = ModuleMgr.addModule(FileName, Type, ImportLoc, ImportedBy,
-                          getGeneration(), ExpectedSize, ExpectedModTime,
-                          ExpectedSignature, readASTFileSignature,
-                          M, ErrorStr);
+  ModuleManager::AddModuleResult AddResult =
+      ModuleMgr.addModule(FileName, Type, ImportLoc, ImportedBy,
+                          getGenerationOrNull(), ExpectedSize, ExpectedModTime,
+                          ExpectedSignature, readASTFileSignature, M, ErrorStr);
 
   switch (AddResult) {
   case ModuleManager::AlreadyLoaded:
@@ -7233,14 +7287,23 @@ void ASTReader::CompleteRedeclChain(const Decl *D) {
     }
   }
 
-  if (auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(D))
-    CTSD->getSpecializedTemplate()->LoadLazySpecializations();
-  if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(D))
-    VTSD->getSpecializedTemplate()->LoadLazySpecializations();
-  if (auto *FD = dyn_cast<FunctionDecl>(D)) {
-    if (auto *Template = FD->getPrimaryTemplate())
-      Template->LoadLazySpecializations();
+  RedeclarableTemplateDecl *Template = nullptr;
+  ArrayRef<TemplateArgument> Args;
+  if (auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(D)) {
+    Template = CTSD->getSpecializedTemplate();
+    Args = CTSD->getTemplateArgs().asArray();
+  } else if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(D)) {
+    Template = VTSD->getSpecializedTemplate();
+    Args = VTSD->getTemplateArgs().asArray();
+  } else if (auto *FD = dyn_cast<FunctionDecl>(D)) {
+    if (auto *Tmplt = FD->getPrimaryTemplate()) {
+      Template = Tmplt;
+      Args = FD->getTemplateSpecializationArgs()->asArray();
+    }
   }
+
+  if (Template)
+    Template->loadLazySpecializationsImpl(Args);
 }
 
 CXXCtorInitializer **
@@ -8231,7 +8294,7 @@ void ASTReader::ReadMethodPool(Selector Sel) {
   // Get the selector generation and update it to the current generation.
   unsigned &Generation = SelectorGeneration[Sel];
   unsigned PriorGeneration = Generation;
-  Generation = getGeneration();
+  Generation = getGenerationOrNull();
   SelectorOutOfDate[Sel] = false;
 
   // Search for methods defined with this selector.
@@ -11685,6 +11748,9 @@ ASTReader::ASTReader(Preprocessor &PP, InMemoryModuleCache &ModuleCache,
 ASTReader::~ASTReader() {
   if (OwnsDeserializationListener)
     delete DeserializationListener;
+  for (auto PStr: TokenLiteralDataLoaded) {
+     delete PStr;
+  }
 }
 
 IdentifierResolver &ASTReader::getIdResolver() {
diff --git a/lib/Serialization/ASTReaderDecl.cpp b/lib/Serialization/ASTReaderDecl.cpp
index ff79f91e..c47a239e 100644
--- a/lib/Serialization/ASTReaderDecl.cpp
+++ b/lib/Serialization/ASTReaderDecl.cpp
@@ -83,9 +83,9 @@ namespace clang {
     ASTReader::RecordLocation Loc;
     const DeclID ThisDeclID;
     const SourceLocation ThisDeclLoc;
-
     using RecordData = ASTReader::RecordData;
-
+    using LazySpecializationInfo
+      = RedeclarableTemplateDecl::LazySpecializationInfo;
     TypeID DeferredTypeID = 0;
     unsigned AnonymousDeclNumber;
     GlobalDeclID NamedDeclForTagDecl = 0;
@@ -131,9 +131,16 @@ namespace clang {
       return Record.readString();
     }
 
-    void readDeclIDList(SmallVectorImpl<DeclID> &IDs) {
+    LazySpecializationInfo ReadLazySpecializationInfo() {
+      DeclID ID = readDeclID();
+      unsigned Hash = Record.readInt();
+      bool IsPartial = Record.readInt();
+      return LazySpecializationInfo(ID, Hash, IsPartial);
+    }
+
+    void readDeclIDList(SmallVectorImpl<LazySpecializationInfo> &IDs) {
       for (unsigned I = 0, Size = Record.readInt(); I != Size; ++I)
-        IDs.push_back(readDeclID());
+        IDs.push_back(ReadLazySpecializationInfo());
     }
 
     Decl *readDecl() {
@@ -254,7 +261,7 @@ namespace clang {
 
     template <typename T> static
     void AddLazySpecializations(T *D,
-                                SmallVectorImpl<serialization::DeclID>& IDs) {
+                                SmallVectorImpl<LazySpecializationInfo>& IDs) {
       if (IDs.empty())
         return;
 
@@ -264,12 +271,11 @@ namespace clang {
       auto *&LazySpecializations = D->getCommonPtr()->LazySpecializations;
 
       if (auto &Old = LazySpecializations) {
-        IDs.insert(IDs.end(), Old + 1, Old + 1 + Old[0]);
-        llvm::sort(IDs);
+        IDs.insert(IDs.end(), Old + 1, Old + 1 + Old[0].DeclID);
+        std::sort(IDs.begin(), IDs.end());
         IDs.erase(std::unique(IDs.begin(), IDs.end()), IDs.end());
       }
-
-      auto *Result = new (C) serialization::DeclID[1 + IDs.size()];
+      auto *Result = new (C) LazySpecializationInfo[1 + IDs.size()];
       *Result = IDs.size();
       std::copy(IDs.begin(), IDs.end(), Result + 1);
 
@@ -307,7 +313,7 @@ namespace clang {
     void ReadFunctionDefinition(FunctionDecl *FD);
     void Visit(Decl *D);
 
-    void UpdateDecl(Decl *D, SmallVectorImpl<serialization::DeclID> &);
+    void UpdateDecl(Decl *D, llvm::SmallVectorImpl<LazySpecializationInfo>&);
 
     static void setNextObjCCategory(ObjCCategoryDecl *Cat,
                                     ObjCCategoryDecl *Next) {
@@ -2135,7 +2141,7 @@ void ASTDeclReader::VisitClassTemplateDecl(ClassTemplateDecl *D) {
   if (ThisDeclID == Redecl.getFirstID()) {
     // This ClassTemplateDecl owns a CommonPtr; read it to keep track of all of
     // the specializations.
-    SmallVector<serialization::DeclID, 32> SpecIDs;
+    SmallVector<LazySpecializationInfo, 32> SpecIDs;
     readDeclIDList(SpecIDs);
     ASTDeclReader::AddLazySpecializations(D, SpecIDs);
   }
@@ -2162,7 +2168,7 @@ void ASTDeclReader::VisitVarTemplateDecl(VarTemplateDecl *D) {
   if (ThisDeclID == Redecl.getFirstID()) {
     // This VarTemplateDecl owns a CommonPtr; read it to keep track of all of
     // the specializations.
-    SmallVector<serialization::DeclID, 32> SpecIDs;
+    SmallVector<LazySpecializationInfo, 32> SpecIDs;
     readDeclIDList(SpecIDs);
     ASTDeclReader::AddLazySpecializations(D, SpecIDs);
   }
@@ -2272,7 +2278,7 @@ void ASTDeclReader::VisitFunctionTemplateDecl(FunctionTemplateDecl *D) {
 
   if (ThisDeclID == Redecl.getFirstID()) {
     // This FunctionTemplateDecl owns a CommonPtr; read it.
-    SmallVector<serialization::DeclID, 32> SpecIDs;
+    SmallVector<LazySpecializationInfo, 32> SpecIDs;
     readDeclIDList(SpecIDs);
     ASTDeclReader::AddLazySpecializations(D, SpecIDs);
   }
@@ -4182,7 +4188,9 @@ void ASTReader::loadDeclUpdateRecords(PendingUpdateRecord &Record) {
   ProcessingUpdatesRAIIObj ProcessingUpdates(*this);
   DeclUpdateOffsetsMap::iterator UpdI = DeclUpdateOffsets.find(ID);
 
-  SmallVector<serialization::DeclID, 8> PendingLazySpecializationIDs;
+  using LazySpecializationInfo
+    = RedeclarableTemplateDecl::LazySpecializationInfo;
+  llvm::SmallVector<LazySpecializationInfo, 8> PendingLazySpecializationIDs;
 
   if (UpdI != DeclUpdateOffsets.end()) {
     auto UpdateOffsets = std::move(UpdI->second);
@@ -4453,7 +4461,7 @@ static void forAllLaterRedecls(DeclT *D, Fn F) {
 }
 
 void ASTDeclReader::UpdateDecl(Decl *D,
-   llvm::SmallVectorImpl<serialization::DeclID> &PendingLazySpecializationIDs) {
+        SmallVectorImpl<LazySpecializationInfo> &PendingLazySpecializationIDs) {
   while (Record.getIdx() < Record.size()) {
     switch ((DeclUpdateKind)Record.readInt()) {
     case UPD_CXX_ADDED_IMPLICIT_MEMBER: {
@@ -4470,7 +4478,7 @@ void ASTDeclReader::UpdateDecl(Decl *D,
 
     case UPD_CXX_ADDED_TEMPLATE_SPECIALIZATION:
       // It will be added to the template's lazy specialization set.
-      PendingLazySpecializationIDs.push_back(readDeclID());
+      PendingLazySpecializationIDs.push_back(ReadLazySpecializationInfo());
       break;
 
     case UPD_CXX_ADDED_ANONYMOUS_NAMESPACE: {
diff --git a/lib/Serialization/ASTReaderInternals.h b/lib/Serialization/ASTReaderInternals.h
index 265a77fd..1016c9b8 100644
--- a/lib/Serialization/ASTReaderInternals.h
+++ b/lib/Serialization/ASTReaderInternals.h
@@ -47,7 +47,7 @@ class ASTDeclContextNameLookupTrait {
 
 public:
   // Maximum number of lookup tables we allow before condensing the tables.
-  static const int MaxTables = 4;
+  static const int MaxTables = 256;
 
   /// The lookup result is a list of global declaration IDs.
   using data_type = SmallVector<DeclID, 4>;
diff --git a/lib/Serialization/ASTWriter.cpp b/lib/Serialization/ASTWriter.cpp
index 66c207ad..d0895a76 100644
--- a/lib/Serialization/ASTWriter.cpp
+++ b/lib/Serialization/ASTWriter.cpp
@@ -4183,6 +4183,8 @@ void ASTWriter::AddToken(const Token &Tok, RecordDataImpl &Record) {
   Record.push_back(Tok.getKind());
   // FIXME: Should translate token flags to a stable encoding.
   Record.push_back(Tok.getFlags());
+  if (Tok.isLiteral())
+    AddString(StringRef(Tok.getLiteralData(), Tok.getLength()), Record);
 }
 
 void ASTWriter::AddString(StringRef Str, RecordDataImpl &Record) {
@@ -4875,12 +4877,29 @@ void ASTWriter::WriteDeclUpdatesBlocks(RecordDataImpl &OffsetsRecord) {
 
       switch (Kind) {
       case UPD_CXX_ADDED_IMPLICIT_MEMBER:
-      case UPD_CXX_ADDED_TEMPLATE_SPECIALIZATION:
       case UPD_CXX_ADDED_ANONYMOUS_NAMESPACE:
         assert(Update.getDecl() && "no decl to add?");
         Record.push_back(GetDeclRef(Update.getDecl()));
         break;
-
+      case UPD_CXX_ADDED_TEMPLATE_SPECIALIZATION: {
+        const Decl *Spec = Update.getDecl();
+        assert(Spec && "no decl to add?");
+        Record.push_back(GetDeclRef(Spec));
+        ArrayRef<TemplateArgument> Args;
+        if (auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(Spec))
+          Args = CTSD->getTemplateArgs().asArray();
+        else if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(Spec))
+          Args = VTSD->getTemplateArgs().asArray();
+        else if (auto *FD = dyn_cast<FunctionDecl>(Spec))
+          Args = FD->getTemplateSpecializationArgs()->asArray();
+        assert(Args.size());
+        Record.push_back(TemplateArgumentList::ComputeODRHash(Args));
+        bool IsPartialSpecialization
+          = isa<ClassTemplatePartialSpecializationDecl>(Spec) ||
+          isa<VarTemplatePartialSpecializationDecl>(Spec);
+        Record.push_back(IsPartialSpecialization);
+        break;
+      }
       case UPD_CXX_ADDED_FUNCTION_DEFINITION:
         break;
 
diff --git a/lib/Serialization/ASTWriterDecl.cpp b/lib/Serialization/ASTWriterDecl.cpp
index e9315f67..6446cd70 100644
--- a/lib/Serialization/ASTWriterDecl.cpp
+++ b/lib/Serialization/ASTWriterDecl.cpp
@@ -173,11 +173,11 @@ namespace clang {
       Record.AddSourceLocation(typeParams->getRAngleLoc());
     }
 
-    /// Add to the record the first declaration from each module file that
-    /// provides a declaration of D. The intent is to provide a sufficient
-    /// set such that reloading this set will load all current redeclarations.
-    void AddFirstDeclFromEachModule(const Decl *D, bool IncludeLocal) {
-      llvm::MapVector<ModuleFile*, const Decl*> Firsts;
+    /// Collect the first declaration from each module file that provides a
+    /// declaration of D.
+    void CollectFirstDeclFromEachModule(const Decl *D, bool IncludeLocal,
+                            llvm::MapVector<ModuleFile*, const Decl*> &Firsts) {
+
       // FIXME: We can skip entries that we know are implied by others.
       for (const Decl *R = D->getMostRecentDecl(); R; R = R->getPreviousDecl()) {
         if (R->isFromASTFile())
@@ -185,10 +185,49 @@ namespace clang {
         else if (IncludeLocal)
           Firsts[nullptr] = R;
       }
+    }
+
+    /// Add to the record the first declaration from each module file that
+    /// provides a declaration of D. The intent is to provide a sufficient
+    /// set such that reloading this set will load all current redeclarations.
+    void AddFirstDeclFromEachModule(const Decl *D, bool IncludeLocal) {
+      llvm::MapVector<ModuleFile*, const Decl*> Firsts;
+      CollectFirstDeclFromEachModule(D, IncludeLocal, Firsts);
+
       for (const auto &F : Firsts)
         Record.AddDeclRef(F.second);
     }
 
+    /// Add to the record the first template specialization from each module
+    /// file that provides a declaration of D. We store the DeclId and an
+    /// ODRHash of the template arguments of D which should provide enough
+    /// information to load D only if the template instantiator needs it.
+    void AddFirstSpecializationDeclFromEachModule(const Decl *D,
+                                                  bool IncludeLocal) {
+      assert(isa<ClassTemplateSpecializationDecl>(D) ||
+             isa<VarTemplateSpecializationDecl>(D) || isa<FunctionDecl>(D) &&
+             "Must not be called with other decls");
+      llvm::MapVector<ModuleFile*, const Decl*> Firsts;
+      CollectFirstDeclFromEachModule(D, IncludeLocal, Firsts);
+
+      for (const auto &F : Firsts) {
+        Record.AddDeclRef(F.second);
+        ArrayRef<TemplateArgument> Args;
+        if (auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(D))
+          Args = CTSD->getTemplateArgs().asArray();
+        else if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(D))
+          Args = VTSD->getTemplateArgs().asArray();
+        else if (auto *FD = dyn_cast<FunctionDecl>(D))
+          Args = FD->getTemplateSpecializationArgs()->asArray();
+        assert(Args.size());
+        Record.push_back(TemplateArgumentList::ComputeODRHash(Args));
+        bool IsPartialSpecialization
+          = isa<ClassTemplatePartialSpecializationDecl>(D) ||
+          isa<VarTemplatePartialSpecializationDecl>(D);
+        Record.push_back(IsPartialSpecialization);
+      }
+    }
+
     /// Get the specialization decl from an entry in the specialization list.
     template <typename EntryType>
     typename RedeclarableTemplateDecl::SpecEntryTraits<EntryType>::DeclType *
@@ -201,7 +240,8 @@ namespace clang {
     decltype(T::PartialSpecializations) &getPartialSpecializations(T *Common) {
       return Common->PartialSpecializations;
     }
-    ArrayRef<Decl> getPartialSpecializations(FunctionTemplateDecl::Common *) {
+    MutableArrayRef<FunctionTemplateSpecializationInfo>
+    getPartialSpecializations(FunctionTemplateDecl::Common *) {
       return None;
     }
 
@@ -218,9 +258,11 @@ namespace clang {
         assert(!Common->LazySpecializations);
       }
 
-      ArrayRef<DeclID> LazySpecializations;
+      using LazySpecializationInfo
+        = RedeclarableTemplateDecl::LazySpecializationInfo;
+      ArrayRef<LazySpecializationInfo> LazySpecializations;
       if (auto *LS = Common->LazySpecializations)
-        LazySpecializations = llvm::makeArrayRef(LS + 1, LS[0]);
+        LazySpecializations = llvm::makeArrayRef(LS + 1, LS[0].DeclID);
 
       // Add a slot to the record for the number of specializations.
       unsigned I = Record.size();
@@ -236,12 +278,20 @@ namespace clang {
 
       for (auto *D : Specs) {
         assert(D->isCanonicalDecl() && "non-canonical decl in set");
-        AddFirstDeclFromEachModule(D, /*IncludeLocal*/true);
+        AddFirstSpecializationDeclFromEachModule(D, /*IncludeLocal*/true);
+      }
+      for (auto &SpecInfo : LazySpecializations) {
+        Record.push_back(SpecInfo.DeclID);
+        Record.push_back(SpecInfo.ODRHash);
+        Record.push_back(SpecInfo.IsPartial);
       }
-      Record.append(LazySpecializations.begin(), LazySpecializations.end());
 
-      // Update the size entry we added earlier.
-      Record[I] = Record.size() - I - 1;
+      // Update the size entry we added earlier. We linerized the
+      // LazySpecializationInfo members and we need to adjust the size as we
+      // will read them always together.
+      assert ((Record.size() - I - 1) % 3 == 0
+              && "Must be divisible by LazySpecializationInfo count!");
+      Record[I] = (Record.size() - I - 1) / 3;
     }
 
     /// Ensure that this template specialization is associated with the specified
diff --git a/lib/Serialization/GlobalModuleIndex.cpp b/lib/Serialization/GlobalModuleIndex.cpp
index 52ce17d9..c784d6ab 100644
--- a/lib/Serialization/GlobalModuleIndex.cpp
+++ b/lib/Serialization/GlobalModuleIndex.cpp
@@ -290,6 +290,13 @@ GlobalModuleIndex::getKnownModules(SmallVectorImpl<ModuleFile *> &ModuleFiles) {
   }
 }
 
+void GlobalModuleIndex::getKnownModuleFileNames(StringSet<> &ModuleFiles) {
+  ModuleFiles.clear();
+  for (unsigned I = 0, N = Modules.size(); I != N; ++I) {
+    ModuleFiles.insert(Modules[I].FileName);
+  }
+}
+
 void GlobalModuleIndex::getModuleDependencies(
        ModuleFile *File,
        SmallVectorImpl<ModuleFile *> &Dependencies) {
@@ -334,6 +341,32 @@ bool GlobalModuleIndex::lookupIdentifier(StringRef Name, HitSet &Hits) {
   return true;
 }
 
+bool GlobalModuleIndex::lookupIdentifier(StringRef Name, FileNameHitSet &Hits) {
+  Hits.clear();
+
+  // If there's no identifier index, there is nothing we can do.
+  if (!IdentifierIndex)
+    return false;
+
+  // Look into the identifier index.
+  ++NumIdentifierLookups;
+  IdentifierIndexTable &Table =
+      *static_cast<IdentifierIndexTable *>(IdentifierIndex);
+  IdentifierIndexTable::iterator Known = Table.find(Name);
+  if (Known == Table.end()) {
+    return false;
+  }
+
+  SmallVector<unsigned, 2> ModuleIDs = *Known;
+  for (unsigned I = 0, N = ModuleIDs.size(); I != N; ++I) {
+    assert(!Modules[ModuleIDs[I]].FileName.empty());
+    Hits.insert(Modules[ModuleIDs[I]].FileName);
+  }
+
+  ++NumIdentifierLookupHits;
+  return true;
+}
+
 bool GlobalModuleIndex::loadedModuleFile(ModuleFile *File) {
   // Look for the module in the global module index based on the module name.
   StringRef Name = File->ModuleName;
@@ -410,9 +443,6 @@ namespace {
 
   /// Builder that generates the global module index file.
   class GlobalModuleIndexBuilder {
-    FileManager &FileMgr;
-    const PCHContainerReader &PCHContainerRdr;
-
     /// Mapping from files to module file information.
     typedef llvm::MapVector<const FileEntry *, ModuleFileInfo> ModuleFilesMap;
 
@@ -452,12 +482,19 @@ namespace {
     }
 
   public:
-    explicit GlobalModuleIndexBuilder(
-        FileManager &FileMgr, const PCHContainerReader &PCHContainerRdr)
-        : FileMgr(FileMgr), PCHContainerRdr(PCHContainerRdr) {}
+    explicit GlobalModuleIndexBuilder(GlobalModuleIndex::UserDefinedInterestingIDs* ExternalIDs) {
+      if (!ExternalIDs)
+        return;
+
+      for (const auto & I : *ExternalIDs)
+        for (const FileEntry * J : I.getValue())
+          InterestingIdentifiers[I.getKey()].push_back(getModuleFileInfo(J).ID);
+    }
 
     /// Load the contents of the given module file into the builder.
-    llvm::Error loadModuleFile(const FileEntry *File);
+    ///
+    llvm::Error loadModuleFile(const FileEntry *File, FileManager &FileMgr,
+                               const PCHContainerReader &PCHContainerRdr);
 
     /// Write the index to the given bitstream.
     /// \returns true if an error occurred, false otherwise.
@@ -528,7 +565,9 @@ namespace {
   };
 }
 
-llvm::Error GlobalModuleIndexBuilder::loadModuleFile(const FileEntry *File) {
+llvm::Error GlobalModuleIndexBuilder::loadModuleFile(const FileEntry *File,
+                                                     FileManager &FileMgr,
+                                    const PCHContainerReader &PCHContainerRdr) {
   // Open the module file.
 
   auto Buffer = FileMgr.getBufferForFile(File, /*isVolatile=*/true);
@@ -764,7 +803,8 @@ bool GlobalModuleIndexBuilder::writeIndex(llvm::BitstreamWriter &Stream) {
         // Verify Signature.
         return true;
     } else if (Info.StoredSize != File->getSize() ||
-               Info.StoredModTime != File->getModificationTime())
+               (Info.StoredModTime &&
+                Info.StoredModTime != File->getModificationTime()))
       // Verify Size and ModTime.
       return true;
   }
@@ -851,7 +891,9 @@ bool GlobalModuleIndexBuilder::writeIndex(llvm::BitstreamWriter &Stream) {
 llvm::Error
 GlobalModuleIndex::writeIndex(FileManager &FileMgr,
                               const PCHContainerReader &PCHContainerRdr,
-                              StringRef Path) {
+                              StringRef Path,
+                       UserDefinedInterestingIDs *ExternalIDs /* = nullptr */) {
+
   llvm::SmallString<128> IndexPath;
   IndexPath += Path;
   llvm::sys::path::append(IndexPath, IndexFileName);
@@ -875,33 +917,35 @@ GlobalModuleIndex::writeIndex(FileManager &FileMgr,
   }
 
   // The module index builder.
-  GlobalModuleIndexBuilder Builder(FileMgr, PCHContainerRdr);
-
-  // Load each of the module files.
-  std::error_code EC;
-  for (llvm::sys::fs::directory_iterator D(Path, EC), DEnd;
-       D != DEnd && !EC;
-       D.increment(EC)) {
-    // If this isn't a module file, we don't care.
-    if (llvm::sys::path::extension(D->path()) != ".pcm") {
-      // ... unless it's a .pcm.lock file, which indicates that someone is
-      // in the process of rebuilding a module. They'll rebuild the index
-      // at the end of that translation unit, so we don't have to.
-      if (llvm::sys::path::extension(D->path()) == ".pcm.lock")
-        return llvm::createStringError(std::errc::device_or_resource_busy,
-                                       "someone else is building the index");
+  GlobalModuleIndexBuilder Builder(ExternalIDs);
+
+  if (!ExternalIDs) {
+    // Load each of the module files.
+    std::error_code EC;
+    for (llvm::sys::fs::directory_iterator D(Path, EC), DEnd;
+         D != DEnd && !EC;
+         D.increment(EC)) {
+      // If this isn't a module file, we don't care.
+      if (llvm::sys::path::extension(D->path()) != ".pcm") {
+        // ... unless it's a .pcm.lock file, which indicates that someone is
+        // in the process of rebuilding a module. They'll rebuild the index
+        // at the end of that translation unit, so we don't have to.
+        if (llvm::sys::path::extension(D->path()) == ".pcm.lock")
+          return llvm::createStringError(std::errc::device_or_resource_busy,
+                                         "someone else is building the index");
 
-      continue;
-    }
+        continue;
+      }
 
-    // If we can't find the module file, skip it.
-    auto ModuleFile = FileMgr.getFile(D->path());
-    if (!ModuleFile)
-      continue;
+      // If we can't find the module file, skip it.
+      auto ModuleFile = FileMgr.getFile(D->path());
+      if (!ModuleFile)
+        continue;
 
-    // Load this module file.
-    if (llvm::Error Err = Builder.loadModuleFile(*ModuleFile))
-      return Err;
+      // Load this module file.
+      if (auto Err = Builder.loadModuleFile(*ModuleFile, FileMgr, PCHContainerRdr))
+        return Err;
+    }
   }
 
   // The output buffer, into which the global index will be written.
diff --git a/lib/Serialization/ModuleManager.cpp b/lib/Serialization/ModuleManager.cpp
index 40ffa6cf..869578f3 100644
--- a/lib/Serialization/ModuleManager.cpp
+++ b/lib/Serialization/ModuleManager.cpp
@@ -232,8 +232,15 @@ ModuleManager::addModule(StringRef FileName, ModuleKind Type,
   // Read the signature eagerly now so that we can check it.  Avoid calling
   // ReadSignature unless there's something to check though.
   if (ExpectedSignature && checkSignature(ReadSignature(NewModule->Data),
-                                          ExpectedSignature, ErrorStr))
+                                          ExpectedSignature, ErrorStr)) {
+    // Try to remove the buffer.  If it can't be removed, then it was already
+    // validated by this process.
+    if (!getModuleCache().tryToDropPCM(NewModule->FileName)) {
+      const FileEntry *FE = NewModule->File;
+      FileMgr.invalidateCache(const_cast<FileEntry*>(FE));
+    }
     return OutOfDate;
+  }
 
   // We're keeping this module.  Store it everywhere.
   Module = Modules[Entry] = NewModule.get();
@@ -285,6 +292,8 @@ void ModuleManager::removeModules(ModuleIterator First, ModuleMap *modMap) {
   for (ModuleIterator victim = First; victim != Last; ++victim) {
     Modules.erase(victim->File);
 
+    const FileEntry *FE = victim->File;
+    FileMgr.invalidateCache(const_cast<FileEntry*>(FE));
     if (modMap) {
       StringRef ModuleName = victim->ModuleName;
       if (Module *mod = modMap->findModule(ModuleName)) {
-- 
2.34.1

