From 828bc87c88d2fd66b1a805a59f8f08fd1d8234b3 Mon Sep 17 00:00:00 2001
From: Chris Burr <christopher.burr@cern.ch>
Date: Tue, 13 Dec 2022 13:53:18 +0100
Subject: [PATCH 1/4] ROOT: include files

---
 include/clang/AST/ASTContext.h                | 18 +++-
 include/clang/AST/Decl.h                      |  2 +
 include/clang/AST/DeclCXX.h                   |  1 +
 include/clang/AST/DeclTemplate.h              | 37 +++++++-
 include/clang/AST/ExternalASTSource.h         | 14 +--
 include/clang/AST/Type.h                      |  8 +-
 include/clang/Basic/Diagnostic.h              |  6 +-
 include/clang/Basic/FileEntry.h               |  1 +
 include/clang/Basic/FileManager.h             |  9 ++
 include/clang/Basic/SourceLocation.h          |  1 +
 include/clang/Basic/SourceManager.h           | 21 ++++-
 include/clang/CodeGen/ModuleBuilder.h         | 10 +++
 include/clang/Frontend/CompilerInvocation.h   | 17 ++++
 include/clang/Lex/DirectoryLookup.h           |  3 +-
 include/clang/Lex/HeaderSearch.h              |  6 +-
 include/clang/Lex/Preprocessor.h              | 82 +++++++++++++++++-
 include/clang/Parse/Parser.h                  | 40 ++++++++-
 include/clang/Sema/Sema.h                     | 86 ++++++++++++++++++-
 include/clang/Serialization/ASTReader.h       |  9 ++
 .../clang/Serialization/GlobalModuleIndex.h   | 24 +++++-
 20 files changed, 360 insertions(+), 35 deletions(-)

diff --git a/include/clang/AST/ASTContext.h b/include/clang/AST/ASTContext.h
index 34299581..08b79abc 100644
--- a/include/clang/AST/ASTContext.h
+++ b/include/clang/AST/ASTContext.h
@@ -252,6 +252,10 @@ class ASTContext : public RefCountedBase<ASTContext> {
                                      ASTContext&>
     SubstTemplateTemplateParmPacks;
 
+  /// Generation number for this external AST source. Must be increased
+  /// whenever we might have added new redeclarations for existing decls.
+  uint32_t CurrentGeneration = 0;
+
   /// The set of nested name specifiers.
   ///
   /// This set is managed by the NestedNameSpecifier class.
@@ -661,6 +665,15 @@ public:
   /// use ParentMapContext::getParents() directly.
   template <typename NodeT> DynTypedNodeList getParents(const NodeT &Node);
 
+  uint32_t getGeneration() const { return CurrentGeneration; }
+  uint32_t incrementGeneration() {
+    uint32_t OldGeneration = CurrentGeneration;
+    CurrentGeneration++;
+    assert(CurrentGeneration > OldGeneration &&
+           "Overflowed generation counter");
+    return OldGeneration;
+  }
+
   const clang::PrintingPolicy &getPrintingPolicy() const {
     return PrintingPolicy;
   }
@@ -1531,7 +1544,8 @@ public:
                              QualType equivalentType);
 
   QualType getSubstTemplateTypeParmType(const TemplateTypeParmType *Replaced,
-                                        QualType Replacement) const;
+                                        QualType Replacement,
+                                        bool AllowNonCanonical = false) const;
   QualType getSubstTemplateTypeParmPackType(
                                           const TemplateTypeParmType *Replaced,
                                             const TemplateArgument &ArgPack);
@@ -3347,7 +3361,7 @@ typename clang::LazyGenerationalUpdatePtr<Owner, T, Update>::ValueType
   // include ASTContext.h. We explicitly instantiate it for all relevant types
   // in ASTContext.cpp.
   if (auto *Source = Ctx.getExternalSource())
-    return new (Ctx) LazyData(Source, Value);
+    return new (Ctx) LazyData(&Ctx, Source, Value);
   return Value;
 }
 
diff --git a/include/clang/AST/Decl.h b/include/clang/AST/Decl.h
index 510bf897..66842653 100644
--- a/include/clang/AST/Decl.h
+++ b/include/clang/AST/Decl.h
@@ -49,6 +49,8 @@
 #include <string>
 #include <utility>
 
+namespace cling { class DeclUnloader; }
+
 namespace clang {
 
 class ASTContext;
diff --git a/include/clang/AST/DeclCXX.h b/include/clang/AST/DeclCXX.h
index 0d5ad40f..88a1a8dd 100644
--- a/include/clang/AST/DeclCXX.h
+++ b/include/clang/AST/DeclCXX.h
@@ -261,6 +261,7 @@ class CXXRecordDecl : public RecordDecl {
   friend class ASTWriter;
   friend class DeclContext;
   friend class LambdaExpr;
+  friend class ::cling::DeclUnloader;
 
   friend void FunctionDecl::setPure(bool);
   friend void TagDecl::startDefinition();
diff --git a/include/clang/AST/DeclTemplate.h b/include/clang/AST/DeclTemplate.h
index cbaa287f..e6b261ed 100644
--- a/include/clang/AST/DeclTemplate.h
+++ b/include/clang/AST/DeclTemplate.h
@@ -261,6 +261,9 @@ public:
   static TemplateArgumentList *CreateCopy(ASTContext &Context,
                                           ArrayRef<TemplateArgument> Args);
 
+  /// \brief Create hash for the given arguments.
+  static unsigned ComputeODRHash(ArrayRef<TemplateArgument> Args);
+
   /// Construct a new, temporary template argument list on the stack.
   ///
   /// The template argument list does not own the template arguments
@@ -763,6 +766,26 @@ class RedeclarableTemplateDecl : public TemplateDecl,
   }
 
   void anchor() override;
+  struct LazySpecializationInfo {
+    uint32_t DeclID = ~0U;
+    unsigned ODRHash = ~0U;
+    bool IsPartial = false;
+    LazySpecializationInfo(uint32_t ID, unsigned Hash = ~0U,
+                           bool Partial = false)
+      : DeclID(ID), ODRHash(Hash), IsPartial(Partial) { }
+    LazySpecializationInfo() { }
+    bool operator<(const LazySpecializationInfo &Other) const {
+      return DeclID < Other.DeclID;
+    }
+    bool operator==(const LazySpecializationInfo &Other) const {
+      assert((DeclID != Other.DeclID || ODRHash == Other.ODRHash) &&
+             "Hashes differ!");
+      assert((DeclID != Other.DeclID || IsPartial == Other.IsPartial) &&
+             "Both must be the same kinds!");
+      return DeclID == Other.DeclID;
+    }
+  };
+
 protected:
   template <typename EntryType> struct SpecEntryTraits {
     using DeclType = EntryType;
@@ -803,7 +826,13 @@ protected:
     return SpecIterator<EntryType>(isEnd ? Specs.end() : Specs.begin());
   }
 
-  void loadLazySpecializationsImpl() const;
+  void loadLazySpecializationsImpl(bool OnlyPartial = false) const;
+
+  ///\returns true if any lazy specialization was loaded.
+  bool loadLazySpecializationsImpl(llvm::ArrayRef<TemplateArgument> Args,
+                                   TemplateParameterList *TPL = nullptr) const;
+
+  Decl *loadLazySpecializationImpl(LazySpecializationInfo &LazySpecInfo) const;
 
   template <class EntryType, typename ...ProfileArguments>
   typename SpecEntryTraits<EntryType>::DeclType*
@@ -830,7 +859,7 @@ protected:
     ///
     /// The first value in the array is the number of specializations/partial
     /// specializations that follow.
-    uint32_t *LazySpecializations = nullptr;
+    LazySpecializationInfo *LazySpecializations = nullptr;
   };
 
   /// Pointer to the common data shared by all declarations of this
@@ -2285,7 +2314,7 @@ public:
   friend class ASTDeclWriter;
 
   /// Load any lazily-loaded specializations from the external source.
-  void LoadLazySpecializations() const;
+  void LoadLazySpecializations(bool OnlyPartial = false) const;
 
   /// Get the underlying class declarations of the template.
   CXXRecordDecl *getTemplatedDecl() const {
@@ -3114,7 +3143,7 @@ public:
   friend class ASTDeclWriter;
 
   /// Load any lazily-loaded specializations from the external source.
-  void LoadLazySpecializations() const;
+  void LoadLazySpecializations(bool OnlyPartial = false) const;
 
   /// Get the underlying variable declarations of the template.
   VarDecl *getTemplatedDecl() const {
diff --git a/include/clang/AST/ExternalASTSource.h b/include/clang/AST/ExternalASTSource.h
index b1851afc..4b0f57a8 100644
--- a/include/clang/AST/ExternalASTSource.h
+++ b/include/clang/AST/ExternalASTSource.h
@@ -90,7 +90,7 @@ public:
   /// Get the current generation of this AST source. This number
   /// is incremented each time the AST source lazily extends an existing
   /// entity.
-  uint32_t getGeneration() const { return CurrentGeneration; }
+  uint32_t getGeneration(const ASTContext &C) const;
 
   /// Resolve a declaration ID into a declaration, potentially
   /// building a new declaration.
@@ -389,12 +389,14 @@ struct LazyGenerationalUpdatePtr {
   /// A cache of the value of this pointer, in the most recent generation in
   /// which we queried it.
   struct LazyData {
+    const ASTContext *Context;
     ExternalASTSource *ExternalSource;
     uint32_t LastGeneration = 0;
     T LastValue;
 
-    LazyData(ExternalASTSource *Source, T Value)
-        : ExternalSource(Source), LastValue(Value) {}
+    LazyData(const ASTContext *Context, ExternalASTSource *Source, T Value)
+        : Context(Context), ExternalSource(Source), LastGeneration(0),
+          LastValue(Value) {}
   };
 
   // Our value is represented as simply T if there is no external AST source.
@@ -436,8 +438,10 @@ public:
   /// Get the value of this pointer, updating its owner if necessary.
   T get(Owner O) {
     if (auto *LazyVal = Value.template dyn_cast<LazyData *>()) {
-      if (LazyVal->LastGeneration != LazyVal->ExternalSource->getGeneration()) {
-        LazyVal->LastGeneration = LazyVal->ExternalSource->getGeneration();
+      if (LazyVal->LastGeneration !=
+          LazyVal->ExternalSource->getGeneration(*LazyVal->Context)) {
+        LazyVal->LastGeneration =
+            LazyVal->ExternalSource->getGeneration(*LazyVal->Context);
         (LazyVal->ExternalSource->*Update)(O);
       }
       return LazyVal->LastValue;
diff --git a/include/clang/AST/Type.h b/include/clang/AST/Type.h
index 9f46d533..adb0d909 100644
--- a/include/clang/AST/Type.h
+++ b/include/clang/AST/Type.h
@@ -4848,10 +4848,12 @@ class SubstTemplateTypeParmType : public Type, public llvm::FoldingSetNode {
 
   // The original type parameter.
   const TemplateTypeParmType *Replaced;
+  QualType Replacement;
 
-  SubstTemplateTypeParmType(const TemplateTypeParmType *Param, QualType Canon)
+  SubstTemplateTypeParmType(const TemplateTypeParmType *Param,
+                            QualType ReplacementType, QualType Canon)
       : Type(SubstTemplateTypeParm, Canon, Canon->getDependence()),
-        Replaced(Param) {}
+        Replaced(Param), Replacement(ReplacementType) {}
 
 public:
   /// Gets the template parameter that was substituted for.
@@ -4862,7 +4864,7 @@ public:
   /// Gets the type that was substituted for the template
   /// parameter.
   QualType getReplacementType() const {
-    return getCanonicalTypeInternal();
+    return Replacement;
   }
 
   bool isSugared() const { return true; }
diff --git a/include/clang/Basic/Diagnostic.h b/include/clang/Basic/Diagnostic.h
index 3b915fb1..19acd97f 100644
--- a/include/clang/Basic/Diagnostic.h
+++ b/include/clang/Basic/Diagnostic.h
@@ -887,9 +887,9 @@ public:
     LastDiagLevel = Other.LastDiagLevel;
   }
 
-  /// Reset the state of the diagnostic object to its initial
-  /// configuration.
-  void Reset();
+  /// Reset the state of the diagnostic object to its initial configuration.
+  /// \param[in] soft - if true, doesn't reset the diagnostic mappings and state
+  void Reset(bool soft = false);
 
   //===--------------------------------------------------------------------===//
   // DiagnosticsEngine classification and reporting interfaces.
diff --git a/include/clang/Basic/FileEntry.h b/include/clang/Basic/FileEntry.h
index 6e91b42e..8b745fc9 100644
--- a/include/clang/Basic/FileEntry.h
+++ b/include/clang/Basic/FileEntry.h
@@ -365,6 +365,7 @@ public:
   FileEntryRef getLastRef() const { return *LastRef; }
 
   StringRef tryGetRealPathName() const { return RealPathName; }
+  bool isOpen() const { return (bool)File; }
   bool isValid() const { return IsValid; }
   off_t getSize() const { return Size; }
   unsigned getUID() const { return UID; }
diff --git a/include/clang/Basic/FileManager.h b/include/clang/Basic/FileManager.h
index 974771a8..f7c4cd13 100644
--- a/include/clang/Basic/FileManager.h
+++ b/include/clang/Basic/FileManager.h
@@ -32,6 +32,7 @@
 #include <map>
 #include <memory>
 #include <string>
+#include <set>
 
 namespace llvm {
 
@@ -105,6 +106,11 @@ class FileManager : public RefCountedBase<FileManager> {
   /// The canonical names of files and directories .
   llvm::DenseMap<const void *, llvm::StringRef> CanonicalNames;
 
+  std::set<const FileEntry*> FileEntriesToReread;
+
+  /// The canonical names of directories.
+  llvm::DenseMap<const DirectoryEntry *, llvm::StringRef> CanonicalDirNames;
+
   /// Storage for canonical names that we have computed.
   llvm::BumpPtrAllocator CanonicalNameStorage;
 
@@ -293,6 +299,9 @@ public:
   std::error_code getNoncachedStatValue(StringRef Path,
                                         llvm::vfs::Status &Result);
 
+  /// Remove the real file \p Entry from the cache.
+  void invalidateCache(FileEntry *Entry);
+
   /// If path is not absolute and FileSystemOptions set the working
   /// directory, the path is modified to be relative to the given
   /// working directory.
diff --git a/include/clang/Basic/SourceLocation.h b/include/clang/Basic/SourceLocation.h
index 540de23b..28810d21 100644
--- a/include/clang/Basic/SourceLocation.h
+++ b/include/clang/Basic/SourceLocation.h
@@ -431,6 +431,7 @@ public:
   /// \returns true if this source location comes before 'Loc', false otherwise.
   bool isBeforeInTranslationUnitThan(FullSourceLoc Loc) const {
     assert(Loc.isValid());
+    if (!SrcMgr) return true; // assume command line is before Loc
     assert(SrcMgr == Loc.SrcMgr && "Loc comes from another SourceManager!");
     return isBeforeInTranslationUnitThan((SourceLocation)Loc);
   }
diff --git a/include/clang/Basic/SourceManager.h b/include/clang/Basic/SourceManager.h
index cc29c24f..8bebe0af 100644
--- a/include/clang/Basic/SourceManager.h
+++ b/include/clang/Basic/SourceManager.h
@@ -243,7 +243,7 @@ public:
 
   /// Set the buffer.
   void setBuffer(std::unique_ptr<llvm::MemoryBuffer> B) {
-    IsBufferInvalid = false;
+    IsBufferInvalid = !B;
     Buffer = std::move(B);
   }
 
@@ -797,6 +797,8 @@ public:
 
   void clearIDTables();
 
+  void invalidateCache(FileID FID);
+
   /// Initialize this source manager suitably to replay the compilation
   /// described by \p Old. Requires that \p Old outlive \p *this.
   void initializeForReplay(const SourceManager &Old);
@@ -1468,24 +1470,35 @@ public:
 
   /// Returns whether \p Loc is located in a <built-in> file.
   bool isWrittenInBuiltinFile(SourceLocation Loc) const {
-    StringRef Filename(getPresumedLoc(Loc).getFilename());
+    PresumedLoc Presumed = getPresumedLoc(Loc);
+    if (Presumed.isInvalid())
+      return false;
+    StringRef Filename(Presumed.getFilename());
     return Filename.equals("<built-in>");
   }
 
   /// Returns whether \p Loc is located in a <command line> file.
   bool isWrittenInCommandLineFile(SourceLocation Loc) const {
-    StringRef Filename(getPresumedLoc(Loc).getFilename());
+    PresumedLoc Presumed = getPresumedLoc(Loc);
+    if (Presumed.isInvalid())
+      return false;
+    StringRef Filename(Presumed.getFilename());
     return Filename.equals("<command line>");
   }
 
   /// Returns whether \p Loc is located in a <scratch space> file.
   bool isWrittenInScratchSpace(SourceLocation Loc) const {
-    StringRef Filename(getPresumedLoc(Loc).getFilename());
+    PresumedLoc Presumed = getPresumedLoc(Loc);
+    if (Presumed.isInvalid())
+      return false;
+    StringRef Filename(Presumed.getFilename());
     return Filename.equals("<scratch space>");
   }
 
   /// Returns if a SourceLocation is in a system header.
   bool isInSystemHeader(SourceLocation Loc) const {
+    if (Loc.isInvalid())
+      return false;
     return isSystem(getFileCharacteristic(Loc));
   }
 
diff --git a/include/clang/CodeGen/ModuleBuilder.h b/include/clang/CodeGen/ModuleBuilder.h
index f9d056ed..91bb5f07 100644
--- a/include/clang/CodeGen/ModuleBuilder.h
+++ b/include/clang/CodeGen/ModuleBuilder.h
@@ -17,9 +17,11 @@
 
 namespace llvm {
   class Constant;
+  class GlobalValue;
   class LLVMContext;
   class Module;
   class StringRef;
+  class raw_ostream;
 }
 
 namespace clang {
@@ -84,9 +86,17 @@ public:
   ///   definition has been registered with this code generator.
   llvm::Constant *GetAddrOfGlobal(GlobalDecl decl, bool isForDefinition);
 
+  void print(llvm::raw_ostream& out);
+
   /// Create a new \c llvm::Module after calling HandleTranslationUnit. This
   /// enable codegen in interactive processing environments.
   llvm::Module* StartModule(llvm::StringRef ModuleName, llvm::LLVMContext &C);
+
+  void forgetGlobal(llvm::GlobalValue* GV);
+  void forgetDecl(const GlobalDecl& GD, llvm::StringRef MangledName);
+  llvm::Module* StartModule(llvm::StringRef ModuleName,
+                            llvm::LLVMContext& C,
+                            const CodeGenOptions& CGO);
 };
 
 /// CreateLLVMCodeGen - Create a CodeGenerator instance.
diff --git a/include/clang/Frontend/CompilerInvocation.h b/include/clang/Frontend/CompilerInvocation.h
index 2245439d..1c1a057e 100644
--- a/include/clang/Frontend/CompilerInvocation.h
+++ b/include/clang/Frontend/CompilerInvocation.h
@@ -22,6 +22,8 @@
 #include "clang/StaticAnalyzer/Core/AnalyzerOptions.h"
 #include "llvm/ADT/IntrusiveRefCntPtr.h"
 #include "llvm/ADT/ArrayRef.h"
+#include "llvm/Support/VirtualFileSystem.h"
+
 #include <memory>
 #include <string>
 
@@ -147,6 +149,9 @@ protected:
   /// Options controlling preprocessed output.
   PreprocessorOutputOptions PreprocessorOutputOpts;
 
+  /// List of overlay files
+  IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> Overlay = new llvm::vfs::OverlayFileSystem(llvm::vfs::getRealFileSystem());
+
 public:
   MigratorOptions &getMigratorOpts() { return MigratorOpts; }
   const MigratorOptions &getMigratorOpts() const { return MigratorOpts; }
@@ -162,6 +167,18 @@ public:
     return DependencyOutputOpts;
   }
 
+  void addOverlay(const IntrusiveRefCntPtr<llvm::vfs::FileSystem>& FS) {
+    Overlay->pushOverlay(FS);
+  }
+
+  IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> &getOverlay() {
+    return Overlay;
+  }
+
+  const IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> &getOverlay() const {
+    return Overlay;
+  }
+
   FileSystemOptions &getFileSystemOpts() { return FileSystemOpts; }
 
   const FileSystemOptions &getFileSystemOpts() const {
diff --git a/include/clang/Lex/DirectoryLookup.h b/include/clang/Lex/DirectoryLookup.h
index da2ae9fc..9e92a6e5 100644
--- a/include/clang/Lex/DirectoryLookup.h
+++ b/include/clang/Lex/DirectoryLookup.h
@@ -182,7 +182,8 @@ public:
              SmallVectorImpl<char> *RelativePath, Module *RequestingModule,
              ModuleMap::KnownHeader *SuggestedModule,
              bool &InUserSpecifiedSystemFramework, bool &IsFrameworkFound,
-             bool &IsInHeaderMap, SmallVectorImpl<char> &MappedName) const;
+             bool &IsInHeaderMap, SmallVectorImpl<char> &MappedName,
+             bool OpenFile = true) const;
 
 private:
   Optional<FileEntryRef> DoFrameworkLookup(
diff --git a/include/clang/Lex/HeaderSearch.h b/include/clang/Lex/HeaderSearch.h
index a35a394f..858d7254 100644
--- a/include/clang/Lex/HeaderSearch.h
+++ b/include/clang/Lex/HeaderSearch.h
@@ -416,7 +416,8 @@ public:
       SmallVectorImpl<char> *SearchPath, SmallVectorImpl<char> *RelativePath,
       Module *RequestingModule, ModuleMap::KnownHeader *SuggestedModule,
       bool *IsMapped, bool *IsFrameworkFound, bool SkipCache = false,
-      bool BuildSystemModule = false);
+      bool BuildSystemModule = false, bool OpenFile = true,
+      bool CacheFailures = true);
 
   /// Look up a subframework for the specified \#include file.
   ///
@@ -707,7 +708,8 @@ private:
   getFileAndSuggestModule(StringRef FileName, SourceLocation IncludeLoc,
                           const DirectoryEntry *Dir, bool IsSystemHeaderDir,
                           Module *RequestingModule,
-                          ModuleMap::KnownHeader *SuggestedModule);
+                          ModuleMap::KnownHeader *SuggestedModule,
+                          bool OpenFile = true, bool CacheFailures = true);
 
 public:
   /// Retrieve the module map.
diff --git a/include/clang/Lex/Preprocessor.h b/include/clang/Lex/Preprocessor.h
index fe2327f0..724a53aa 100644
--- a/include/clang/Lex/Preprocessor.h
+++ b/include/clang/Lex/Preprocessor.h
@@ -1145,6 +1145,11 @@ public:
     return appendDefMacroDirective(II, MI, MI->getDefinitionLoc());
   }
 
+  /// Remove a IdentifierInfo and MacroDirective from the history.
+  /// Given an IdentifierInfo and a MacroDirective we can remove them from
+  /// the macros vector.
+  void removeMacro(IdentifierInfo *II, MacroDirective *MD);
+
   /// Set a MacroDirective that was loaded from a PCH file.
   void setLoadedMacroDirective(IdentifierInfo *II, MacroDirective *ED,
                                MacroDirective *MD);
@@ -1374,6 +1379,74 @@ public:
                      IsReinject);
   }
 
+  /// A RAII object to temporarily reset PP's state and restore it.
+  class CleanupAndRestoreCacheRAII {
+  private:
+    Preprocessor &PP;
+    CachedTokensTy::size_type SavedCachedLexPos;
+    CachedTokensTy SavedCachedTokens;
+    std::vector<IncludeStackInfo> SavedStack;
+    Lexer *SavedCurLexer;
+    PreprocessorLexer *SavedCurPPLexer;
+    TokenLexer* SavedCurTokenLexer;
+    const DirectoryLookup *SavedCurDirLookup;
+    enum CurLexerKind SavedCurLexerKind;
+    unsigned SavedLexLevel;
+
+  public:
+    CleanupAndRestoreCacheRAII(Preprocessor &PP)
+      : PP(PP), SavedCachedLexPos(PP.CachedLexPos),
+        SavedCachedTokens(PP.CachedTokens),
+        SavedStack(std::move(PP.IncludeMacroStack)),
+        SavedCurLexer(PP.CurLexer.release()),
+        SavedCurPPLexer(PP.CurPPLexer),
+        SavedCurTokenLexer(PP.CurTokenLexer.release()),
+        SavedCurDirLookup(PP.CurDirLookup),
+        SavedCurLexerKind(PP.CurLexerKind),
+        SavedLexLevel(PP.LexLevel)
+    {
+      PP.CachedLexPos = 0;
+      PP.CachedTokens.clear();
+      PP.IncludeMacroStack.clear();
+      PP.CurLexer.reset(0);
+      PP.CurPPLexer = 0;
+      PP.CurTokenLexer.reset(0);
+      PP.CurDirLookup = 0;
+      PP.CurLexerKind = CLK_CachingLexer;
+      PP.LexLevel = 0;
+    }
+
+    void pop() {
+      if (SavedCurLexerKind == (enum CurLexerKind)~0U)
+        return;
+
+      //ExitCachingLexMode();
+      PP.CachedLexPos = SavedCachedLexPos;
+      PP.CachedTokens = SavedCachedTokens;
+      PP.IncludeMacroStack = std::move(SavedStack);
+      PP.CurLexer.reset(SavedCurLexer);
+      PP.CurPPLexer = SavedCurPPLexer;
+      PP.CurTokenLexer.reset(SavedCurTokenLexer);
+      PP.CurDirLookup = SavedCurDirLookup;
+      PP.CurLexerKind = SavedCurLexerKind;
+      PP.LexLevel = SavedLexLevel;
+
+      SavedCachedLexPos = 0;
+      SavedCachedTokens.clear();
+      SavedStack.clear();
+      SavedCurLexer = 0;
+      SavedCurPPLexer = 0;
+      SavedCurTokenLexer = 0;
+      SavedCurDirLookup = 0;
+      SavedCurLexerKind = (enum CurLexerKind)~0U;
+      SavedLexLevel = ~0U;
+    }
+
+    ~CleanupAndRestoreCacheRAII() {
+      pop();
+    }
+  };
+
   /// Pop the current lexer/macro exp off the top of the lexer stack.
   ///
   /// This should only be used in situations where the current state of the
@@ -1859,6 +1932,12 @@ public:
   void DumpMacro(const MacroInfo &MI) const;
   void dumpMacroInfo(const IdentifierInfo *II);
 
+  /// Print a Macro to an ostream used for ClangInternalState
+  /// Same as dump, but without orinting source location.
+  void printMacros(raw_ostream &OS) const;
+  void printMacro(const IdentifierInfo* II, const MacroDirective *MD,
+                  llvm::raw_ostream &OS) const;
+
   /// Given a location that specifies the start of a
   /// token, return a new location that specifies a character within the token.
   SourceLocation AdvanceToTokenCharacter(SourceLocation TokStart,
@@ -2017,7 +2096,8 @@ public:
              const DirectoryLookup *&CurDir, SmallVectorImpl<char> *SearchPath,
              SmallVectorImpl<char> *RelativePath,
              ModuleMap::KnownHeader *SuggestedModule, bool *IsMapped,
-             bool *IsFrameworkFound, bool SkipCache = false);
+             bool *IsFrameworkFound, bool SkipCache = false,
+             bool OpenFile = true, bool CacheFailures = true);
 
   /// Get the DirectoryLookup structure used to find the current
   /// FileEntry, if CurLexer is non-null and if applicable.
diff --git a/include/clang/Parse/Parser.h b/include/clang/Parse/Parser.h
index 8eb3f902..26b6815c 100644
--- a/include/clang/Parse/Parser.h
+++ b/include/clang/Parse/Parser.h
@@ -30,6 +30,8 @@
 #include <memory>
 #include <stack>
 
+namespace cling { class ParserStateRAII; }
+
 namespace clang {
   class PragmaHandler;
   class Scope;
@@ -52,6 +54,7 @@ namespace clang {
   struct OMPTraitSelector;
   struct OMPTraitSet;
   class OMPTraitInfo;
+  class DestroyTemplateIdAnnotationsRAIIObj;
 
 /// Parser - This implements a parser for the C family of languages.  After
 /// parsing units of the grammar, productions are invoked to handle whatever has
@@ -65,6 +68,8 @@ class Parser : public CodeCompletionHandler {
   friend class ObjCDeclContextSwitch;
   friend class ParenBraceBracketBalancer;
   friend class BalancedDelimiterTracker;
+  friend class DestroyTemplateIdAnnotationsRAIIObj;
+  friend class ::cling::ParserStateRAII;
 
   Preprocessor &PP;
 
@@ -429,8 +434,11 @@ class Parser : public CodeCompletionHandler {
   /// a statement expression and builds a suitable expression statement.
   StmtResult handleExprStmt(ExprResult E, ParsedStmtContext StmtCtx);
 
+  bool IsTemporary;
+
 public:
-  Parser(Preprocessor &PP, Sema &Actions, bool SkipFunctionBodies);
+  Parser(Preprocessor &PP, Sema &Actions, bool SkipFunctionBodies, 
+         bool isTemp = false);
   ~Parser() override;
 
   const LangOptions &getLangOpts() const { return PP.getLangOpts(); }
@@ -440,6 +448,34 @@ public:
   AttributeFactory &getAttrFactory() { return AttrFactory; }
 
   const Token &getCurToken() const { return Tok; }
+
+  /// A RAII object to temporarily reset PP's state and restore it.
+  class ParserCurTokRestoreRAII {
+  private:
+    Parser &P;
+    Token SavedTok;
+
+  public:
+    ParserCurTokRestoreRAII(Parser &P)
+      : P(P), SavedTok(P.Tok) 
+    {
+    }
+
+    void pop() {
+      if (SavedTok.is(tok::unknown))
+        return;
+
+      P.Tok = SavedTok;
+      
+      SavedTok.startToken();
+    }
+
+    ~ParserCurTokRestoreRAII() {
+      pop();
+    }
+  };
+
+
   Scope *getCurScope() const { return Actions.getCurScope(); }
   void incrementMSManglingNumber() const {
     return Actions.incrementMSManglingNumber();
@@ -1171,7 +1207,7 @@ public:
     return Diag(Tok, DiagID);
   }
 
-private:
+protected:
   void SuggestParentheses(SourceLocation Loc, unsigned DK,
                           SourceRange ParenRange);
   void CheckNestedObjCContexts(SourceLocation AtLoc);
diff --git a/include/clang/Sema/Sema.h b/include/clang/Sema/Sema.h
index d8b2546b..9d376ba6 100644
--- a/include/clang/Sema/Sema.h
+++ b/include/clang/Sema/Sema.h
@@ -150,6 +150,7 @@ namespace clang {
   typedef ArrayRef<std::pair<IdentifierInfo *, SourceLocation>> ModuleIdPath;
   class ModuleLoader;
   class MultiLevelTemplateArgumentList;
+  class MultiplexExternalSemaSource;
   class NamedDecl;
   class ObjCCategoryDecl;
   class ObjCCategoryImplDecl;
@@ -359,8 +360,9 @@ class Sema final {
   ///Source of additional semantic information.
   ExternalSemaSource *ExternalSource;
 
-  ///Whether Sema has generated a multiplexer and has to delete it.
-  bool isMultiplexExternalSource;
+  ///Source of additional semantic information if it is a multiplexer.
+  llvm::IntrusiveRefCntPtr<MultiplexExternalSemaSource>
+      MultiplexExternalSource;
 
   static bool mightHaveNonExternalLinkage(const DeclaratorDecl *FD);
 
@@ -1036,6 +1038,41 @@ public:
            isConstantEvaluatedOverride;
   }
 
+  /// A RAII object to temporarily push a decl context and scope.
+  class ContextAndScopeRAII {
+  private:
+    Sema &S;
+    DeclContext *SavedContext;
+    Scope *SavedScope;
+    ProcessingContextState SavedContextState;
+    QualType SavedCXXThisTypeOverride;
+
+  public:
+    ContextAndScopeRAII(Sema &S, DeclContext *ContextToPush, Scope *ScopeToPush)
+      : S(S), SavedContext(S.CurContext), SavedScope(S.CurScope),
+        SavedContextState(S.DelayedDiagnostics.pushUndelayed()),
+        SavedCXXThisTypeOverride(S.CXXThisTypeOverride)
+    {
+      assert(ContextToPush && "pushing null context");
+      S.CurContext = ContextToPush;
+      S.CurScope = ScopeToPush;
+    }
+
+    void pop() {
+      if (!SavedContext) return;
+      S.CurContext = SavedContext;
+      S.CurScope = SavedScope;
+      S.DelayedDiagnostics.popUndelayed(SavedContextState);
+      S.CXXThisTypeOverride = SavedCXXThisTypeOverride;
+      SavedContext = 0;
+      SavedScope = 0;
+    }
+
+    ~ContextAndScopeRAII() {
+      pop();
+    }
+  };
+
   /// RAII object to handle the state changes required to synthesize
   /// a function body.
   class SynthesizedFunctionScope {
@@ -1077,6 +1114,27 @@ public:
     }
   };
 
+  class DelayedInfoRAII {
+    Sema &S;
+    SmallVector<std::pair<const CXXMethodDecl*, const CXXMethodDecl*>, 2>
+      DelayedOverridingExceptionSpecChecks;
+    SmallVector<std::pair<FunctionDecl*, FunctionDecl*>, 2>
+      DelayedEquivalentExceptionSpecChecks;
+  public:
+    DelayedInfoRAII(Sema& S): S(S) {
+      std::swap(S.DelayedOverridingExceptionSpecChecks,
+                DelayedOverridingExceptionSpecChecks);
+      std::swap(S.DelayedEquivalentExceptionSpecChecks,
+                DelayedEquivalentExceptionSpecChecks);
+    }
+    ~DelayedInfoRAII() {
+      std::swap(S.DelayedOverridingExceptionSpecChecks,
+                DelayedOverridingExceptionSpecChecks);
+      std::swap(S.DelayedEquivalentExceptionSpecChecks,
+                DelayedEquivalentExceptionSpecChecks);
+    }
+  };
+
   /// WeakUndeclaredIdentifiers - Identifiers contained in
   /// \#pragma weak before declared. rare. may alias another
   /// identifier, declared or undeclared
@@ -6435,7 +6493,7 @@ public:
   StmtResult ActOnFinishFullStmt(Stmt *Stmt);
 
   // Marks SS invalid if it represents an incomplete type.
-  bool RequireCompleteDeclContext(CXXScopeSpec &SS, DeclContext *DC);
+  bool RequireCompleteDeclContext(CXXScopeSpec &SS, DeclContext *&DC);
   // Complete an enum decl, maybe without a scope spec.
   bool RequireCompleteEnumDecl(EnumDecl *D, SourceLocation L,
                                CXXScopeSpec *SS = nullptr);
@@ -7591,7 +7649,8 @@ public:
   bool CheckTemplateParameterList(TemplateParameterList *NewParams,
                                   TemplateParameterList *OldParams,
                                   TemplateParamListContext TPC,
-                                  SkipBodyInfo *SkipBody = nullptr);
+                                  SkipBodyInfo *SkipBody = nullptr,
+                                  bool Complain = true);
   TemplateParameterList *MatchTemplateParametersToScopeSpecifier(
       SourceLocation DeclStartLoc, SourceLocation DeclLoc,
       const CXXScopeSpec &SS, TemplateIdAnnotation *TemplateId,
@@ -9292,6 +9351,24 @@ public:
     }
   };
 
+  class SavePendingInstantiationsRAII {
+  public:
+    SavePendingInstantiationsRAII(Sema &S):
+      SavedPendingLocalImplicitInstantiations(S), S(S) {
+      SavedPendingInstantiations.swap(S.PendingInstantiations);
+    }
+
+    ~SavePendingInstantiationsRAII() {
+      assert(S.PendingInstantiations.empty() &&
+             "there shouldn't be any pending instantiations");
+      SavedPendingInstantiations.swap(S.PendingInstantiations);
+    }
+  private:
+    LocalEagerInstantiationScope SavedPendingLocalImplicitInstantiations;
+    Sema &S;
+    std::deque<PendingImplicitInstantiation> SavedPendingInstantiations;
+  };
+
   void PerformPendingInstantiations(bool LocalOnly = false);
 
   TypeSourceInfo *SubstType(TypeSourceInfo *T,
@@ -12798,6 +12875,7 @@ protected:
   friend class ASTReader;
   friend class ASTDeclReader;
   friend class ASTWriter;
+  friend class ::cling::DeclUnloader;
 
 public:
   /// Retrieve the keyword associated
diff --git a/include/clang/Serialization/ASTReader.h b/include/clang/Serialization/ASTReader.h
index 242b75ba..8ea16187 100644
--- a/include/clang/Serialization/ASTReader.h
+++ b/include/clang/Serialization/ASTReader.h
@@ -649,6 +649,9 @@ private:
   /// files.
   llvm::DenseSet<LoadedMacroInfo> LoadedUndefs;
 
+  /// \Token literal data loaded and owned by us.
+  std::vector<std::string *> TokenLiteralDataLoaded;
+
   using GlobalMacroMapType =
       ContinuousRangeMap<serialization::MacroID, ModuleFile *, 4>;
 
@@ -1291,6 +1294,12 @@ private:
         : Mod(Mod), ImportedBy(ImportedBy), ImportLoc(ImportLoc) {}
   };
 
+  uint32_t getGenerationOrNull() const {
+    if (ContextObj)
+      return getGeneration(*ContextObj);
+    return 0u;
+  }
+
   ASTReadResult ReadASTCore(StringRef FileName, ModuleKind Type,
                             SourceLocation ImportLoc, ModuleFile *ImportedBy,
                             SmallVectorImpl<ImportedModule> &Loaded,
diff --git a/include/clang/Serialization/GlobalModuleIndex.h b/include/clang/Serialization/GlobalModuleIndex.h
index 5f481262..d38ae6a9 100644
--- a/include/clang/Serialization/GlobalModuleIndex.h
+++ b/include/clang/Serialization/GlobalModuleIndex.h
@@ -16,11 +16,13 @@
 #define LLVM_CLANG_SERIALIZATION_GLOBALMODULEINDEX_H
 
 #include "llvm/ADT/DenseMap.h"
+#include <llvm/ADT/DenseSet.h>
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringMap.h"
 #include "llvm/ADT/StringRef.h"
 #include "llvm/Support/Error.h"
+#include "llvm/ADT/StringSet.h"
 #include <memory>
 #include <utility>
 
@@ -42,6 +44,12 @@ namespace serialization {
   class ModuleFile;
 }
 
+using llvm::SmallVector;
+using llvm::SmallVectorImpl;
+using llvm::StringRef;
+using llvm::StringSet;
+using serialization::ModuleFile;
+
 /// A global index for a set of module files, providing information about
 /// the identifiers within those module files.
 ///
@@ -54,8 +62,6 @@ namespace serialization {
 /// imported, and can be queried to determine which modules the current
 /// translation could or should load to fix a problem.
 class GlobalModuleIndex {
-  using ModuleFile = serialization::ModuleFile;
-
   /// Buffer containing the index file, which is lazily accessed so long
   /// as the global module index is live.
   std::unique_ptr<llvm::MemoryBuffer> Buffer;
@@ -121,6 +127,9 @@ class GlobalModuleIndex {
   GlobalModuleIndex &operator=(const GlobalModuleIndex &) = delete;
 
 public:
+  using UserDefinedInterestingIDs =
+    llvm::StringMap<llvm::SmallVector<const FileEntry*, 2>>;
+
   ~GlobalModuleIndex();
 
   /// Read a global index file for the given directory.
@@ -142,7 +151,9 @@ public:
   ///
   /// \param ModuleFiles Will be populated with the set of module files that
   /// have been indexed.
-  void getKnownModules(llvm::SmallVectorImpl<ModuleFile *> &ModuleFiles);
+  void getKnownModules(SmallVectorImpl<ModuleFile *> &ModuleFiles);
+
+  void getKnownModuleFileNames(StringSet<> &ModuleFiles);
 
   /// Retrieve the set of module files on which the given module file
   /// directly depends.
@@ -163,6 +174,9 @@ public:
   /// \returns true if the identifier is known to the index, false otherwise.
   bool lookupIdentifier(llvm::StringRef Name, HitSet &Hits);
 
+  typedef llvm::SmallDenseSet<llvm::StringRef, 4> FileNameHitSet;
+  bool lookupIdentifier(StringRef Name, FileNameHitSet &Hits);
+
   /// Note that the given module file has been loaded.
   ///
   /// \returns false if the global module index has information about this
@@ -182,9 +196,11 @@ public:
   /// creating modules.
   /// \param Path The path to the directory containing module files, into
   /// which the global index will be written.
+  /// \param Optionally pass already precomputed interesting identifiers.
   static llvm::Error writeIndex(FileManager &FileMgr,
                                 const PCHContainerReader &PCHContainerRdr,
-                                llvm::StringRef Path);
+                                StringRef Path,
+                              UserDefinedInterestingIDs *ExternalIDs = nullptr);
 };
 }
 
-- 
2.34.1

